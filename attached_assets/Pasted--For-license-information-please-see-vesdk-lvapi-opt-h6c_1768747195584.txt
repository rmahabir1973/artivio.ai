/*! For license information please see vesdk-lvapi-opt.h6c71al.js.LICENSE.txt */
var createVEModule = ( () => {
    var _scriptDir = import.meta.url;
    return function(moduleArg={}) {
        function GROWABLE_HEAP_I8() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAP8
        }
        function GROWABLE_HEAP_U8() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAPU8
        }
        function GROWABLE_HEAP_I16() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAP16
        }
        function GROWABLE_HEAP_U16() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAPU16
        }
        function GROWABLE_HEAP_I32() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAP32
        }
        function GROWABLE_HEAP_U32() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAPU32
        }
        function GROWABLE_HEAP_F32() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAPF32
        }
        function GROWABLE_HEAP_F64() {
            return wasmMemory.buffer != HEAP8.buffer && updateMemoryViews(),
            HEAPF64
        }
        var readyPromiseResolve, readyPromiseReject, library_bytenn, read_, readAsync, readBinary, wasmBinary, wasmMemory, wasmModule, EXITSTATUS, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64, wasmBinaryFile, functionsInTableMap, InternalError, embind_charCodes, BindingError, delayFunction, UnboundTypeError, _emscripten_get_now, GLctx, calledRun, Module = moduleArg;
        Module.ready = new Promise( (e, t) => {
            readyPromiseResolve = e,
            readyPromiseReject = t
        }
        ),
        Module.SIMD_MODE = 1,
        Module.BUILD_TYPE = "release",
        library_bytenn = ( () => {
            "use strict";
            var e = {
                6825: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGLContext = t.WebGLLocatedProgram = t.WebGLStorage = void 0;
                    let i = r(7693)
                      , n = r(2810)
                      , o = r(8137)
                      , a = r(2638);
                    class s {
                        constructor(e, t, r, i, n=!0) {
                            this.context = e,
                            this.texture = t,
                            this.layout = r,
                            this.type = i,
                            this.owned = n
                        }
                        get width() {
                            return this.layout.folding.w
                        }
                        get height() {
                            return this.layout.folding.h
                        }
                        download(e) {
                            this.stagedArray && this.stagedArray.length == this.layout.folding.w * this.layout.folding.h * 4 || (this.stagedArray = new Float32Array(this.layout.folding.w * this.layout.folding.h * 4));
                            let t = this.context.readTexture(this, this.stagedArray)
                              , r = this.layout.reorderAsData(t);
                            return t = null,
                            r
                        }
                        downloadOrigin(e) {
                            return e ? this.context.readTexture(this, e) : this.context.readTexture(this)
                        }
                    }
                    t.WebGLStorage = s;
                    class u {
                        constructor(e, t, r) {
                            this.program = e,
                            this.position = t,
                            this.coord = r
                        }
                    }
                    t.WebGLLocatedProgram = u,
                    t.WebGLContext = class {
                        constructor(e, t, r, i) {
                            this.options = e,
                            this.gl = t,
                            this.framebuffer = r,
                            this.vertexBuffer = i,
                            this.recyclingTextures = [],
                            this.recyclingPrograms = {},
                            this.reuseTexture = !0,
                            this.reuseProgram = !0,
                            this.flushInterval = 2,
                            this.lastFlushTime = 0,
                            this.recycleFragShaders = new Map,
                            this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE) || 4096,
                            this._maxTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS) || 16,
                            this.defaultVertexShader = this.compileShader("precision highp float;\nattribute vec3 position;\nattribute vec2 textureCoord;\nvarying vec2 TexCoords;\nvoid main() {\n    gl_Position = vec4(position, 1.0);\n    TexCoords = textureCoord;\n}", this.gl.VERTEX_SHADER),
                            this.queryTimerExtension = this.getQueryTimerExtension(),
                            this.parallelShaderCompileExtension = t.getExtension("KHR_parallel_shader_compile"),
                            this.glVersion = -1 != t.getParameter(t.VERSION).indexOf("WebGL 2.0") ? 2 : 1,
                            this.isFenceEnable = null !== t?.fenceSync
                        }
                        get maxTextureSize() {
                            return this._maxTextureSize
                        }
                        get maxTextureImageUnits() {
                            return this._maxTextureImageUnits
                        }
                        get precision() {
                            let e = "";
                            switch (this.options.precision) {
                            case a.WebGLPrecision.Low:
                                e = "precision lowp";
                                break;
                            case a.WebGLPrecision.Medium:
                                e = "precision mediump";
                                break;
                            case a.WebGLPrecision.High:
                            default:
                                e = "precision highp"
                            }
                            return `${e} float;
precision highp int;
${e} sampler2D;`
                        }
                        isWebGL2() {
                            return -1 != this.gl.getParameter(this.gl.VERSION).indexOf("WebGL 2.0")
                        }
                        isWebGL1() {
                            return -1 != this.gl.getParameter(this.gl.VERSION).indexOf("WebGL 1.0")
                        }
                        dispose() {
                            this.deleteShader(this.defaultVertexShader),
                            this.gl.deleteFramebuffer(this.framebuffer),
                            this.gl.deleteBuffer(this.vertexBuffer),
                            this.recyclingTextures.forEach(e => this.gl.deleteTexture(e.texture)),
                            Object.values(this.recyclingPrograms).forEach(e => this.gl.deleteProgram(e.program))
                        }
                        alloc(e) {
                            n.trace.assert( () => !e.storage || e.storage instanceof s && e.storage.context == this),
                            this.releaseTexture(e.storage),
                            e.storage = this.allocTexture(e.type, o.WebGLLayout.fold(e.shape, this))
                        }
                        release(e) {
                            n.trace.assert( () => !e.storage || e.storage instanceof s && e.storage.context == this),
                            this.releaseTexture(e.storage)
                        }
                        checkError(e) {
                            let t;
                            let r = this.gl
                              , i = r.getError();
                            switch (i) {
                            case r.NO_ERROR:
                                return;
                            case r.INVALID_ENUM:
                                t = "INVALID_ENUM";
                                break;
                            case r.INVALID_VALUE:
                                t = "INVALID_VALUE";
                                break;
                            case r.INVALID_OPERATION:
                                t = "INVALID_OPERATION";
                                break;
                            case r.INVALID_FRAMEBUFFER_OPERATION:
                                t = "INVALID_FRAMEBUFFER_OPERATION";
                                break;
                            case r.OUT_OF_MEMORY:
                                t = "OUT_OF_MEMORY";
                                break;
                            case r.CONTEXT_LOST_WEBGL:
                                t = "CONTEXT_LOST_WEBGL";
                                break;
                            default:
                                t = "Unknown WebGL Error: " + i.toString(16)
                            }
                            throw Error(`${e || ""}: ${t}`)
                        }
                        recycleTexture(e, t) {
                            if (!this.reuseTexture)
                                return;
                            let r = this.recyclingTextures.findIndex(r => r.width == e.folding.w && r.height == e.folding.h && r.type == t);
                            if (r < 0)
                                return;
                            let i = this.recyclingTextures[r];
                            return this.recyclingTextures.splice(r, 1),
                            new s(this,i.texture,e,t)
                        }
                        allocTexture(e, t) {
                            let r;
                            (this.maxTextureSize < t.folding.w || this.maxTextureSize < t.folding.h) && n.trace.error( () => `texture limit: ${this.maxTextureSize} < ${t.folding.w} x ${t.folding.h}`);
                            let o = null;
                            if (null == e ? r = i.DataType.Float32 : "number" == typeof e ? r = e : (r = i.typedArrayGetType(e),
                            o = e instanceof Float32Array ? e : new Float32Array(e)),
                            null == o) {
                                let e = this.recycleTexture(t, r);
                                if (e)
                                    return e
                            }
                            let a = this.gl
                              , u = a.createTexture();
                            if (!u)
                                throw Error("[webgl1] fail to create texture.");
                            let l = o ? this.dataTexType() : this.nullTexType()
                              , c = this.internalTexFormat();
                            return a.bindTexture(a.TEXTURE_2D, u),
                            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
                            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
                            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE),
                            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE),
                            a.texImage2D(a.TEXTURE_2D, 0, c, t.folding.w, t.folding.h, 0, a.RGBA, l, o),
                            new s(this,u,t,r)
                        }
                        allocUint8Texture(e, t) {
                            (this.maxTextureSize < t.folding.w || this.maxTextureSize < t.folding.h) && n.trace.error( () => `texture limit: ${this.maxTextureSize} < ${t.folding.w} x ${t.folding.h}`);
                            let r = i.DataType.Uint8;
                            if (null == e) {
                                let e = this.recycleTexture(t, r);
                                if (e)
                                    return e
                            }
                            let o = this.gl
                              , a = o.createTexture();
                            if (!a)
                                throw Error("[webgl] fail to create texture.");
                            return o.bindTexture(o.TEXTURE_2D, a),
                            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST),
                            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST),
                            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE),
                            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE),
                            o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, t.folding.w, t.folding.h, 0, o.RGBA, o.UNSIGNED_BYTE, e),
                            new s(this,a,t,r)
                        }
                        releaseTexture(e) {
                            e && e.owned && (this.reuseTexture ? this.recyclingTextures.push(e) : this.gl.deleteTexture(e.texture))
                        }
                        readTexture(e, t) {
                            let r = t || new Float32Array(e.width * e.height * 4)
                              , n = this.gl;
                            switch (this.attachFramebuffer(e),
                            n.bindTexture(n.TEXTURE_2D, e.texture),
                            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.texture, 0),
                            n.readPixels(0, 0, e.width, e.height, n.RGBA, n.FLOAT, r),
                            e.type) {
                            case i.DataType.Float32:
                                return r;
                            case i.DataType.Int8:
                                return new Int8Array(r);
                            case i.DataType.Uint8:
                                return new Uint8Array(r);
                            default:
                                throw Error(`[webgl] invalid data type ${e.type} for reading.`)
                            }
                        }
                        compileShader(e, t) {
                            let r = this.gl
                              , i = r.createShader(t);
                            if (!i)
                                throw Error(`[webgl] failed to create shader with type ${t}.`);
                            if (r.shaderSource(i, e),
                            r.compileShader(i),
                            !1 === r.getShaderParameter(i, r.COMPILE_STATUS))
                                throw Error(`[webgl] failed to compile shader: ${r.getShaderInfoLog(i)}`);
                            return i
                        }
                        deleteShader(e) {
                            e && this.gl.deleteShader(e)
                        }
                        hashScript(e) {
                            if (0 === e.length)
                                return 0;
                            let t, r = 0;
                            for (t = 0; t < e.length; t++)
                                r = (r << 5) - r + e.charCodeAt(t) | 0;
                            return r
                        }
                        linkProgram(e, t) {
                            let r = this.gl
                              , i = r.createProgram();
                            if (!i)
                                throw Error("[webgl] failed to create program.");
                            if (r.attachShader(i, e),
                            r.attachShader(i, t),
                            r.linkProgram(i),
                            !r.getProgramParameter(i, r.LINK_STATUS))
                                throw Error("Could not compile WebGL program. \n\n" + r.getProgramInfoLog(i));
                            return this.deleteShader(t),
                            new u(i,-1,-1)
                        }
                        compileByFragShaderKey(e) {
                            let t = this.recycleFragShaders.get(e);
                            if (e && t && this.defaultVertexShader)
                                return this.linkProgram(this.defaultVertexShader, t)
                        }
                        compile(e, t, r) {
                            let i = 0;
                            if (!r && this.reuseProgram) {
                                i = this.hashScript(e);
                                let t = this.recyclingPrograms[i];
                                if (t)
                                    return t
                            }
                            if (!this.gl.createProgram())
                                throw Error("[webgl] failed to create program.");
                            let n = r ? this.compileShader(r, this.gl.VERTEX_SHADER) : this.defaultVertexShader
                              , o = this.compileShader(e, this.gl.FRAGMENT_SHADER)
                              , a = this.linkProgram(n, o);
                            return !r && this.reuseProgram && (this.recyclingPrograms[i] = a),
                            t && this.reuseProgram && this.recycleFragShaders.set(t, o),
                            a
                        }
                        deleteProgram(e) {
                            e && !this.reuseProgram && this.gl.deleteProgram(e.program)
                        }
                        useProgram(e) {
                            let t = this.gl
                              , r = t.getAttribLocation(e.program, "position")
                              , i = t.getAttribLocation(e.program, "textureCoord");
                            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer),
                            t.vertexAttribPointer(r, 3, t.FLOAT, !1, 20, 0),
                            t.enableVertexAttribArray(r),
                            -1 !== i && (t.vertexAttribPointer(i, 2, t.FLOAT, !1, 20, 12),
                            t.enableVertexAttribArray(i)),
                            this.gl.useProgram(e.program)
                        }
                        attachFramebuffer(e) {
                            let t = this.gl;
                            t.bindTexture(t.TEXTURE_2D, e.texture),
                            t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer),
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e.texture, 0),
                            t.viewport(0, 0, e.width, e.height),
                            t.scissor(0, 0, e.width, e.height)
                        }
                        bindTexture(e, t, r) {
                            let i = this.gl;
                            i.activeTexture(i.TEXTURE0 + r),
                            i.bindTexture(i.TEXTURE_2D, e.texture),
                            i.uniform1i(t, r)
                        }
                        bindUniformF(e, t) {
                            this.gl.uniform1f(e, t)
                        }
                        bindUniformI(e, t) {
                            this.gl.uniform1i(e, t)
                        }
                        bindUniform2IV(e, t) {
                            this.gl.uniform2iv(e, t)
                        }
                        bindUniform3IV(e, t) {
                            this.gl.uniform3iv(e, t)
                        }
                        bindUniform4IV(e, t) {
                            this.gl.uniform4iv(e, t)
                        }
                        bindUniform2FV(e, t) {
                            this.gl.uniform2fv(e, t)
                        }
                        bindUniform3FV(e, t) {
                            this.gl.uniform3fv(e, t)
                        }
                        bindUniform4FV(e, t) {
                            this.gl.uniform4fv(e, t)
                        }
                        getUniformLocation(e, t) {
                            let r = this.gl.getUniformLocation(e.program, t);
                            if (!r)
                                throw Error(`[webgl] location <${t}> not found.`);
                            return r
                        }
                        draw() {
                            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                            let e = n.trace.now();
                            e - this.lastFlushTime > this.flushInterval && (this.gl.flush(),
                            this.lastFlushTime = e),
                            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null)
                        }
                        async waitFenceSync(e=0) {
                            return new Promise( (t, r) => {
                                if (this.isFenceEnable) {
                                    let r = this.gl
                                      , i = r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                    r.flush();
                                    let n = () => {
                                        switch (r.clientWaitSync(i, 0, 0)) {
                                        case r.TIMEOUT_EXPIRED:
                                            setTimeout(n, e);
                                            break;
                                        case r.WAIT_FAILED:
                                            throw Error("Wait failed...");
                                        default:
                                            r.deleteSync(i),
                                            t()
                                        }
                                    }
                                    ;
                                    n()
                                } else
                                    r()
                            }
                            )
                        }
                        getQueryTimerExtension() {
                            let e;
                            return this.isWebGL2() ? this.gl.getExtension("EXT_disjoint_timer_query_webgl2") : this.gl.getExtension("Ext_disjoint_timer_query")
                        }
                        createAndBeginQuery() {
                            if (!this.queryTimerExtension)
                                throw TypeError("Unable to create query timer extension");
                            if (this.isWebGL2()) {
                                let e = this.queryTimerExtension
                                  , t = this.gl
                                  , r = t.createQuery();
                                if (!r)
                                    throw TypeError("Unable to create query");
                                return t.beginQuery(e.TIME_ELAPSED_EXT, r),
                                r
                            }
                            {
                                let e = this.queryTimerExtension
                                  , t = (this.gl,
                                e.createQueryEXT());
                                if (!t)
                                    throw TypeError("Unable to create query");
                                return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t),
                                t
                            }
                        }
                        endQuery() {
                            if (!this.queryTimerExtension)
                                throw TypeError("Unable to create query timer extension");
                            if (this.isWebGL2()) {
                                let e = this.queryTimerExtension;
                                this.gl.endQuery(e.TIME_ELAPSED_EXT)
                            } else {
                                let e = this.queryTimerExtension;
                                e.endQueryEXT(e.TIME_ELAPSED_EXT)
                            }
                        }
                        isQueryFinished(e) {
                            if (!this.queryTimerExtension)
                                throw TypeError("Unable to create query timer extension");
                            if (this.isWebGL2()) {
                                let t = this.gl;
                                return this.queryTimerExtension,
                                !!t.getQueryParameter(e, t.QUERY_RESULT_AVAILABLE)
                            }
                            this.gl;
                            let t = this.queryTimerExtension;
                            return !!t.getQueryObjectEXT(e, t.QUERY_RESULT_AVAILABLE_EXT)
                        }
                        async waitQueryFinish(e, t=0) {
                            if (!this.queryTimerExtension)
                                throw TypeError("Unable to create query timer extension");
                            return new Promise( (r, i) => {
                                let n = 0
                                  , o = () => {
                                    let a = this.isQueryFinished(e);
                                    n += 1,
                                    t && n > t && i(),
                                    a ? r() : setTimeout(o, 0)
                                }
                                ;
                                o()
                            }
                            )
                        }
                        getQueryTime(e) {
                            if (!this.queryTimerExtension)
                                throw TypeError("Unable to create query timer extension");
                            if (this.isWebGL2()) {
                                let t = this.gl;
                                return t.getQueryParameter(e, t.QUERY_RESULT) / 1e6
                            }
                            this.gl;
                            let t = this.queryTimerExtension
                              , r = t.getQueryObjectEXT(e, t.QUERY_RESULT_EXT);
                            return console.log("query time", r),
                            r / 1e6
                        }
                        async waitAndGetQueryTime(e) {
                            await this.waitQueryFinish(e);
                            let t = this.getQueryTime(e);
                            return console.log(t),
                            t
                        }
                    }
                }
                ,
                5462: (e, t, r) => {
                    t.WebGLDevice = void 0;
                    let i = r(7693)
                      , n = r(5249)
                      , o = r(2810)
                      , a = r(6825)
                      , s = r(2426)
                      , u = r(8137)
                      , l = r(2638)
                      , c = r(6480)
                      , p = r(4329);
                    class d {
                        constructor(e, t) {
                            this.gl = e,
                            this.context = t
                        }
                        getContext() {
                            return this.context
                        }
                        getWebGLRenderingContext() {
                            return this.gl
                        }
                        build(e) {
                            let t = s.WebGLOps.builder(e);
                            return t ? t(e, this.context) : void 0
                        }
                        tensorFromData(e, t) {
                            let r = u.WebGLLayout.fold(e, this.context)
                              , o = i.typedArrayGetType(t)
                              , a = r.reorderAsTexture(t)
                              , s = this.context.allocTexture(a, r);
                            return new n.Tensor(r.shape,o,s)
                        }
                        tensorFromTextureData(e, t) {
                            let r = u.WebGLLayout.fold(e, this.context)
                              , o = i.typedArrayGetType(t)
                              , a = this.context.allocTexture(t, r);
                            return new n.Tensor(r.shape,o,a)
                        }
                        tensorFromTexture(e, t, r) {
                            let i = u.WebGLLayout.folded(e);
                            return new n.Tensor(i.shape,t,new a.WebGLStorage(this.context,r,i,t,!1))
                        }
                        textureFromTensor(e) {
                            if (e.storage instanceof a.WebGLStorage)
                                return e.storage.texture
                        }
                        dispose() {
                            this.context.dispose()
                        }
                        static getValidContext(e, t) {
                            let r = {
                                alpha: !1,
                                depth: !1,
                                antialias: !1,
                                stencil: !1,
                                preserveDrawingBuffer: !1,
                                premultipliedAlpha: !1,
                                failIfMajorPerformanceCaveat: !1
                            };
                            try {
                                let i = t.getContext(e, r);
                                if (!i || i.isContextLost())
                                    return null;
                                let n = i.createFramebuffer()
                                  , o = i.createBuffer();
                                if (!n || !o)
                                    return i.deleteFramebuffer(n),
                                    i.deleteBuffer(o),
                                    null;
                                i.disable(i.DEPTH_TEST),
                                i.disable(i.STENCIL_TEST),
                                i.disable(i.BLEND),
                                i.disable(i.DITHER),
                                i.disable(i.POLYGON_OFFSET_FILL),
                                i.disable(i.SAMPLE_COVERAGE),
                                i.enable(i.SCISSOR_TEST),
                                i.enable(i.CULL_FACE),
                                i.cullFace(i.BACK);
                                let a = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
                                return i.bindBuffer(i.ARRAY_BUFFER, o),
                                i.bufferData(i.ARRAY_BUFFER, a, i.STATIC_DRAW),
                                [i, n, o]
                            } catch (t) {
                                return o.trace.log( () => `${e} is NOT available on this platform. falling back to webgl.`),
                                null
                            }
                        }
                        static testAttachment(e, t, r, i) {
                            let n = e.createTexture();
                            e.bindTexture(e.TEXTURE_2D, n),
                            e.texImage2D(e.TEXTURE_2D, 0, r, 1, 1, 0, e.RGBA, i, null),
                            e.bindFramebuffer(e.FRAMEBUFFER, t),
                            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
                            let o = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
                            return e.bindTexture(e.TEXTURE_2D, null),
                            e.bindFramebuffer(e.FRAMEBUFFER, null),
                            e.deleteTexture(n),
                            o
                        }
                        static createContext(e, t) {
                            let r = this.getValidContext("webgl2", t);
                            if (r) {
                                let[t,i,n] = r
                                  , a = t.getExtension("WEBGL_debug_renderer_info");
                                a && console.log("render type is " + t.getParameter(a.UNMASKED_RENDERER_WEBGL)),
                                o.trace.log( () => `webgl2 supported extensions: 
	${(t.getSupportedExtensions() || []).join("\n	")}`);
                                let s = t.getExtension("EXT_color_buffer_float");
                                if (e.precision,
                                l.WebGLPrecision.Low,
                                null == e.precision || e.precision == l.WebGLPrecision.High) {
                                    if (s && this.testAttachment(t, i, WebGL2RenderingContext.RGBA32F, t.FLOAT))
                                        return [t, new p.WebGL2Fp32Context(e,t,i,n)];
                                    if (s && this.testAttachment(t, i, WebGL2RenderingContext.RGBA16F, t.FLOAT))
                                        return [t, new p.WebGL2Fp16Context(e,t,i,n)]
                                } else {
                                    if (s && this.testAttachment(t, i, WebGL2RenderingContext.RGBA16F, t.FLOAT))
                                        return [t, new p.WebGL2Fp16Context(e,t,i,n)];
                                    if (s && this.testAttachment(t, i, WebGL2RenderingContext.RGBA32F, t.FLOAT))
                                        return [t, new p.WebGL2Fp32Context(e,t,i,n)]
                                }
                            }
                            let i = this.getValidContext("webgl", t);
                            if (i) {
                                let[t,r,n] = i;
                                o.trace.log( () => `webgl1 supported extensions: 
	${(t.getSupportedExtensions() || []).join("\n	")}`);
                                let a = t.getExtension("OES_texture_float")
                                  , s = t.getExtension("OES_texture_half_float");
                                if (null == e.precision || e.precision == l.WebGLPrecision.High) {
                                    if (a && this.testAttachment(t, r, WebGLRenderingContext.RGBA, t.FLOAT))
                                        return [t, new c.WebGL1Fp32Context(e,t,r,n)];
                                    if (s && this.testAttachment(t, r, WebGLRenderingContext.RGBA, s.HALF_FLOAT_OES))
                                        return [t, new c.WebGL1Fp16Context(e,t,r,n,s)]
                                } else {
                                    if (s && this.testAttachment(t, r, WebGLRenderingContext.RGBA, s.HALF_FLOAT_OES))
                                        return [t, new c.WebGL1Fp16Context(e,t,r,n,s)];
                                    if (a && this.testAttachment(t, r, WebGLRenderingContext.RGBA, t.FLOAT))
                                        return [t, new c.WebGL1Fp32Context(e,t,r,n)]
                                }
                            }
                            return null
                        }
                        static createDeviceWithGLContext(e, t) {
                            let r;
                            if (!t || t.isContextLost())
                                return console.error("context lost"),
                                null;
                            let i = t.createFramebuffer()
                              , n = t.createBuffer()
                              , o = -1 != t.getParameter(t.VERSION).indexOf("WebGL 2.0") ? 2 : 1;
                            if (!i || !n)
                                return t.deleteFramebuffer(i),
                                t.deleteBuffer(n),
                                null;
                            t.disable(t.DEPTH_TEST),
                            t.disable(t.STENCIL_TEST),
                            t.disable(t.BLEND),
                            t.disable(t.DITHER),
                            t.disable(t.POLYGON_OFFSET_FILL),
                            t.disable(t.SAMPLE_COVERAGE),
                            t.enable(t.SCISSOR_TEST),
                            t.enable(t.CULL_FACE),
                            t.cullFace(t.BACK);
                            let a = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
                            t.bindBuffer(t.ARRAY_BUFFER, n),
                            t.bufferData(t.ARRAY_BUFFER, a, t.STATIC_DRAW);
                            let s = t.getExtension("OES_texture_float")
                              , u = t.getExtension("OES_texture_half_float");
                            if (2 == o) {
                                let o = t.getExtension("EXT_color_buffer_float");
                                if (e.precision,
                                l.WebGLPrecision.Low,
                                null == e.precision || e.precision == l.WebGLPrecision.High) {
                                    if (o && this.testAttachment(t, i, WebGL2RenderingContext.RGBA32F, t.FLOAT))
                                        return r = new p.WebGL2Fp32Context(e,t,i,n),
                                        new d(t,r);
                                    if (o && this.testAttachment(t, i, WebGL2RenderingContext.RGBA16F, t.FLOAT))
                                        return r = new p.WebGL2Fp16Context(e,t,i,n),
                                        new d(t,r)
                                } else {
                                    if (o && this.testAttachment(t, i, WebGL2RenderingContext.RGBA16F, t.FLOAT))
                                        return r = new p.WebGL2Fp16Context(e,t,i,n),
                                        new d(t,r);
                                    if (o && this.testAttachment(t, i, WebGL2RenderingContext.RGBA32F, t.FLOAT))
                                        return r = new p.WebGL2Fp32Context(e,t,i,n),
                                        new d(t,r)
                                }
                            } else if (console.log("extFp32", s),
                            console.log("in device context", t),
                            null == e.precision || e.precision == l.WebGLPrecision.High) {
                                if (s && this.testAttachment(t, i, WebGLRenderingContext.RGBA, t.FLOAT))
                                    return r = new c.WebGL1Fp32Context(e,t,i,n),
                                    new d(t,r);
                                if (u && this.testAttachment(t, i, WebGLRenderingContext.RGBA, u.HALF_FLOAT_OES))
                                    return r = new c.WebGL1Fp16Context(e,t,i,n,u),
                                    new d(t,r)
                            } else {
                                if (u && this.testAttachment(t, i, WebGLRenderingContext.RGBA, u.HALF_FLOAT_OES))
                                    return r = new c.WebGL1Fp16Context(e,t,i,n,u),
                                    new d(t,r);
                                if (s && this.testAttachment(t, i, WebGLRenderingContext.RGBA, t.FLOAT))
                                    return r = new c.WebGL1Fp32Context(e,t,i,n),
                                    new d(t,r)
                            }
                            return null
                        }
                        static create(e, t) {
                            if (t || ("undefined" != typeof OffscreenCanvas ? (t = new OffscreenCanvas(300,150),
                            console.log("canvas log 0")) : "undefined" != typeof document && ((t = document.createElement("canvas")).width = 1,
                            t.height = 1,
                            console.log("canvas log 1"))),
                            !t)
                                return console.log("bytenn couldn't create canvas"),
                                null;
                            let r = this.createContext(e, t);
                            return r ? new d(r[0],r[1]) : (console.log("couldn't crete context"),
                            null)
                        }
                    }
                    t.WebGLDevice = d
                }
                ,
                4701: (e, t, r) => {
                    let i = r(7393)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            if (1 == i.inputNum && 1 == i.outputNum)
                                r.deleteProgram(this.program),
                                this.program = r.compile(this.scriptShuffleSingleInOut(e[0], t[0])),
                                this.inputLoc0 = r.getUniformLocation(this.program, "input_s");
                            else {
                                if (2 != i.inputNum || 2 != i.outputNum)
                                    throw Error("inputNum & outputNum must be 1 or 2, Now is " + i.inputNum);
                                r.deleteProgram(this.program),
                                this.program = r.compile(this.scriptShuffleMultipleInOut(e[0], t[0], i.outputNum)),
                                this.inputLoc0 = r.getUniformLocation(this.program, "input0_s"),
                                this.inputLoc1 = r.getUniformLocation(this.program, "input1_s")
                            }
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.operator
                              , o = this.context;
                            if (1 == n.inputNum && 1 == n.outputNum)
                                o.useProgram(this.program),
                                o.attachFramebuffer(i),
                                o.bindTexture(r, this.inputLoc0, 0),
                                o.draw();
                            else {
                                if (2 != n.inputNum || 2 != n.outputNum)
                                    throw Error("inputNum & outputNum must be 1 or 2, Now is " + n.inputNum);
                                o.useProgram(this.program);
                                for (let r = 0; r < n.outputNum; r++)
                                    o.attachFramebuffer(t[r].storage),
                                    o.bindTexture(e[0].storage, this.inputLoc0, 0),
                                    o.bindTexture(e[1].storage, this.inputLoc1, 1),
                                    null == this.outIdLoc && (this.outIdLoc = o.getUniformLocation(this.program, "outId")),
                                    o.bindUniformI(this.outIdLoc, r),
                                    o.draw()
                            }
                        }
                        scriptShuffleSingleInOut(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , [a,s,u,l] = e.shape.dims
                              , c = r.group
                              , p = r.shuffle;
                            if (p > 4)
                                throw Error("channelShuffle only supports shuffle == 2 or 4, Please check!");
                            return l <= c * p ? `${i.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    gl_FragColor = in4;
}
` : 2 == p ? `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    float dstRow = floor(float(oc4 * 4) / float(${p * c})) ;
    float dstCol = mod(float(oc4 * 4), float(${p * c})) / 4.0;
    float srcRow0 = dstCol * float(${p});
    float srcRow1 = srcRow0 + 1.0;
    float srcCol = dstRow / float(${p});
    bool isEvenColInSrcMatrix = (int(mod(dstRow, 2.0)) == 0);
    vec4 v_out4 = vec4(0.0);
    float srcIdx0 = srcRow0 * float(${l}) / float(${c} * 4) + srcCol;
    float srcIdx1 = srcIdx0 + float(${l}) / float(${c} * 4);
    vec4 v_in4_0 = texture2D(input_s, coord_input(on, oh, ow, int(srcIdx0)));
    vec4 v_in4_1 = texture2D(input_s, coord_input(on, oh, ow, int(srcIdx1)));
    if(isEvenColInSrcMatrix){
        v_out4 = vec4(v_in4_0.xy, v_in4_1.xy);
    }
    else{
        v_out4 = vec4(v_in4_0.zw, v_in4_1.zw);
    }
    gl_FragColor = v_out4;
}
` : `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    float dstRow = floor(float(oc4 * 4) / float(${p * c})) ;
    float dstCol = mod(float(oc4 * 4), float(${p * c})) / 4.0;
    float srcRow = dstCol;
    float srcCol = dstRow;
    vec4 v_out4 = vec4(0.0);
    float srcIdx = srcRow * float(${l}) / float(${c} * 4) + srcCol;
    vec4 v_in4 = texture2D(input_s, coord_input(on, oh, ow, int(srcIdx)));
    gl_FragColor = v_in4;
}
`
                        }
                        scriptShuffleMultipleInOut(e, t, r) {
                            let i = this.operator
                              , n = this.context
                              , o = e.storage.layout
                              , a = t.storage.layout
                              , [s,u,l,c] = e.shape.dims;
                            if (4 == (i.group,
                            i.shuffle) && 2 == r)
                                return `${n.precision}
${o.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input0_s, input1_s;
uniform int outId;
void main() {
    ${a.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    float srcIndex, modIndex;
    if(outId == 0){
        srcIndex = floor(float(oc4) / 2.0);
        modIndex = mod(float(oc4), 2.0);
    }
    else{
        srcIndex = floor(float(oc4) / 2.0) + float(${c}) / 2.0 / 4.0;
        modIndex = mod(float(oc4), 2.0);
    }
    gl_FragColor = int(modIndex) == 0 ? texture2D(input0_s, coord_input(on, oh, ow, int(srcIndex)))
     : texture2D(input1_s, coord_input(on, oh, ow, int(srcIndex)));
}
`;
                            throw Error("channelShuffleNet only supports shuffle == 4, Please check!")
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.ChannelShuffle)
                }
                ,
                6040: (e, t, r) => {
                    let i = r(5634)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = this.context;
                            this.operator,
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.scriptClip(e, t)),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage;
                            this.operator.inplace && (i = this.context.allocTexture(t[0].type, i.layout),
                            t[0].storage = i);
                            let n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        scriptClip(e, t) {
                            let r = this.operator;
                            return `${this.context.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    gl_FragColor = min(vec4(float(${r.maxValue})), max(vec4(float(${r.minValue})), texture2D(input_s, TexCoords)));
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Clip)
                }
                ,
                2393: (e, t, r) => {
                    let i = r(5574)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        compileProgram() {
                            let e = this.context;
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        getProgramKey() {
                            let e = this.operator;
                            return `concat_input_size_${e.input_size}_axis_${e.axis}`
                        }
                        initLoc() {
                            let e = this.context
                              , t = this.operator;
                            if (t.axis,
                            e.deleteProgram(this.program),
                            2 == t.input_size)
                                this.input0Loc = e.getUniformLocation(this.program, "input0_s"),
                                this.input1Loc = e.getUniformLocation(this.program, "input1_s"),
                                this.input0StridesLoc = e.getUniformLocation(this.program, "input0Strides"),
                                this.input1StridesLoc = e.getUniformLocation(this.program, "input1Strides"),
                                this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                                this.input0FoldLoc = e.getUniformLocation(this.program, "input0Fold"),
                                this.input1FoldLoc = e.getUniformLocation(this.program, "input1Fold"),
                                this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                                this.input0ShapesLoc = e.getUniformLocation(this.program, "input0Shapes");
                            else {
                                if (3 != t.input_size)
                                    throw Error("Input_size must be 2 or 3, Now is " + t.input_size);
                                this.input0Loc = e.getUniformLocation(this.program, "input0_s"),
                                this.input1Loc = e.getUniformLocation(this.program, "input1_s"),
                                this.input2Loc = e.getUniformLocation(this.program, "input2_s"),
                                this.input0StridesLoc = e.getUniformLocation(this.program, "input0Strides"),
                                this.input1StridesLoc = e.getUniformLocation(this.program, "input1Strides"),
                                this.input2StridesLoc = e.getUniformLocation(this.program, "input2Strides"),
                                this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                                this.input0FoldLoc = e.getUniformLocation(this.program, "input0Fold"),
                                this.input1FoldLoc = e.getUniformLocation(this.program, "input1Fold"),
                                this.input2FoldLoc = e.getUniformLocation(this.program, "input2Fold"),
                                this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                                this.input0ShapesLoc = e.getUniformLocation(this.program, "input0Shapes"),
                                this.input1ShapesLoc = e.getUniformLocation(this.program, "input1Shapes")
                            }
                        }
                        bindUniform(e, t) {
                            let r = this.operator
                              , i = e[0].storage
                              , n = e[1].storage
                              , o = t[0].storage
                              , a = this.context;
                            if (a.bindTexture(e[0].storage, this.input0Loc, 0),
                            a.bindTexture(e[1].storage, this.input1Loc, 1),
                            3 == r.input_size) {
                                let t = e[2].storage;
                                a.bindTexture(t, this.input2Loc, 2)
                            }
                            if (this.needUpadateBinding) {
                                if (2 != r.input_size && 3 != r.input_size)
                                    throw Error("Input_size must be 2 or 3, Now is " + r.input_size);
                                {
                                    let e = i.layout.getStrides()
                                      , t = n.layout.getStrides()
                                      , r = o.layout.getStrides()
                                      , s = [i.layout.folding.w, i.layout.folding.h]
                                      , u = [n.layout.folding.w, n.layout.folding.h]
                                      , l = [o.layout.folding.w, o.layout.folding.h];
                                    a.bindUniform4FV(this.input0ShapesLoc, [...i.layout.shape.dims]),
                                    a.bindUniform3FV(this.input0StridesLoc, e),
                                    a.bindUniform3FV(this.input1StridesLoc, t),
                                    a.bindUniform3FV(this.outputStridesLoc, r),
                                    a.bindUniform2FV(this.input0FoldLoc, s),
                                    a.bindUniform2FV(this.input1FoldLoc, u),
                                    a.bindUniform2FV(this.outputFoldLoc, l)
                                }
                                if (3 == r.input_size) {
                                    let t = e[1].storage
                                      , r = e[2].storage
                                      , i = r.layout.getStrides()
                                      , n = [r.layout.folding.w, r.layout.folding.h];
                                    a.bindUniform4FV(this.input1ShapesLoc, [...t.layout.shape.dims]),
                                    a.bindUniform3FV(this.input2StridesLoc, i),
                                    a.bindUniform2FV(this.input2FoldLoc, n)
                                }
                                this.needUpadateBinding = !1
                            }
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.attachFramebuffer(r),
                            i.useProgram(this.program),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script() {
                            let e = this.operator
                              , t = this.context;
                            if (2 == e.input_size) {
                                let r = e.axis;
                                if (0 == r)
                                    return `${t.precision}

                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }

                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;

                    int input0_n = int(input0Shapes[0]);
                    vec4 out4;
                    if(on >= 0 && on < input0_n) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else {
                        out4 = texture2D(input1_s, coord_input1(on - input0_n, oh, ow, oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (1 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }
                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    int input0_h = int(input0Shapes[1]);
                    vec4 out4;
                    if(oh >= 0 && oh < input0_h) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else {
                        out4 = texture2D(input1_s, coord_input1(on, oh - input0_h, ow, oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (2 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }
                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    int input0_w = int(input0Shapes[2]);
                    vec4 out4;
                    if(ow >= 0 && ow < input0_w) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else {
                        out4 = texture2D(input1_s, coord_input1(on, oh, ow - input0_w, oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (3 == r)
                                    return `${t.precision}

                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s;
                uniform int channel0;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }

                int input0_c = int(ceil(float(input0Shapes[3]) / 4.0));
                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    vec4 out4;
                    int channel0_mod = int(input0Shapes[3]) - int(input0Shapes[3] / 4.0) * 4;
                    if(channel0_mod == 0)
                    {
                        if(oc4 >= 0 && oc4 < input0_c) {
                            out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                        }
                        else {
                            out4 = texture2D(input1_s, coord_input1(on, oh, ow, oc4 - input0_c));
                        }
                    }
                    else
                    {
                        if(oc4 >= 0 && oc4 < input0_c - 1) {
                            out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                        }
                        else if(oc4 == input0_c - 1)
                        {
                            vec4 in0 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                            vec4 in1 = texture2D(input1_s, coord_input1(on, oh, ow, 0));
                            if(channel0_mod == 1)
                            {
                                out4.x = in0.x;
                                out4.y = in1.x;
                                out4.z = in1.y;
                                out4.w = in1.z;
                            }
                            else if(channel0_mod == 2)
                            {
                                out4.x = in0.x;
                                out4.y = in0.y;
                                out4.z = in1.x;
                                out4.w = in1.y;
                            }
                            else if(channel0_mod == 3)
                            {
                                out4.x = in0.x;
                                out4.y = in0.y;
                                out4.z = in0.z;
                                out4.w = in1.x;
                            }
                        }
                        else
                        {
                            vec4 in0 = texture2D(input1_s, coord_input1(on, oh, ow, oc4 - input0_c));
                            vec4 in1 = texture2D(input1_s, coord_input1(on, oh, ow, oc4 - input0_c + 1));
                            if(channel0_mod == 1)
                            {
                                out4.x = in0.w;
                                out4.y = in1.x;
                                out4.z = in1.y;
                                out4.w = in1.z;
                            }
                            else if(channel0_mod== 2)
                            {
                                out4.x = in0.z;
                                out4.y = in0.w;
                                out4.z = in1.x;
                                out4.w = in1.y;
                            }
                            else if(channel0_mod == 3)
                            {
                                out4.x = in0.y;
                                out4.y = in0.z;
                                out4.z = in0.w;
                                out4.w = in1.x;
                            }
                        }

                    }
                    gl_FragColor = out4;
                }`;
                                throw Error("Axis must be 0 or 1 or 2 or 3, Now is " + r)
                            }
                            if (3 == e.input_size) {
                                let r = e.axis;
                                if (0 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s, input2_s;
                uniform int channel0;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 input2Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 input2Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                uniform vec4 input1Shapes;

                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_input2(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input2Strides, input2Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }

                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    int input0_n = int(input0Shapes[0]);
                    int input1_n = int(input1Shapes[0]);
                    vec4 out4;
                    if(on >= 0 && on < input0_n) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else if(on >= input0_n && on < input0_n + input1_n) {
                        out4 = texture2D(input1_s, coord_input1(on - input0_n, oh, ow, oc4));
                    }
                    else {
                        out4 = texture2D(input2_s, coord_input2(on - (input0_n + input1_n), oh, ow, oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (1 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s, input2_s;
                uniform int channel0;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 input2Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 input2Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                uniform vec4 input1Shapes;

                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_input2(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input2Strides, input2Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }
                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    int input0_h = int(input0Shapes[1]);
                    int input1_h = int(input1Shapes[1]);
                    vec4 out4;
                    if(oh >= 0 && oh < input0_h) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else if(oh >= input0_h && oh < input0_h + input1_h) {
                        out4 = texture2D(input1_s, coord_input1(on, oh - input0_h, ow, oc4));
                    }
                    else {
                        out4 = texture2D(input2_s, coord_input2(on, oh - (input0_h + input1_h), ow, oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (2 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s, input2_s;
                uniform int channel0;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 input2Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 input2Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                uniform vec4 input1Shapes;

                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_input2(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input2Strides, input2Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }

                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    int input0_w = int(input0Shapes[2]);
                    int input1_w = int(input1Shapes[2]);
                    vec4 out4;
                    if(ow >= 0 && ow < input0_w) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else if(ow >= input0_w && ow < input0_w + input1_w) {
                        out4 = texture2D(input1_s, coord_input1(on, oh, ow - input0_w, oc4));
                    }
                    else {
                        out4 = texture2D(input2_s, coord_input2(on, oh, ow - (input0_w + input1_w), oc4));
                    }
                    gl_FragColor = out4;
                }`;
                                if (3 == r)
                                    return `${t.precision}
                varying vec2 TexCoords;
                uniform sampler2D input0_s, input1_s, input2_s;
                uniform int channel0;
                uniform vec3 input0Strides;
                uniform vec3 input1Strides;
                uniform vec3 input2Strides;
                uniform vec3 outputStrides;
                uniform vec2 input0Fold;
                uniform vec2 input1Fold;
                uniform vec2 input2Fold;
                uniform vec2 outputFold;
                uniform vec4 input0Shapes;
                uniform vec4 input1Shapes;

                ${n.TexCoordDimScript}

                vec2 coord_input0(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input0Strides, input0Fold);
                }

                vec2 coord_input1(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input1Strides, input1Fold);
                }

                vec2 coord_input2(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), input2Strides, input2Fold);
                }

                vec2 coord_output(int n, int h, int w, int c4) {
                    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
                }
                void main() {
                    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                    int on = int(dims[0]);
                    int oh = int(dims[1]);
                    int ow = int(dims[2]);
                    int oc4 = int(dims[3]);
                    int oc = oc4 * 4;
                    vec4 out4;
                    int input0_c = int(ceil(input0Shapes[3] / 4.0));
                    int input1_c = int(ceil(input1Shapes[3] / 4.0));
                    if(oc4 >= 0 && oc4 < input0_c) {
                        out4 = texture2D(input0_s, coord_input0(on, oh, ow, oc4));
                    }
                    else if(oc4 >= input0_c && oc4 < input0_c + input1_c) {
                        out4 = texture2D(input1_s, coord_input1(on, oh, ow, oc4 - input0_c));
                    }
                    else {
                        out4 = texture2D(input2_s, coord_input2(on, oh, ow, oc4 - input0_c - input1_c));
                    }
                    gl_FragColor = out4;
                }`;
                                throw Error("Axis must be 0 or 1 or 2 or 3, Now is " + r)
                            }
                            throw Error("Input_size must be 2 or 3, Now is " + e.input_size)
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Concat)
                }
                ,
                8395: (e, t, r) => {
                    let i = r(8407)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        execute(e, t) {
                            let r = this.operator
                              , i = this.context
                              , o = n.WebGLLayout.fold(r.constShape, i)
                              , a = o.reorderAsTexture(r.constValue);
                            t[0].storage = i.allocTexture(a, o)
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Constant)
                }
                ,
                876: (e, t, r) => {
                    let i = r(7115)
                      , n = r(8137)
                      , o = r(4633)
                      , a = r(9998)
                      , s = r(2426);
                    class u extends a.WebGLKernel {
                        dispose() {
                            super.dispose();
                            let e = this.context;
                            e.releaseTexture(this.weightTexture),
                            e.releaseTexture(this.biasTexture)
                        }
                        allocTexture() {
                            let e = this.context
                              , t = this.operator;
                            if (!this.weightTexture) {
                                let r = n.WebGLLayout.fold([t.channel.out, t.kernel.h, t.kernel.w, t.channel.in], e)
                                  , i = r.reorderAsTexture(t.weight);
                                this.weightTexture = e.allocTexture(i, r)
                            }
                            if (!this.biasTexture && t.bias) {
                                let r = n.WebGLLayout.fold([t.channel.out], e)
                                  , i = r.reorderAsTexture(t.bias);
                                this.biasTexture = e.allocTexture(i, r)
                            }
                        }
                        getProgramKey() {
                            let e = this.operator;
                            return `conv2d_kernel_${e.kernel.w}_${e.kernel.h}_stride_${e.stride.x}_${e.stride.y}_padding_${e.padding.top}_${e.padding.right}_${e.padding.bottom}_${e.padding.left}_dilation_${e.dilation.x}_${e.dilation.y}_bias_${e.bias ? "1" : "0"}_activation_${e.activation}`
                        }
                        compileProgram() {
                            let e = this.context
                              , t = this.operator
                              , r = this.getProgramKey()
                              , i = !1;
                            1 === t.kernel.h && 1 === t.kernel.w && 1 === t.stride.x && 1 === t.stride.y && 0 === t.padding.bottom && 0 === t.padding.top && 0 === t.padding.left && 0 === t.padding.right && (i = !0),
                            e.deleteProgram(this.program),
                            this.program = !0 === i ? e.compile(this.script1x1(), r) : e.compile(this.scriptMxN(), r)
                        }
                        initLoc(e, t) {
                            let r = this.context;
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.weightLoc = r.getUniformLocation(this.program, "weight_s"),
                            this.biasLoc = r.getUniformLocation(this.program, "bias_s"),
                            this.inputStridesLoc = r.getUniformLocation(this.program, "inputStrides"),
                            this.outputStridesLoc = r.getUniformLocation(this.program, "outputStrides"),
                            this.weightStridesLoc = r.getUniformLocation(this.program, "weightStrides"),
                            this.inputFoldLoc = r.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = r.getUniformLocation(this.program, "outputFold"),
                            this.weightFoldLoc = r.getUniformLocation(this.program, "weightFold"),
                            this.biasFoldLoc = r.getUniformLocation(this.program, "biasFold"),
                            this.inputShapeLoc = r.getUniformLocation(this.program, "inputShapes"),
                            this.allocTexture()
                        }
                        bindUniform(e, t) {
                            let r = this.context
                              , i = e[0].storage
                              , n = t[0].storage;
                            if (r.bindTexture(i, this.inputLoc, 0),
                            r.bindTexture(this.weightTexture, this.weightLoc, 1),
                            r.bindTexture(this.biasTexture, this.biasLoc, 2),
                            this.needUpadateBinding) {
                                let e = i.layout.getStrides()
                                  , t = n.layout.getStrides()
                                  , o = this.weightTexture.layout.getStrides()
                                  , a = [i.layout.folding.w, i.layout.folding.h]
                                  , s = [n.layout.folding.w, n.layout.folding.h]
                                  , u = [this.weightTexture.layout.folding.w, this.weightTexture.layout.folding.h]
                                  , l = [this.biasTexture.layout.folding.w, this.biasTexture.layout.folding.h];
                                r.bindUniform4FV(this.inputShapeLoc, [...i.layout.shape.dims]),
                                r.bindUniform3FV(this.inputStridesLoc, e),
                                r.bindUniform3FV(this.outputStridesLoc, t),
                                r.bindUniform3FV(this.weightStridesLoc, o),
                                r.bindUniform2FV(this.inputFoldLoc, a),
                                r.bindUniform2FV(this.outputFoldLoc, s),
                                r.bindUniform2FV(this.weightFoldLoc, u),
                                r.bindUniform2FV(this.biasFoldLoc, l),
                                this.needUpadateBinding = !1
                            }
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.attachFramebuffer(r),
                            i.useProgram(this.program),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script1x1() {
                            let e = this.operator;
                            return `${this.context.precision}

        varying vec2 TexCoords;
        uniform sampler2D input_s, weight_s, bias_s;
        uniform vec3 inputStrides;
        uniform vec3 outputStrides;
        uniform vec3 weightStrides;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        uniform vec2 weightFold;
        uniform vec2 biasFold;
        uniform vec4 inputShapes;

        ${o.TexCoordDimScript}
        vec2 coord_input(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
        }

        vec2 coord_weight(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), weightStrides, weightFold);
        }

        vec2 coord_output(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
        }

        vec2 coord_bias(int c4) {
            return dim1ToTexCoord(c4, biasFold);
        }

        void main() {
            vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
            int on = int(dims[0]);
            int oh = int(dims[1]);
            int ow = int(dims[2]);
            int oc4 = int(dims[3]);
            int oc = oc4 * 4;
            int IC4 = int(ceil(inputShapes[3] / 4.0));
            vec4 out4 = texture2D(bias_s, coord_bias(oc4));

            for (int ic4 = 0; ic4 < 10000; ic4++) {
                if (ic4 >= IC4) {
                    break;
                }
                vec4 in4 = texture2D(input_s, coord_input(on, oh, ow, ic4));
                vec4 w0 = texture2D(weight_s, coord_weight(oc, 0, 0, ic4));
                vec4 w1 = texture2D(weight_s, coord_weight(oc + 1, 0, 0, ic4));
                vec4 w2 = texture2D(weight_s, coord_weight(oc + 2, 0, 0, ic4));
                vec4 w3 = texture2D(weight_s, coord_weight(oc + 3, 0, 0, ic4));
                out4 += vec4(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
            }
            gl_FragColor = ${e.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
        }`
                        }
                        scriptMxN() {
                            let e = this.operator
                              , t = this.context
                              , r = e.kernel.h
                              , n = e.kernel.w
                              , a = e.dilation.y
                              , s = e.dilation.x;
                            return `${t.precision}
        varying vec2 TexCoords;
        uniform sampler2D input_s, weight_s, bias_s;
        uniform vec3 inputStrides;
        uniform vec3 outputStrides;
        uniform vec3 weightStrides;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        uniform vec2 weightFold;
        uniform vec2 biasFold;
        uniform vec4 inputShapes;


        ${o.TexCoordDimScript}

        vec2 coord_input(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
        }

        vec2 coord_weight(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), weightStrides, weightFold);
        }

        vec2 coord_output(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
        }

        vec2 coord_bias(int c4) {
            return dim1ToTexCoord(c4, biasFold);
        }

        void main() {
            vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
            int on = int(dims[0]);
            int oh = int(dims[1]);
            int ow = int(dims[2]);
            int oc4 = int(dims[3]);
            int oc = oc4 * 4;
            int ih = oh * ${e.stride.y} - ${e.padding.top};
            int iw = ow * ${e.stride.x} - ${e.padding.left};
            int IC4 = int(ceil(inputShapes[3] / 4.0));
            int IH = int(inputShapes[1]);
            int IW = int(inputShapes[2]);
            vec4 out4 = texture2D(bias_s, coord_bias(oc4));
            for (int ic4 = 0; ic4 < 10000; ic4++) {
                if (ic4 >= IC4) {
                    break;
                }
                for (int kh = 0; kh < ${r}; kh++) {
                    if (ih + kh * ${a} < 0 || ih + kh * ${a} >= IH) continue;

                    for (int kw = 0; kw < ${n}; kw++) {
                        if (iw + kw * ${s} < 0 || iw + kw * ${s} >= IW) continue;

                        vec4 in4 = texture2D(input_s, coord_input(on, ih + kh * ${a}, iw + kw * ${s}, ic4));
                        vec4 w0 = texture2D(weight_s, coord_weight(oc + 0, kh, kw, ic4));
                        vec4 w1 = texture2D(weight_s, coord_weight(oc + 1, kh, kw, ic4));
                        vec4 w2 = texture2D(weight_s, coord_weight(oc + 2, kh, kw, ic4));
                        vec4 w3 = texture2D(weight_s, coord_weight(oc + 3, kh, kw, ic4));
                        out4 += vec4(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                    }
                }
            }
            gl_FragColor = ${e.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
        }
        `
                        }
                    }
                    s.WebGLOps.register( (e, t) => new u(e,t), i.Conv2D)
                }
                ,
                9016: (e, t, r) => {
                    let i = r(1858)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        dispose() {
                            super.dispose();
                            let e = this.context;
                            e.releaseTexture(this.weightTexture),
                            e.releaseTexture(this.biasTexture)
                        }
                        init(e, t) {
                            let r = this.context;
                            this.program = r.compile(this.script(e[0], t[0]))
                        }
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            if (!this.weightTexture) {
                                let e = n.WebGLLayout.fold([i.channel.out, i.kernel.h, i.kernel.w, i.channel.in], r)
                                  , t = e.reorderAsTexture(i.weight);
                                this.weightTexture = r.allocTexture(t, e)
                            }
                            if (!this.biasTexture && i.bias) {
                                let e = n.WebGLLayout.fold([i.channel.out], r)
                                  , t = e.reorderAsTexture(i.bias);
                                this.biasTexture = r.allocTexture(t, e)
                            }
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.weightLoc = r.getUniformLocation(this.program, "weight_s"),
                            this.biasLoc = r.getUniformLocation(this.program, "bias_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.bindTexture(this.weightTexture, this.weightLoc, 1),
                            n.bindTexture(this.biasTexture, this.biasLoc, 2),
                            n.draw()
                        }
                        script(e, t) {
                            let r = this.operator
                              , o = this.context
                              , a = e.storage.layout
                              , s = t.storage.layout
                              , [,u,l,c] = e.shape.dims
                              , p = r.kernel.h
                              , d = r.kernel.w
                              , f = r.dilation.y
                              , m = r.dilation.x;
                            return `${o.precision}
${this.weightTexture.layout.scriptDimsToCoord("coord_weight")}
${this.biasTexture.layout.scriptDimsToCoord("coord_bias")}
${a.scriptDimsToCoord("coord_input")}

int mod(int x, int y) {
    return x - x / y * y;
}
varying vec2 TexCoords;
uniform sampler2D input_s, weight_s, bias_s;
void main() {
    ${s.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    int oc = oc4 * 4;
    int ih = oh - ${p} + ${r.padding.top} + 1 - (${f} - 1) * (${p} - 1);
    int iw = ow - ${d} + ${r.padding.left} + 1 - (${m} - 1) * (${d} - 1);
    int double_ch = ${p} - 1;
    int double_cw = ${d} - 1;
    vec4 out4 = texture2D(bias_s, coord_bias(oc4));
    for (int ic4 = 0; ic4 < ${n.upDiv(c, 4)}; ic4++) {
        for (int kh = 0; kh < ${p}; kh++) {
            if (ih + kh * ${f}  < 0 || (ih + kh * ${f}) / ${r.stride.x} >= ${u}) continue;

            for (int kw = 0; kw < ${d}; kw++) {
                if (iw + kw * ${m}  < 0 || (iw + kw * ${m}) / ${r.stride.x} >= ${l}) continue;

                if (mod(ih + kh * ${f}, ${r.stride.y}) + mod(iw + kw  * ${m}, ${r.stride.x}) == 0) {

                    int transpose_kh = double_ch - kh;
                    int transpose_kw = double_cw - kw;

                    vec4 in4 = texture2D(input_s, coord_input(on, (ih + kh * ${f} ) / ${r.stride.y}, (iw + kw * ${m} ) / ${r.stride.x}, ic4));
                    vec4 w0 = texture2D(weight_s, coord_weight(oc + 0, transpose_kh, transpose_kw, ic4));
                    vec4 w1 = texture2D(weight_s, coord_weight(oc + 1, transpose_kh, transpose_kw, ic4));
                    vec4 w2 = texture2D(weight_s, coord_weight(oc + 2, transpose_kh, transpose_kw, ic4));
                    vec4 w3 = texture2D(weight_s, coord_weight(oc + 3, transpose_kh, transpose_kw, ic4));
                    out4 += vec4(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                }
            }
        }
    }
    gl_FragColor = ${r.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
}
`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.ConvTranspose2D)
                }
                ,
                7150: (e, t, r) => {
                    let i = r(9226)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        compute(e) {
                            return e % 4 == 0 ? "\n            out4 = texture2D(input_s, coord_input(on, ih, iw, ic4));\n            " : e % 4 == 1 ? "\n            out4.xyz = texture2D(input_s, coord_input(on, ih, iw, ic4)).yzw;\n            out4.w = texture2D(input_s, coord_input(on, ih, iw, ic4 + 1)).x;\n            " : e % 4 == 2 ? "\n            out4.xy = texture2D(input_s, coord_input(on, ih, iw, ic4)).zw;\n            out4.zw = texture2D(input_s, coord_input(on, ih, iw, ic4 + 1)).xy;\n            " : "\n            out4.x = texture2D(input_s, coord_input(on, ih, iw, ic4)).w;\n            out4.yzw = texture2D(input_s, coord_input(on, ih, iw, ic4 + 1)).xyz;\n            "
                        }
                        script(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.hoffset
                              , s = r.woffset
                              , u = r.coffset;
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    int ih = oh + ${a};
    int iw = ow + ${s};
    int ic = oc4 * 4 + ${u};
    int ic4 = int(floor(float(ic) / 4.0));
    ${this.compute(u)};
    gl_FragColor = out4;
}
`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Crop)
                }
                ,
                8807: (e, t, r) => {
                    let i = r(3770)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        execute(e, t) {}
                        setData(e, t) {
                            e !== t && (e.fraction = t.fraction,
                            e.shape = t.shape.copy(),
                            e.storage = t.storage,
                            e.type = t.type)
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Data)
                }
                ,
                5886: (e, t, r) => {
                    let i = r(8159)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            r.deleteProgram(this.program),
                            t[0].shape.dims.slice(-1)[0] % 4 && 1 != i.blockSize ? this.program = r.compile(this.scriptDepth2SpaceDisorderedForNHWC(e[0], t[0])) : this.program = r.compile(this.scriptDepth2SpaceForNHWC(e[0], t[0])),
                            this.program = r.compile(this.scriptDepth2SpaceForNHWC(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        scriptDepth2SpaceForNHWC(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.blockSize;
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${o.scriptCoordToDims("TexCoords", ["n", "oh", "ow", "oc4"])}
    int oc = oc4 * 4;
    int ic4 = oh * ${a} * ${a} + ow * ${a} + oc4;
    int iw = ow / ${a};
    int ih = oh / ${a};
    gl_FragColor = texture2D(input_s, coord_input(n, ih, iw, ic4));
}`
                        }
                        scriptDepth2SpaceDisorderedForNHWC(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.blockSize
                              , [,,,s] = t.shape.dims;
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${o.scriptCoordToDims("TexCoords", ["n", "oh", "ow", "oc4"])}
    int oc = oc4 * 4;
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    int iw = ow / ${a};
    int ih = oh / ${a};
    for (int i = 0; i < 4; ++i) {
        int ic4 = (oh * ${a} * ${a} + ow * ${a} + mod(oc + i, ${s})) / 4;
        int offset = mod(mod(oc + i, ${s}), 4);
        if (offset == 0)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).x;
        else if (offset == 1)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).y;
        else if (offset == 2)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).z;
        else
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).w;
    }

    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.DepthToSpace)
                }
                ,
                7470: (e, t, r) => {
                    let i = r(5857)
                      , n = r(8137)
                      , o = r(4633)
                      , a = r(9998)
                      , s = r(2426);
                    class u extends a.WebGLKernel {
                        dispose() {
                            super.dispose();
                            let e = this.context;
                            e.releaseTexture(this.weightTexture),
                            e.releaseTexture(this.biasTexture)
                        }
                        getProgramKey() {
                            let e = this.operator;
                            return `depthwise_conv2d_kernel_${e.kernel.w}_${e.kernel.h}_stride_${e.stride.x}_${e.stride.y}_padding_${e.padding.top}_${e.padding.right}_${e.padding.bottom}_${e.padding.left}_dilation_${e.dilation.x}_${e.dilation.y}_bias_${e.bias ? "1" : "0"}_activation_${e.activation}`
                        }
                        compileProgram() {
                            let e = this.context
                              , t = this.operator;
                            if (!this.weightTexture) {
                                let r = n.WebGLLayout.fold([1, t.kernel.h, t.kernel.w, t.channel.out], e)
                                  , i = r.reorderAsTexture(t.weight);
                                this.weightTexture = e.allocTexture(i, r)
                            }
                            if (!this.biasTexture && t.bias) {
                                let r = n.WebGLLayout.fold([t.channel.out], e)
                                  , i = r.reorderAsTexture(t.bias);
                                this.biasTexture = e.allocTexture(i, r)
                            }
                            e.deleteProgram(this.program),
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        initLoc() {
                            let e = this.context;
                            this.inputLoc = e.getUniformLocation(this.program, "input_s"),
                            this.weightLoc = e.getUniformLocation(this.program, "weight_s"),
                            this.biasLoc = e.getUniformLocation(this.program, "bias_s"),
                            this.inputStridesLoc = e.getUniformLocation(this.program, "inputStrides"),
                            this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                            this.weightStridesLoc = e.getUniformLocation(this.program, "weightStrides"),
                            this.inputFoldLoc = e.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                            this.weightFoldLoc = e.getUniformLocation(this.program, "weightFold"),
                            this.biasFoldLoc = e.getUniformLocation(this.program, "biasFold"),
                            this.inputShapeLoc = e.getUniformLocation(this.program, "inputShapes"),
                            this.allocTexture()
                        }
                        allocTexture() {
                            let e = this.context
                              , t = this.operator;
                            if (!this.weightTexture) {
                                let r = n.WebGLLayout.fold([1, t.kernel.h, t.kernel.w, t.channel.out], e)
                                  , i = r.reorderAsTexture(t.weight);
                                this.weightTexture = e.allocTexture(i, r)
                            }
                            if (!this.biasTexture && t.bias) {
                                let r = n.WebGLLayout.fold([t.channel.out], e)
                                  , i = r.reorderAsTexture(t.bias);
                                this.biasTexture = e.allocTexture(i, r)
                            }
                        }
                        bindUniform(e, t) {
                            let r = this.context
                              , i = e[0].storage
                              , n = t[0].storage;
                            if (r.bindTexture(i, this.inputLoc, 0),
                            r.bindTexture(this.weightTexture, this.weightLoc, 1),
                            r.bindTexture(this.biasTexture, this.biasLoc, 2),
                            this.needUpadateBinding) {
                                let e = i.layout.getStrides()
                                  , t = n.layout.getStrides()
                                  , o = this.weightTexture.layout.getStrides()
                                  , a = [i.layout.folding.w, i.layout.folding.h]
                                  , s = [n.layout.folding.w, n.layout.folding.h]
                                  , u = [this.weightTexture.layout.folding.w, this.weightTexture.layout.folding.h]
                                  , l = [this.biasTexture.layout.folding.w, this.biasTexture.layout.folding.h];
                                r.bindUniform4FV(this.inputShapeLoc, [...i.layout.shape.dims]),
                                r.bindUniform3FV(this.inputStridesLoc, e),
                                r.bindUniform3FV(this.outputStridesLoc, t),
                                r.bindUniform3FV(this.weightStridesLoc, o),
                                r.bindUniform2FV(this.inputFoldLoc, a),
                                r.bindUniform2FV(this.outputFoldLoc, s),
                                r.bindUniform2FV(this.weightFoldLoc, u),
                                r.bindUniform2FV(this.biasFoldLoc, l),
                                this.needUpadateBinding = !1
                            }
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.useProgram(this.program),
                            i.attachFramebuffer(r),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script() {
                            let e = this.operator
                              , t = this.context
                              , r = e.kernel.h
                              , n = e.kernel.w
                              , a = e.dilation.y
                              , s = e.dilation.x;
                            return `${t.precision}

    varying vec2 TexCoords;
    uniform sampler2D input_s, weight_s, bias_s;
    uniform vec3 inputStrides;
    uniform vec3 outputStrides;
    uniform vec3 weightStrides;
    uniform vec2 inputFold;
    uniform vec2 outputFold;
    uniform vec2 weightFold;
    uniform vec2 biasFold;
    uniform vec4 inputShapes;
    int IH = int(inputShapes[1]);
    int IW = int(inputShapes[2]);

    ${o.TexCoordDimScript}
    vec2 coord_input(int n, int h, int w, int c4) {
        return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
    }

    vec2 coord_weight(int n, int h, int w, int c4) {
        return dim4ToTexCoord(vec4(n, h, w, c4), weightStrides, weightFold);
    }

    vec2 coord_output(int n, int h, int w, int c4) {
        return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
    }

    vec2 coord_bias(int c4) {
        return dim1ToTexCoord(c4, biasFold);
    }

    void main() {
        vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
        int on = int(dims[0]);
        int oh = int(dims[1]);
        int ow = int(dims[2]);
        int oc4 = int(dims[3]);
        int oc = oc4 * 4;
        int ih = oh * ${e.stride.y} - ${e.padding.top};
        int iw = ow * ${e.stride.x} - ${e.padding.left};
        vec4 out4 = texture2D(bias_s, coord_bias(oc4));

        for (int kh = 0; kh < ${r}; kh++) {
            if (ih + kh * ${a} < 0 || ih + kh * ${a} >= IH) continue;
            for (int kw = 0; kw < ${n}; kw++) {
                if (iw + kw * ${s} < 0 || iw + kw * ${s} >= IW) continue;
                vec4 in4 = texture2D(input_s, coord_input(on, ih + kh * ${a}, iw + kw * ${s}, oc4));
                vec4 filter4 = texture2D(weight_s, coord_weight(0, kh, kw, oc4));
                out4 += in4 * filter4;
            }
        }

    gl_FragColor = ${e.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};

    }
`
                        }
                    }
                    s.WebGLOps.register( (e, t) => new u(e,t), i.DepthwiseConv2D)
                }
                ,
                3490: (e, t, r) => {
                    let i = r(3507)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            let e = this.operator;
                            return `eltwise_type_${e.type}_activation_${e.activation}`
                        }
                        compileProgram() {
                            let e = this.context;
                            e.deleteProgram(this.program),
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        initLoc() {
                            let e = this.context;
                            this.input1Loc = e.getUniformLocation(this.program, "input1_s"),
                            this.input2Loc = e.getUniformLocation(this.program, "input2_s")
                        }
                        bindUniform(e, t) {
                            let r = e[0].storage
                              , i = e[1].storage
                              , n = this.context;
                            n.bindTexture(r, this.input1Loc, 0),
                            n.bindTexture(i, this.input2Loc, 1)
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.useProgram(this.program),
                            i.attachFramebuffer(r),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script() {
                            let e = this.context
                              , t = this.operator;
                            if (t.type == i.EltwiseType.Add)
                                return `${e.precision}
varying vec2 TexCoords;
uniform sampler2D input1_s, input2_s;
void main() {
    vec4 in4_1 = texture2D(input1_s, TexCoords);
    vec4 in4_2 = texture2D(input2_s, TexCoords);
    vec4 out4 = in4_1 + in4_2;
    gl_FragColor = ${t.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
}
`;
                            if (t.type == i.EltwiseType.Prod)
                                return `${e.precision}
varying vec2 TexCoords;
uniform sampler2D input1_s, input2_s;
void main() {
    vec4 in4_1 = texture2D(input1_s, TexCoords);
    vec4 in4_2 = texture2D(input2_s, TexCoords);
    vec4 out4 = in4_1 * in4_2;
    gl_FragColor = ${t.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
}
`;
                            throw Error("[webgl] Eltwise only support: 1.Add  2.Prod ")
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Eltwise)
                }
                ,
                8522: (e, t, r) => {
                    let i = r(2520)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        dispose() {
                            super.dispose(),
                            this.context.releaseTexture(this.indexTexture)
                        }
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            if (e[0].shape.dims.length !== t[0].shape.dims.length)
                                throw Error("input's length and output's length must be the same for gather op!");
                            let o = n.WebGLLayout.fold(i.outputShape, r)
                              , a = o.reorderAsTexture(new Float32Array(i.index.buffer));
                            this.indexTexture = r.allocTexture(a, o),
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.scriptGather(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.indexLoc = r.getUniformLocation(this.program, "index_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.bindTexture(this.indexTexture, this.indexLoc, 1),
                            n.draw()
                        }
                        scriptGather(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.dim
                              , s = "out_axis_";
                            return `${i.precision}
${this.indexTexture.layout.scriptDimsToCoord("coord_index")}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s, index_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", Array(t.shape.dims.length).fill(s).map( (e, t) => e + t))}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);

    vec4 index4 = texture2D(index_s, coord_index(${[...t.shape.dims].map( (e, t) => s + t).join(",")}));
    // TODO: input texture memory fold diagonally to accelerate maybe?
    out4[0] = texture2D(input_s, coord_input(${[...t.shape.dims].map( (e, t) => t == a ? "int(index4[0])" : s + t).join(",")})).x;
    out4[1] = texture2D(input_s, coord_input(${[...t.shape.dims].map( (e, t) => t == a ? "int(index4[1])" : s + t).join(",")})).y;
    out4[2] = texture2D(input_s, coord_input(${[...t.shape.dims].map( (e, t) => t == a ? "int(index4[2])" : s + t).join(",")})).z;
    out4[3] = texture2D(input_s, coord_input(${[...t.shape.dims].map( (e, t) => t == a ? "int(index4[3])" : s + t).join(",")})).w;
    gl_FragColor = out4;
}`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Gather)
                }
                ,
                3315: (e, t, r) => {
                    let i = r(5113)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        dispose() {
                            super.dispose(),
                            this.context.releaseTexture(this.gridTexture)
                        }
                        resize(e, t) {
                            let r = this.context
                              , o = this.operator
                              , a = n.WebGLLayout.fold(o.gridShape, r)
                              , s = a.reorderAsTexture(new Float32Array(o.grid.buffer));
                            if (this.gridTexture = r.allocTexture(s, a),
                            r.deleteProgram(this.program),
                            o.mode == i.SampleType.Nearest)
                                this.program = r.compile(this.scriptGridSampleNearest(e[0], t[0]));
                            else {
                                if (o.mode != i.SampleType.Bilinear)
                                    throw Error("GridSample: Padding Type was not supported!");
                                this.program = r.compile(this.scriptGridSampleBilinear(e[0], t[0]))
                            }
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.gridLoc = r.getUniformLocation(this.program, "grid_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.bindTexture(this.gridTexture, this.gridLoc, 1),
                            n.draw()
                        }
                        scriptGridSampleBilinear(e, t) {
                            let r = this.operator
                              , n = this.context
                              , o = e.storage.layout
                              , a = t.storage.layout
                              , [s,u,l,c] = e.shape.dims;
                            return `${n.precision}
${this.gridTexture.layout.scriptDimsToCoord("coord_grid")}
${o.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s, grid_s;
bool is_out_of_bounds(int index, int boundary) {
    if (index < 0 || index > boundary - 1) return true;
    return false;
}
int mod(int x, int y) {
    return x - x / y * y;
}
int max(int a, int b) {
    return a < b ? b : a;
}
int min(int a, int b) {
    return a < b ? a : b;
}
void main() {
    vec4 out4 = vec4(0.0);
    ${a.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    int offset_h = mod(oh, 4);
    float coor_x = 0.0, coor_y = 0.0;
    if (offset_h == 0) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).x;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).x;
    }
    else if (offset_h == 1) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).y;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).y;
    }
    else if (offset_h == 2) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).z;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).z;
    }
    else {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).w;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).w;
    }

    for (int i = 0; i < 4; ++i) {
        // left up corner coordinate
        float x_pos_f = floor((coor_x + 1.0) / 2.0) * float(${u}) - 0.5;
        float y_pos_f = floor((coor_y + 1.0) / 2.0) * float(${l}) - 0.5;
        int x_pos_i = int(floor(x_pos_f));
        int y_pos_i = int(floor(y_pos_f));
        float xs = fract(x_pos_f);
        float ys = fract(y_pos_f);
        float p0, p1, p2, p3;

    ${( () => {
                                if (r.paddingMode == i.PaddingType.Zeros)
                                    return `if (is_out_of_bounds(y_pos_i, ${l})) {
                p0 = 0.0;
                p1 = 0.0;
            } else {
                p0 = is_out_of_bounds(x_pos_i, ${u}) ? 0.0 : texture2D(input_s, coord_input(on, y_pos_i, x_pos_i, oc4))[i];
                p1 = is_out_of_bounds(x_pos_i + 1, ${u}) ? 0.0 : texture2D(input_s, coord_input(on, y_pos_i, x_pos_i + 1, oc4))[i];
            }

            if (is_out_of_bounds(y_pos_i + 1, ${l})) {
                p2 = 0.0;
                p3 = 0.0;
            } else {
                p2 = is_out_of_bounds(x_pos_i, ${u}) ? 0.0 : texture2D(input_s, coord_input(on, y_pos_i + 1, x_pos_i, oc4))[i];
                p3 = is_out_of_bounds(x_pos_i + 1, ${u}) ? 0.0 : texture2D(input_s, coord_input(on, y_pos_i + 1, x_pos_i + 1, oc4))[i];
            }`;
                                if (r.paddingMode == i.PaddingType.Border)
                                    return `int xp0 = max(x_pos_i, 0);
                    int xp1 = min(x_pos_i + 1, ${u - 1});
                    int yp0 = max(y_pos_i, 0);
                    int yp1 = min(y_pos_i + 1, ${l - 1});
                    p0 = texture2D(input_s, coord_input(on, yp0, xp0, oc4))[i];
                    p1 = texture2D(input_s, coord_input(on, yp0, xp1, oc4))[i];
                    p2 = texture2D(input_s, coord_input(on, yp1, xp0, oc4))[i];
                    p3 = texture2D(input_s, coord_input(on, yp1, xp1, oc4))[i];`;
                                if (r.paddingMode == i.PaddingType.Reflection)
                                    return `
                int xp0 = x_pos_i < 0 ? -x_pos_i : x_pos_i;
                xp0 = x_pos_i > ${u - 1}? 2 * ${u} - x_pos_i - 2 : x_pos_i;
                int xp1 = (x_pos_i + 1) < 0 ? -x_pos_i - 1 : x_pos_i + 1;
                xp1 = (x_pos_i + 1) > ${u - 1} ? 2 * ${u} - x_pos_i - 3 : x_pos_i + 1;
                int yp0 = y_pos_i < 0 ? -y_pos_i : y_pos_i;
                yp0 = y_pos_i > ${l - 1} ? 2 * ${l} - y_pos_i - 2 : y_pos_i;
                int yp1 = (y_pos_i + 1) < 0 ? -y_pos_i - 1 : y_pos_i + 1;
                yp1 = (y_pos_i + 1) > ${l - 1} ? 2 * ${l} - y_pos_i - 3 : y_pos_i + 1;
                p0 = texture2D(input_s, coord_input(on, yp0, xp0, oc4))[i];
                p1 = texture2D(input_s, coord_input(on, yp0, xp1, oc4))[i];
                p2 = texture2D(input_s, coord_input(on, yp1, xp0, oc4))[i];
                p3 = texture2D(input_s, coord_input(on, yp1, xp1, oc4))[i];`;
                                throw Error("GridSample: Padding Type was not supported!")
                            }
                            )()}
        out4[i] = mix(mix(p0, p1, xs), mix(p2, p3, xs), ys);
    }
    gl_FragColor = out4;
}`
                        }
                        scriptGridSampleNearest(e, t) {
                            let r = this.operator
                              , n = this.context
                              , o = e.storage.layout
                              , a = t.storage.layout
                              , [s,u,l,c] = e.shape.dims;
                            return `${n.precision}
${this.gridTexture.layout.scriptDimsToCoord("coord_grid")}
${o.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s, grid_s;
bool is_out_of_bounds(int index, int boundary) {
    if (index < 0 || index > boundary - 1) return true;
    return false;
}
void main() {
    vec4 out4 = vec4(0.0);
    ${a.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    int offset_h = mod(oh, 4);
    float coor_x = 0.0, coor_y = 0.0;
    if (offset_h == 0) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).x;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).x;
    }
    else if (offset_h == 1) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).y;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).y;
    }
    else if (offset_h == 2) {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).z;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).z;
    }
    else {
        coor_x = texture2D(grid_s, coord_grid(on, ow, 0, oh / 4)).w;
        coor_y = texture2D(grid_s, coord_grid(on, ow, 1, oh / 4)).w;
    }
    for (int i = 0; i < 4; ++i) {
        float x_pos_f = floor((coor_x + 1.0) / 2.0) * float(${u}) - 0.5;
        float y_pos_f = floor((coor_y + 1.0) / 2.0) * float(${l}) - 0.5;
        int x_pos_i = int(floor(x_pos_f));
        int y_pos_i = int(floor(y_pos_f));
        float p0 = 0.0;

    ${( () => {
                                if (r.paddingMode == i.PaddingType.Zeros)
                                    return `p0 = is_out_of_bounds(y_pos_i, ${l}) || is_out_of_bounds(x_pos_i, ${u}) ? 0.0 : texture2D(input_s, coord_input(on, y_pos_i, x_pos_i, oc4))[i];`;
                                if (r.paddingMode == i.PaddingType.Border)
                                    return `p0 = texture2D(input_s, coord_input(on, int(clamp(float(y_pos_i), 0.0, float(${l} - 1))), int(clamp(float(x_pos_i), 0.0, float(${u} - 1))), oc4))[i];`;
                                if (r.paddingMode == i.PaddingType.Reflection)
                                    return `
                int xp0 = x_pos_i < 0 ? -x_pos_i : x_pos_i;
                xp0 = x_pos_i > ${u - 1} ? 2 * ${u} - x_pos_i - 2 : x_pos_i;
                int yp0 = y_pos_i < 0 ? -y_pos_i : y_pos_i;
                yp0 = y_pos_i > ${l - 1} ? 2 * ${l} - y_pos_i - 2 : y_pos_i;
                p0 = texture2D(input_s, coord_input(on, yp0, xp0, oc4))[i];`;
                                throw Error("GridSample: Padding Type was not supported!")
                            }
                            )()}
        out4[i] = p0;
    }
    gl_FragColor = out4;
}`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.GridSample)
                }
                ,
                4974: (e, t, r) => {
                    let i = r(4965)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        dispose() {
                            super.dispose();
                            let e = this.context;
                            e.releaseTexture(this.weightTexture),
                            e.releaseTexture(this.biasTexture)
                        }
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator
                              , o = e[0].shape.dims.slice(-1)[0];
                            if (!this.weightTexture) {
                                let e = n.WebGLLayout.fold([i.outChannel, o], r)
                                  , t = e.reorderAsTexture(i.weight);
                                this.weightTexture = r.allocTexture(t, e)
                            }
                            if (!this.biasTexture && i.bias) {
                                let e = n.WebGLLayout.fold([i.outChannel], r)
                                  , t = e.reorderAsTexture(i.bias);
                                this.biasTexture = r.allocTexture(t, e)
                            }
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.scriptGemm(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.weightLoc = r.getUniformLocation(this.program, "weight_s"),
                            this.biasLoc = r.getUniformLocation(this.program, "bias_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.bindTexture(this.weightTexture, this.weightLoc, 1),
                            n.bindTexture(this.biasTexture, this.biasLoc, 2),
                            n.draw()
                        }
                        scriptGemm(e, t) {
                            let r = this.operator
                              , o = this.context
                              , a = e.storage.layout
                              , s = t.storage.layout
                              , u = t.shape.dims.length - 1
                              , l = a.shape.dims.slice(-1)[0]
                              , c = "out_axis_";
                            return `${o.precision}
${this.weightTexture.layout.scriptDimsToCoord("coord_weight")}
${this.biasTexture.layout.scriptDimsToCoord("coord_bias")}
${a.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s, weight_s, bias_s;
void main() {
    ${s.scriptCoordToDims("TexCoords", Array(t.shape.dims.length).fill("out_axis_").map( (e, t) => e + t))}

    vec4 out4 = texture2D(bias_s, coord_bias(${c + u}));
    for (int in_last_axis4 = 0; in_last_axis4 < ${n.upDiv(l, 4)}; in_last_axis4++) {
        vec4 in4 = texture2D(input_s, coord_input(${[...t.shape.dims].map( (e, t) => t == u ? "in_last_axis4" : c + t).join(",")}));
        vec4 w0 = texture2D(weight_s, coord_weight(${c + u} * 4 + 0, in_last_axis4));
        vec4 w1 = texture2D(weight_s, coord_weight(${c + u} * 4 + 1, in_last_axis4));
        vec4 w2 = texture2D(weight_s, coord_weight(${c + u} * 4 + 2, in_last_axis4));
        vec4 w3 = texture2D(weight_s, coord_weight(${c + u} * 4 + 3, in_last_axis4));
        out4 += vec4(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
        }
    gl_FragColor = ${r.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
}`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.InnerProduct)
                }
                ,
                9998: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGLKernel = void 0;
                    let i = r(4401);
                    class n extends i.Kernel {
                        constructor() {
                            super(...arguments),
                            this.preInitFlag = !1,
                            this.needUpadateBinding = !0
                        }
                        dispose() {
                            this.context.deleteProgram(this.program)
                        }
                        initProgram(e, t) {
                            let r = this.getProgramKey()
                              , i = this.context;
                            if (r) {
                                let e = i.compileByFragShaderKey(r);
                                if (e)
                                    return void (this.program = e)
                            }
                            this.compileProgram(e, t)
                        }
                        resize(e, t) {
                            this.program || (this.initProgram(e, t),
                            this.initLoc(e, t)),
                            this.needUpadateBinding = !0
                        }
                        unify(e) {
                            return e
                        }
                        isPreInit() {
                            return this.preInitFlag
                        }
                        preInit(e, t) {
                            this.initProgram(e, t),
                            this.preInitFlag = !0
                        }
                        init(e, t) {
                            this.initLoc(e, t),
                            this.preInitFlag = !1
                        }
                        isInitialized() {
                            return !!this.program
                        }
                    }
                    t.WebGLKernel = n
                }
                ,
                6340: (e, t, r) => {
                    let i = r(714)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script()),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage;
                            this.operator.inplace && (i = this.context.allocTexture(t[0].type, i.layout),
                            t[0].storage = i);
                            let n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        script() {
                            let e = this.operator;
                            return `${this.context.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    vec4 out4 = step(0.0, in4) * in4 + (vec4(1.0) - step(0.0, in4)) * vec4(float(${e.alpha})) * in4;
    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.LeakyReLU)
                }
                ,
                5778: (e, t, r) => {
                    let i = r(3679)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        dispose() {
                            super.dispose();
                            let e = this.context;
                            e.releaseTexture(this.midTexture),
                            e.releaseTexture(this.gammaTexture),
                            e.releaseTexture(this.betaTexture)
                        }
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator
                              , o = e[0].shape.copy()
                              , a = e[0].shape.copy()
                              , s = !0;
                            for (let e = o.dims.length - 1; e >= 0; --e)
                                i.nomalizedType >> o.dims.length - e - 1 & 1 ? (o.dims[e] = s ? 2 : 1,
                                s = !1) : a.dims[e] = 1;
                            let u = n.WebGLLayout.fold(o, r)
                              , l = u.reorderAsTexture(new Float32Array(o.stride()).fill(0));
                            this.midTexture = r.allocTexture(l, u);
                            let c = n.WebGLLayout.fold(a, r)
                              , p = c.reorderAsTexture(i.gamma);
                            this.gammaTexture = r.allocTexture(p, c);
                            let d = n.WebGLLayout.fold(a, r)
                              , f = c.reorderAsTexture(i.beta);
                            this.betaTexture = r.allocTexture(f, d),
                            r.deleteProgram(this.program),
                            r.deleteProgram(this.localProgram),
                            1 & i.nomalizedType ? this.localProgram = r.compile(this.scriptCalcParamsContainsLastAxis(e[0])) : this.localProgram = r.compile(this.scriptCalcParamsNotContainsLastAxis(e[0])),
                            this.inputLocalLoc = r.getUniformLocation(this.localProgram, "input_s"),
                            this.program = r.compile(this.scriptNormalize(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.midLoc = r.getUniformLocation(this.program, "mid_s"),
                            i.elementwiseAffine && (this.gammaLoc = r.getUniformLocation(this.program, "gamma_s"),
                            this.betaLoc = r.getUniformLocation(this.program, "beta_s"))
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context
                              , o = this.operator;
                            n.useProgram(this.localProgram),
                            n.attachFramebuffer(this.midTexture),
                            n.bindTexture(r, this.inputLocalLoc, 0),
                            n.draw(),
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.bindTexture(this.midTexture, this.midLoc, 1),
                            o.elementwiseAffine && (n.bindTexture(this.gammaTexture, this.gammaLoc, 2),
                            n.bindTexture(this.betaTexture, this.betaLoc, 3)),
                            n.draw()
                        }
                        scriptCalcParamsContainsLastAxis(e) {
                            let t = this.operator
                              , r = this.context
                              , i = e.storage.layout
                              , o = [];
                            for (let r = 0; r < e.shape.dims.length; ++r)
                                t.nomalizedType >> e.shape.dims.length - r - 1 & 1 && o.push(r);
                            let a = [...e.shape.dims.filter( (e, t) => o.indexOf(t) >= 0)].reduce( (e, t) => e * t)
                              , s = Array(e.shape.dims.length).fill("out_axis_").map( (e, t) => e + t)
                              , u = [...s];
                            return o.map( (e, t) => u[e] = "index_" + t),
                            `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${this.midTexture.layout.scriptCoordToDims("TexCoords", s)}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 temp4;
    float mean = 0.0;
    float var = 0.0;
    ${( () => {
                                let t = "";
                                for (let r = 0; r < o.length; ++r)
                                    t += o[r] == e.shape.dims.length - 1 ? `for (int index_${r} = 0; index_${r} < ${n.upDiv(e.shape.dims[o[r]], 4)}; ++index_${r}) 
 ` : `for (int index_${r} = 0; index_${r} < ${e.shape.dims[o[r]]}; ++index_${r}) 
`;
                                return t
                            }
                            )()}
    {
        temp4 = texture2D(input_s, coord_input(${u}));
        if (${u.slice(-1)[0]} == ${n.upDiv(e.shape.dims[o.slice(-1)[0]], 4) - 1}) {
            if (mod(${e.shape.dims[o.slice(-1)[0]]}, 4) == 1) {
                mean += temp4[0];
                var += temp4[0] * temp4[0];
            }
            else if (mod(${e.shape.dims[o.slice(-1)[0]]}, 4) == 2) {
                mean += temp4[0] + temp4[1];
                var += temp4[0] * temp4[0] + temp4[1] * temp4[1];
            }
            else if (mod(${e.shape.dims[o.slice(-1)[0]]}, 4) == 3) {
                mean += temp4[0] + temp4[1] + temp4[2];
                var += temp4[0] * temp4[0] + temp4[1] * temp4[1] + temp4[2] * temp4[2];
            }
            else {
                mean += temp4[0] + temp4[1] + temp4[2] + temp4[3];
                var += temp4[0] * temp4[0] + temp4[1] * temp4[1] + temp4[2] * temp4[2] + temp4[3] * temp4[3];
            }
        }
        else {
            mean += temp4[0] + temp4[1] + temp4[2] + temp4[3];
            var += temp4[0] * temp4[0] + temp4[1] * temp4[1] + temp4[2] * temp4[2] + temp4[3] * temp4[3];
        }

    }
    // E(x^2) - E(x)^2
    mean /= float(${a});
    var /= float(${a});
    out4[0] = mean;
    out4[1] = sqrt(var - mean * mean + ${t.epsilon});
    // TODO: Since webgl texture shader has no concept of warp or workgroup as CUDA/Compute Shader,
    //       wondering how to leverage the throughput rate?
    gl_FragColor = out4;
}`
                        }
                        scriptCalcParamsNotContainsLastAxis(e) {
                            let t = this.operator
                              , r = this.context
                              , i = e.storage.layout
                              , n = [];
                            for (let r = 0; r < e.shape.dims.length; ++r)
                                t.nomalizedType >> e.shape.dims.length - r - 1 & 1 && n.push(r);
                            let o = [...e.shape.dims.filter( (e, t) => n.indexOf(t) >= 0)].reduce( (e, t) => e * t)
                              , a = Array(e.shape.dims.length).fill("out_axis_").map( (e, t) => e + t)
                              , s = [...a];
                            return n.map( (e, t) => s[e] = "index_" + t),
                            `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${this.midTexture.layout.scriptCoordToDims("TexCoords", a)}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 temp4;
    vec4 mean = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 var = vec4(0.0, 0.0, 0.0, 0.0);
    ${( () => {
                                let t = "";
                                for (let r = 0; r < n.length; ++r)
                                    t += `for (int index_${r} = 0; index_${r} < ${e.shape.dims[n[r]]}; ++index_${r}) `;
                                return t
                            }
                            )()}
    {
        temp4 = texture2D(input_s, coord_input(${s}));
        mean += temp4;
        var += temp4 * temp4;
    }

    mean /= vec4(${o});
    var /= vec4(${o});
    if (${a[n.slice(-1)[0]]} > 0) {
        var -= mean * mean + vec4(${t.epsilon});
        out4 = sqrt(var);
    } else {
        out4 = mean;
    }
    gl_FragColor = out4;
}
`
                        }
                        scriptNormalize(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = [];
                            for (let t = 0; t < e.shape.dims.length; ++t)
                                r.nomalizedType >> e.shape.dims.length - t - 1 & 1 && a.push(t);
                            let s = 1 & r.nomalizedType
                              , u = "out_axis_"
                              , l = Array(e.shape.dims.length).fill(u).map( (e, t) => e + t)
                              , c = [...l]
                              , p = [...l];
                            a.map( (e, t) => {
                                c[e] = "0",
                                p[e] = t != a.length - 1 || s ? "0" : "1"
                            }
                            );
                            let d = Array(e.shape.dims.length).fill("0");
                            return a.map( (e, t) => d[e] = u + e),
                            `${i.precision}
${this.midTexture.layout.scriptDimsToCoord("coord_mid")}
${this.gammaTexture.layout.scriptDimsToCoord("coord_gamma")}
${this.betaTexture.layout.scriptDimsToCoord("coord_beta")}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s, mid_s;
uniform sampler2D gamma_s, beta_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", l)}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 in4 = texture2D(input_s, coord_input(${l}));

    vec4 mean4 = ${s ? `vec4(texture2D(mid_s, coord_mid(${c})).x);` : `texture2D(mid_s, coord_mid(${c}));`}
    vec4 std_var4 = ${s ? `vec4(texture2D(mid_s, coord_mid(${p})).y);` : `texture2D(mid_s, coord_mid(${p}));`}
    ${r.elementwiseAffine ? `vec4 gamma4 = texture2D(gamma_s, coord_gamma(${d}));
 vec4 beta4 = texture2D(beta_s, coord_beta(${d}));
` : "vec4 gamma4 = vec4(1.0);\n vec4 beta4 = vec4(0.0);\n"}
    vec4 scale = ${s ? "gamma4;" : "vec4(gamma4.x);"}
    vec4 bias = ${s ? "beta4;" : "vec4(beta4.x);"}
    out4 = scale * (in4 - mean4) / std_var4 + bias;
    gl_FragColor = out4;
}`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Normalization)
                }
                ,
                1642: (e, t, r) => {
                    let i = r(8528)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        script(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.axis
                              , s = r.onValue
                              , u = r.offValue
                              , l = "out_axis_";
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", Array(t.shape.dims.length).fill(l).map( (e, t) => e + t))}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 in4 = texture2D(input_s, coord_input(${[...e.shape.dims].map( (e, t) => t >= a ? l + (t + 1) : l + t).join(",")}));
    out4[0] = out_axis_${a} == int(in4[0]) ? float(${s}) : float(${u});
    out4[1] = out_axis_${a} == int(in4[1]) ? float(${s}) : float(${u});
    out4[2] = out_axis_${a} == int(in4[2]) ? float(${s}) : float(${u});
    out4[3] = out_axis_${a} == int(in4[3]) ? float(${s}) : float(${u});

    gl_FragColor = out4;
}
`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.OneHot)
                }
                ,
                4740: (e, t, r) => {
                    let i = r(8391)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = e[0].storage.layout
                              , n = t[0].storage.layout
                              , o = this.operator;
                            if (o.type != i.OpType.Reshape)
                                throw Error(`${o.type} is not supported!`);
                            {
                                if (r.shape.elements !== n.shape.elements)
                                    throw Error("num of element must be the same for reshape");
                                let i = this.context;
                                i.deleteProgram(this.program),
                                this.program = i.compile(this.reindexScript(e[0], t[0])),
                                this.inputLoc = i.getUniformLocation(this.program, "input_s")
                            }
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        reindexScript(e, t) {
                            let r = this.context
                              , i = e.storage.layout
                              , n = t.storage.layout
                              , [,o,a,s] = e.shape.dims
                              , [u,l,c,p] = t.shape.dims;
                            return `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main(){
    ${n.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);
    int oc = oc4 * 4;
    for (int i = 0; i < 4; i++) {
        int nchw_addr = on * ${l * c * p} + (oc + i) * ${l * c} + oh * ${c} + ow;
        int i_n = nchw_addr / (${s * o * a});
        nchw_addr -= i_n * ${s * o * a};
        int ic4 = nchw_addr / (${o * a} * 4);
        nchw_addr -= ic4 * ${o * a} * 4;
        int offset = nchw_addr / (${o * a});
        nchw_addr -= offset * ${o * a};
        int ih = nchw_addr / ${a} ;
        int iw = nchw_addr - ih * ${a};
        // Index expression must be constant below glsl 3.0
        if (offset == 0) {
            res[i] = texture2D(input_s, coord_input(i_n, ih, iw, ic4)).x;
        }
        else if (offset == 1) {
            res[i] = texture2D(input_s, coord_input(i_n, ih, iw, ic4)).y;
        }
        else if (offset == 2) {
            res[i] = texture2D(input_s, coord_input(i_n, ih, iw, ic4)).z;
        }
        else {
            res[i] = texture2D(input_s, coord_input(i_n, ih, iw, ic4)).w;
        }
    }
    gl_FragColor = res;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.OnnxOp1)
                }
                ,
                5260: (e, t, r) => {
                    let i = r(3011)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            if (e[0].shape.elements != e[0].shape.elements)
                                throw Error("OnnxOp2: doesn't support broadcast yet!");
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e, t)),
                            this.input1Loc = r.getUniformLocation(this.program, "input1_s"),
                            this.input2Loc = r.getUniformLocation(this.program, "input2_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = e[1].storage
                              , n = t[0].storage
                              , o = this.context;
                            o.useProgram(this.program),
                            o.attachFramebuffer(n),
                            o.bindTexture(r, this.input1Loc, 0),
                            o.bindTexture(i, this.input2Loc, 1),
                            o.draw()
                        }
                        compute(e, t, r) {
                            switch (e) {
                            case i.OpType.Sum:
                                return `${t} + ${r}`;
                            case i.OpType.Pow:
                                return `pow(${t}, ${r})`;
                            case i.OpType.Sub:
                                return `${t} - ${r}`;
                            case i.OpType.Mul:
                                return `${t} * ${r}`;
                            case i.OpType.Div:
                                return `${t} / ${r}`;
                            case i.OpType.Equal:
                                return `vec4(equal(${t}, ${r}))`;
                            case i.OpType.Greater:
                                return `step(${r}, ${t})`;
                            case i.OpType.Less:
                                return `vec4(1.0) - step(${r}, ${t})`;
                            case i.OpType.Max:
                                return `max(${t}, ${r})`;
                            case i.OpType.Min:
                                return `min(${t}, ${r})`;
                            case i.OpType.Mean:
                                return `(${t} + ${r}) / vec4(2.0)`;
                            default:
                                throw Error("OnnxOp2 op not supported: " + e)
                            }
                        }
                        script(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = r.type;
                            return `${i.precision}
varying vec2 TexCoords;
uniform sampler2D input1_s, input2_s;
void main(){
    vec4 in4_1 = texture2D(input1_s, TexCoords);
    vec4 in4_2 = texture2D(input2_s, TexCoords);
    gl_FragColor = ${this.compute(n, "in4_1", "in4_2")};
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.OnnxOp2)
                }
                ,
                1535: (e, t, r) => {
                    let i = r(4463)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e, t)),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        script(e, t) {
                            let r = this.context
                              , i = this.operator
                              , n = e[0].storage.layout
                              , o = t[0].storage.layout
                              , [a,s,u,l] = e[0].shape.dims
                              , [,c,p] = t[0].shape.dims;
                            return `${r.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${o.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    int ih = oh - ${i.padTop};
    int iw = ow - ${i.padLeft};
    vec4 v_out4 = vec4(0.0);
    if(ih >= 0 && ih < ${s} && iw >= 0 && iw < ${u}){
        v_out4 = texture2D(input_s, coord_input(on, ih, iw, oc4));
    }
    gl_FragColor = v_out4;
}
`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Pad2d)
                }
                ,
                4656: (e, t, r) => {
                    let i = r(1242)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        initLoc() {
                            let e = this.context;
                            this.inputLoc = e.getUniformLocation(this.program, "input_s"),
                            this.inputStridesLoc = e.getUniformLocation(this.program, "inputStrides"),
                            this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                            this.inputFoldLoc = e.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                            this.inputShapesLoc = e.getUniformLocation(this.program, "inputShapes")
                        }
                        getProgramKey() {
                            let e = this.operator;
                            return `pooling_padding_${e.padding.w}_${e.padding.h}_kernel_${e.kernel.w}_${e.kernel.h}_strides_${e.stride.x}_${e.stride.y}`
                        }
                        compileProgram() {
                            let e = this.context;
                            e.deleteProgram(this.program),
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        bindUniform(e, t) {
                            let r = this.context
                              , i = e[0].storage
                              , n = t[0].storage;
                            if (this.needUpadateBinding) {
                                let e = i.layout.getStrides()
                                  , t = n.layout.getStrides()
                                  , o = [i.layout.folding.w, i.layout.folding.h]
                                  , a = [n.layout.folding.w, n.layout.folding.h];
                                r.bindUniform3FV(this.inputStridesLoc, e),
                                r.bindUniform3FV(this.outputStridesLoc, t),
                                r.bindUniform2FV(this.inputFoldLoc, o),
                                r.bindUniform2FV(this.outputFoldLoc, a),
                                r.bindUniform4FV(this.inputShapesLoc, [...i.layout.shape.dims]),
                                this.needUpadateBinding = !1
                            }
                            r.bindTexture(i, this.inputLoc, 0)
                        }
                        isPreInit() {
                            return !!this.program && !this.inputLoc
                        }
                        preInit(e, t) {
                            this.initProgram(e, t)
                        }
                        init(e, t) {
                            this.initLoc()
                        }
                        resize(e, t) {
                            this.initProgram(e, t),
                            this.initLoc()
                        }
                        execute(e, t) {
                            e[0].storage;
                            let r = t[0].storage
                              , i = this.context;
                            i.useProgram(this.program),
                            i.attachFramebuffer(r),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script() {
                            let e = this.operator
                              , t = this.context
                              , r = e.type
                              , o = e.kernel.h
                              , a = e.kernel.w
                              , s = e.stride.x
                              , u = e.stride.y
                              , l = e.padding.w
                              , c = e.padding.h;
                            return r == i.PoolingType.Max ? `${t.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
uniform vec3 inputStrides;
uniform vec3 outputStrides;
uniform vec2 inputFold;
uniform vec2 outputFold;
uniform vec4 inputShapes;
${n.TexCoordDimScript}
vec2 coord_input(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
}
vec2 coord_output(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
}

void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int ih = oh * ${u} - ${c};
    int iw = ow * ${s} - ${l};
    int sh = ih > 0 ? ih : 0;
    int sw = iw > 0 ? iw : 0;
    int IH = int(inputShapes[1]);
    int IW = int(inputShapes[2]);

    vec4 out4 = vec4(-1000000);
    for (int kh = 0; kh < ${o}; kh++) {
        if (ih + kh < 0 || ih + kh >= IH) continue;
        for (int kw = 0; kw < ${a}; kw++) {
            if (iw + kw < 0 || iw + kw >= IW) continue;
            vec4 in4 = texture2D(input_s, coord_input(on, ih + kh, iw + kw, oc4));
            out4 = max(out4, in4);
        }
    }
    gl_FragColor = out4;
}
` : `${t.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
uniform vec3 inputStrides;
uniform vec3 outputStrides;
uniform vec2 inputFold;
uniform vec2 outputFold;
uniform vec2 biasFold;
uniform vec4 inputShapes;
${n.TexCoordDimScript}
vec2 coord_input(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
}
void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int IH = int(inputShapes[1]);
    int IW = int(inputShapes[2]);
    int ih = oh * ${u} - ${c};
    int iw = ow * ${s} - ${l};
    int sh = ih > 0 ? ih : 0;
    int sw = iw > 0 ? iw : 0;
    int eh = (ih + ${o}) < IH ? (ih + ${o}) : IH;
    int ew = (iw + ${a}) < IW ? (iw + ${a}) : IW;

    vec4 out4 = vec4(0.0);
    for (int kh = 0; kh < ${o}; kh++) {
        if (ih + kh < 0 || ih + kh >= IH) continue;
        for (int kw = 0; kw < ${a}; kw++) {
            if (iw + kw < 0 || iw + kw >= IW) continue;
            out4 += texture2D(input_s, coord_input(on, ih + kh, iw + kw, oc4));
        }
    }
    vec4 div = vec4((eh - sh) * (ew - sw));
    gl_FragColor = out4 / div;
}
`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Pooling)
                }
                ,
                5729: (e, t, r) => {
                    let i = r(6682)
                      , n = r(8137)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            r.deleteProgram(this.program),
                            -1 != i.reductionIndices.indexOf(e[0].shape.dims.length - 1) ? this.program = r.compile(this.scriptIndiceContainsLastAxis(e[0], t[0])) : this.program = r.compile(this.scriptIndiceNotContainsLastAxis(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        scriptIndiceNotContainsLastAxis(e, t) {
                            let r = this.operator
                              , n = this.context
                              , o = e.storage.layout
                              , a = t.storage.layout
                              , s = r.reductionIndices
                              , u = [...e.shape.dims.filter( (e, t) => s.indexOf(t) >= 0)].reduce( (e, t) => e * t)
                              , l = Array(t.shape.dims.length).fill("out_axis_").map( (e, t) => e + t)
                              , c = r.keepDims ? [...l] : Array(e.shape.dims.length).fill("");
                            return !r.keepDims && [...e.shape.dims.keys()].filter(e => -1 == s.indexOf(e)).map( (e, t) => c[e] = l[t]),
                            s.map( (e, t) => c[e] = "index_" + t),
                            `${n.precision}
${o.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    ${a.scriptCoordToDims("TexCoords", l)}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    ${( () => {
                                let t = "";
                                for (let r = 0; r < s.length; ++r)
                                    t += `for (int index_${r} = 0; index_${r} < ${e.shape.dims[s[r]]}; ++index_${r}) `;
                                return t
                            }
                            )()}
    {
        out4 += texture2D(input_s, coord_input(${c}));
    }
    ${r.type == i.ReduceType.Mean ? `out4 /= vec4(${u});` : ""}
    gl_FragColor = out4;
}
`
                        }
                        scriptIndiceContainsLastAxis(e, t) {
                            let r = this.operator
                              , o = this.context
                              , a = e.storage.layout
                              , s = t.storage.layout
                              , u = r.reductionIndices
                              , l = [...e.shape.dims.filter( (e, t) => u.indexOf(t) >= 0)].reduce( (e, t) => e * t)
                              , c = Array(t.shape.dims.length).fill("out_axis_").map( (e, t) => e + t)
                              , p = r.keepDims ? [...c] : Array(e.shape.dims.length).fill("");
                            if (!r.keepDims) {
                                let t = [...e.shape.dims.keys()].filter(e => -1 == u.indexOf(e));
                                t.map( (e, r) => r == t.length - 1 ? p[e] = c[r] + " * 4 + offset" : p[e] = c[r])
                            }
                            return u.map( (e, t) => p[e] = "index_" + t),
                            `${o.precision}
${a.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${s.scriptCoordToDims("TexCoords", c)}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 temp4;
    float sum = 0.0;
    for (int offset = 0; offset < ${r.keepDims ? "1" : "4"}; ++offset) {
        sum = 0.0;
    ${( () => {
                                let t = "";
                                for (let r = 0; r < u.length; ++r)
                                    t += u[r] == e.shape.dims.length - 1 ? `for (int index_${r} = 0; index_${r} < ${n.upDiv(e.shape.dims[u[r]], 4)}; ++index_${r}) 
 ` : `for (int index_${r} = 0; index_${r} < ${e.shape.dims[u[r]]}; ++index_${r}) 
`;
                                return t
                            }
                            )()}
        {
            temp4 = texture2D(input_s, coord_input(${p}));

            if (${p.slice(-1)[0]} == ${n.upDiv(e.shape.dims[u.slice(-1)[0]], 4) - 1}) {
                if (mod(${e.shape.dims[u.slice(-1)[0]]}, 4) == 1)
                    sum += temp4[0];
                else if (mod(${e.shape.dims[u.slice(-1)[0]]}, 4) == 2)
                    sum += temp4[0] + temp4[1];
                else if (mod(${e.shape.dims[u.slice(-1)[0]]}, 4) == 3)
                    sum += temp4[0] + temp4[1] + temp4[2];
                else
                    sum += temp4[0] + temp4[1] + temp4[2] + temp4[3];
            }
            else {
                sum += temp4[0] + temp4[1] + temp4[2] + temp4[3];
            }
        }
        if (offset == 0) out4[offset] = sum;
        else if (offset == 1) out4[offset] = sum;
        else if (offset == 2) out4[offset] = sum;
        else out4[offset] = sum;
    }
    ${r.type == i.ReduceType.Mean ? `out4 /= vec4(${l});` : ""}
    gl_FragColor = out4;
}
`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Reduce)
                }
                ,
                2426: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGLOps = void 0;
                    let r = new Map;
                    t.WebGLOps = class {
                        static register(e, t) {
                            r.set(t, e)
                        }
                        static builder(e) {
                            return r.get(e.constructor)
                        }
                    }
                }
                ,
                8273: (e, t, r) => {
                    let i = r(3642)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            let r = this.context;
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        getProgramKey() {
                            return `relu_max_${this.operator.max}`
                        }
                        compileProgram(e, t) {
                            let r = this.context;
                            this.program = r.compile(this.script(), "relu")
                        }
                        bindUniform(e, t) {
                            let r = e[0].storage;
                            this.context.bindTexture(r, this.inputLoc, 0)
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage;
                            this.operator.inplace && (i = this.context.allocTexture(t[0].type, i.layout),
                            t[0].storage = i);
                            let n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            this.bindUniform(e, t),
                            n.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        script() {
                            let e = this.operator
                              , t = this.context;
                            return console.log("relu precision is %s", t.precision),
                            `${t.precision}

varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    vec4 out4 = ${0 == e.max ? "max(vec4(0.0), in4)" : `max(vec4(0.0), min(in4, float(${e.max})))`};
    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.ReLU)
                }
                ,
                3356: (e, t, r) => {
                    let i = r(2382)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        isReshapeFree(e, t) {
                            return e.shape.dims.slice(-1)[0] === t.shape.dims.slice(-1)[0] && e.folding.w === t.folding.w && e.folding.h === t.folding.h
                        }
                        getProgramKey() {
                            return "reshape"
                        }
                        compileProgram() {
                            let e = this.context;
                            e.deleteProgram(this.program),
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        initLoc() {
                            let e = this.context;
                            this.inputLoc = e.getUniformLocation(this.program, "input_s"),
                            this.inputFoldLoc = e.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                            this.inputShapesLoc = e.getUniformLocation(this.program, "inputShapes"),
                            this.outputShapesLoc = e.getUniformLocation(this.program, "outputShapes")
                        }
                        script() {
                            return `${this.context.precision}
        varying vec2 TexCoords;
        uniform sampler2D input_s;
        uniform vec4 inputShapes;
        uniform vec4 outputShapes;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        // uniform int inputDims;
        // uniform int outputDims;
        void main(){

            int inputLastChannel = int(inputShapes[3]);
            int outputLastChannel = int(outputShapes[3]);
            if (inputFold.x == outputFold.x && inputFold.y == outputFold.y && inputLastChannel == outputLastChannel) {
                gl_FragColor = texture2D(input_s, TexCoords);
                return;
            }
            vec4 res = vec4(0.0, 0.0, 0.0, 0.0);

            int numChannel = 4;
            int _x = int(TexCoords.s * float(outputFold[0]));
            int _y = int(TexCoords.t * float(outputFold[1]));
            int currentIdx = _y * outputLastChannel + _x * numChannel;

            // res[0] = texture2D(input_s, vec2(0, 0)).x;

            for (int i = 0; i < 4; i++) {
                int currentIdxInChannel = currentIdx + i;
                float inputTexCoordsH = float(currentIdxInChannel / inputLastChannel);
                int offset = int(mod(mod(float(currentIdxInChannel), float(inputLastChannel)), float(numChannel)));
                float inputTexCoordsW = float(int(mod(float(currentIdxInChannel), float(inputLastChannel)) / float(numChannel)));

                inputTexCoordsW = (inputTexCoordsW + 0.5) / float(inputFold.x);
                inputTexCoordsH = (inputTexCoordsH + 0.5) / float(inputFold.y);

                if (offset == 0)
                    res[i] = texture2D(input_s, vec2(inputTexCoordsW, inputTexCoordsH)).x;
                else if (offset == 1)
                    res[i] = texture2D(input_s, vec2(inputTexCoordsW, inputTexCoordsH)).y;
                else if (offset == 2)
                    res[i] = texture2D(input_s, vec2(inputTexCoordsW, inputTexCoordsH)).z;
                else
                    res[i] = texture2D(input_s, vec2(inputTexCoordsW, inputTexCoordsH)).w;
            }
            gl_FragColor = res;
        }`
                        }
                        bindUniforms(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.bindUniform4FV(this.inputShapesLoc, [...r.layout.shape.dims]),
                            n.bindUniform4FV(this.outputShapesLoc, [...i.layout.shape.dims]),
                            n.bindUniform2FV(this.inputFoldLoc, [r.layout.folding.w, r.layout.folding.h]),
                            n.bindUniform2FV(this.outputFoldLoc, [i.layout.folding.w, i.layout.folding.h]),
                            n.bindUniform2FV(this.outputFoldLoc, [i.layout.folding.w, i.layout.folding.h])
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            this.bindUniforms(e, t),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Reshape)
                }
                ,
                696: (e, t, r) => {
                    let i = r(8200)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.scriptScale(e, t)),
                            this.input1Loc = r.getUniformLocation(this.program, "input1_s"),
                            this.input2Loc = r.getUniformLocation(this.program, "input2_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = e[1].storage
                              , n = t[0].storage;
                            this.operator.inplace && (n = this.context.allocTexture(t[0].type, n.layout),
                            t[0].storage = n);
                            let o = this.context;
                            o.useProgram(this.program),
                            o.attachFramebuffer(n),
                            o.bindTexture(r, this.input1Loc, 0),
                            o.bindTexture(i, this.input2Loc, 1),
                            o.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        scriptScale(e, t) {
                            let r = this.operator
                              , n = this.context
                              , o = e[0].storage.layout
                              , a = e[1].storage.layout
                              , s = t[0].storage.layout;
                            return `${n.precision}
${o.scriptDimsToCoord("coord_input1")}
${a.scriptDimsToCoord("coord_input2")}
varying vec2 TexCoords;
uniform sampler2D input1_s, input2_s;
void main() {
    ${s.scriptCoordToDims("TexCoords", ["on", "oh", "ow", "oc4"])}
    vec4 in4 = texture2D(input1_s, coord_input1(on, oh, ow, oc4));
    vec4 scale_factor_4 = texture2D(input2_s, coord_input2(0, 0, 0, oc4));
    vec4 out4 = in4 * scale_factor_4;
    gl_FragColor = ${r.activation == i.Activation.ReLU ? "max(out4, 0.0)" : "out4"};
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Scale)
                }
                ,
                9699: (e, t, r) => {
                    let i = r(3193)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        getProgramKey() {
                            return ""
                        }
                        initLoc(e, t) {}
                        compileProgram(e, t) {}
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script()),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage;
                            this.operator.inplace && (i = this.context.allocTexture(t[0].type, i.layout),
                            t[0].storage = i);
                            let n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        script() {
                            let e = this.operator;
                            return `${this.context.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    vec4 gamma4 = vec4(float(${e.gamma}));
    vec4 alpha4 = vec4(float(${e.alpha}));
    vec4 out4 = step(0.0, in4) * gamma4 * in4 + (vec4(1.0) - step(0.0, in4)) * gamma4 * (alpha4 * exp(in4) - alpha4);
    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.SeLU)
                }
                ,
                8019: (e, t, r) => {
                    let i = r(4284)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            return "sescale"
                        }
                        initLoc(e, t) {
                            let r = this.context;
                            this.inputLoc = r.getUniformLocation(this.program, "input_s"),
                            this.scaleLoc = r.getUniformLocation(this.program, "scale_s"),
                            this.inputStridesLoc = r.getUniformLocation(this.program, "inputStrides"),
                            this.scaleStridesLoc = r.getUniformLocation(this.program, "scaleStrides"),
                            this.outputStridesLoc = r.getUniformLocation(this.program, "outputStrides"),
                            this.inputFoldLoc = r.getUniformLocation(this.program, "inputFold"),
                            this.scaleFoldLoc = r.getUniformLocation(this.program, "scaleFold"),
                            this.outputFoldLoc = r.getUniformLocation(this.program, "outputFold")
                        }
                        compileProgram(e, t) {
                            let r = this.script()
                              , i = this.context;
                            this.program = i.compile(r, this.getProgramKey())
                        }
                        bindUniform(e, t) {
                            let r = this.context
                              , i = e[0].storage
                              , n = e[1].storage
                              , o = t[0].storage;
                            if (r.bindTexture(i, this.inputLoc, 0),
                            r.bindTexture(n, this.scaleLoc, 1),
                            this.needUpadateBinding) {
                                let e = i.layout.getStrides()
                                  , t = o.layout.getStrides()
                                  , a = n.layout.getStrides()
                                  , s = [i.layout.folding.w, i.layout.folding.h]
                                  , u = [o.layout.folding.w, o.layout.folding.h]
                                  , l = [n.layout.folding.w, n.layout.folding.h];
                                r.bindUniform3FV(this.inputStridesLoc, e),
                                r.bindUniform3FV(this.outputStridesLoc, t),
                                r.bindUniform3FV(this.scaleStridesLoc, a),
                                r.bindUniform2FV(this.inputFoldLoc, s),
                                r.bindUniform2FV(this.outputFoldLoc, u),
                                r.bindUniform2FV(this.scaleFoldLoc, l),
                                this.needUpadateBinding = !1
                            }
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = e[1].storage
                              , n = t[0].storage
                              , o = this.context;
                            o.useProgram(this.program),
                            o.attachFramebuffer(n),
                            o.bindTexture(r, this.inputLoc, 0),
                            o.bindTexture(i, this.scaleLoc, 1),
                            this.bindUniform(e, t),
                            o.draw()
                        }
                        script() {
                            let e = this.operator;
                            return `${this.context.precision}
varying vec2 TexCoords;
uniform sampler2D input_s, scale_s;
uniform vec3 inputStrides;
uniform vec3 outputStrides;
uniform vec3 scaleStrides;
uniform vec2 inputFold;
uniform vec2 outputFold;
uniform vec2 scaleFold;

${n.TexCoordDimScript}
vec2 coord_input(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
}

vec2 coord_scale(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), scaleStrides, scaleFold);
}

vec2 coord_output(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
}
void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    vec4 in4 = texture2D(input_s, coord_input(on, oh, ow, oc4));
    vec4 scale4 = texture2D(scale_s, coord_scale(on, 1, 1, oc4));
    vec4 out4 = in4 * scale4;
    gl_FragColor = ${e.relu_term ? "max(out4, 0.0)" : "out4"};
}`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.SEScale)
                }
                ,
                5879: (e, t, r) => {
                    let i = r(5456)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        constructor() {
                            super(...arguments),
                            this.programs = [],
                            this.inputLoc = [],
                            this.beginLoc = [],
                            this.axisLoc = []
                        }
                        deleteProgram() {
                            let e = this.context;
                            this.programs.forEach(t => e.deleteProgram(t))
                        }
                        dispose() {
                            super.dispose(),
                            this.deleteProgram()
                        }
                        getProgramKey() {
                            return `slice_axis_${this.operator.axis}`
                        }
                        initLoc(e, t) {
                            let r = this.context;
                            this.inputLoc = this.programs.map(e => r.getUniformLocation(e, "input_s")),
                            this.beginLoc = this.programs.map(e => r.getUniformLocation(e, "begin")),
                            this.axisLoc = this.programs.map(e => r.getUniformLocation(e, "axis"))
                        }
                        init(e, t) {
                            this.initLoc(e, t),
                            this.preInitFlag = !1
                        }
                        preInit(e, t) {
                            this.initProgram(e, t),
                            this.preInitFlag = !0
                        }
                        initProgram(e, t) {
                            if (t.length > this.programs.length)
                                for (let e = 0; e < t.length - this.programs.length; e++)
                                    this.programs.push(this.getSingleProgram())
                        }
                        resize(e, t) {
                            t.length > this.programs.length && (this.initProgram(e, t),
                            this.initLoc(e, t)),
                            this.needUpadateBinding = !0
                        }
                        getSingleProgram() {
                            let e = this.context
                              , t = "slice";
                            return e.compileByFragShaderKey(t) || e.compile(this.script(), t)
                        }
                        compileProgram() {}
                        execute(e, t) {
                            let r = e[0].storage
                              , i = this.context;
                            for (let e = 0; e < t.length; e++) {
                                i.useProgram(this.programs[e]);
                                let n = t[e].storage;
                                i.attachFramebuffer(n),
                                i.bindTexture(r, this.inputLoc[e], 0),
                                i.draw()
                            }
                        }
                        script() {
                            return `${this.context.precision}
        varying vec2 TexCoords;
        uniform sampler2D input_s;
        uniform vec3 inputStrides;
        uniform vec3 outputStrides;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        uniform vec2 biasFold;
        uniform vec4 inputShapes;
        uniform vec4 outputShapes;
        uniform int begin;
        uniform int axis;
        ${n.TexCoordDimScript}
        vec2 coord_input(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
        }

        void main(){
            // if not last axis
            if (axis != 3) {
                vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
                int on = int(dims[0]);
                int oh = int(dims[1]);
                int ow = int(dims[2]);
                int oc4 = int(dims[3]);
                gl_FragColor = texture2D(input_s, coord_input(on, oh, ow, oc4));
                return;
            }
            vec4 res = vec4(0.);
            vec4 part0 = vec4(0.);
            vec4 part1 = vec4(0.);

            int numChannel = 4;
            int _x = int(TexCoords.s * float(outputFold[0]));
            int _y = int(TexCoords.t * float(outputFold[1]));
            int currentIdx = _y * int(outputShapes[3]) + _x * numChannel;

            gl_FragColor = texture2D(input_s, vec2(0.));

            vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
            int on = int(dims[0]);
            int oh = int(dims[1]);
            int ow = int(dims[2]);
            int oc4 = int(dims[3]);
            int oc = oc4 * 4;

            float begin_float = float(begin);
            int ih = oh ;
            int iw = ow ;
            int ic = oc4 * 4 + begin;
            int ic4 = int(floor(float(ic) / 4.0));
            int begin_div4 = int((float(ic)+ 3.0) /4.0);
            int begin_mod4 = ic - begin_div4*4;
            if(begin_mod4==0)
            {
                res = texture2D(input_s, coord_input(on, ih, iw, ic4));
            }
            else
            {
                part0 = texture2D(input_s, coord_input(on, ih, iw, ic4));
                part1 = texture2D(input_s, coord_input(on, ih, iw, ic4+1));
                if(begin_mod4==1)
                {
                    res.xyz = part0.yzw;
                    res.w = part1.x;
                }
                else if(begin_mod4==2)
                {
                    res.xy = part0.zw;
                    res.zw = part1.xy;
                }
                else if(begin_mod4==3)
                {
                    res.x = part0.w;
                    res.yzw = part1.xyz;
                }
            }
            gl_FragColor = res;
        }`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Slice)
                }
                ,
                6556: (e, t, r) => {
                    let i = r(8655)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        compileProgram() {
                            let e = this.context
                              , t = this.operator
                              , r = this.getProgramKey();
                            e.deleteProgram(this.program),
                            3 == t.axis ? this.program = e.compile(this.scriptChannel(), r) : 1 == t.axis ? this.program = e.compile(this.scriptHeight(), r) : 2 == t.axis ? this.program = e.compile(this.scriptWidth(), r) : this.program = e.compile(this.scriptChannel(), r)
                        }
                        getProgramKey() {
                            return `softmax_axis_${this.operator.axis}`
                        }
                        initLoc() {
                            let e = this.context;
                            this.inputLoc = e.getUniformLocation(this.program, "input_s"),
                            this.inputStridesLoc = e.getUniformLocation(this.program, "inputStrides"),
                            this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                            this.inputFoldLoc = e.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                            this.inputShapesLoc = e.getUniformLocation(this.program, "inputShapes")
                        }
                        bindUniform(e, t) {
                            let r = this.context
                              , i = e[0].storage
                              , n = t[0].storage;
                            if (r.bindTexture(i, this.inputLoc, 0),
                            this.needUpadateBinding) {
                                let e = i.layout.getStrides()
                                  , t = n.layout.getStrides()
                                  , o = [i.layout.folding.w, i.layout.folding.h]
                                  , a = [n.layout.folding.w, n.layout.folding.h];
                                r.bindUniform3FV(this.inputStridesLoc, e),
                                r.bindUniform3FV(this.outputStridesLoc, t),
                                r.bindUniform2FV(this.inputFoldLoc, o),
                                r.bindUniform2FV(this.outputFoldLoc, a),
                                r.bindUniform4FV(this.inputShapesLoc, [...i.layout.shape.dims]),
                                this.needUpadateBinding = !1
                            }
                        }
                        preInit(e, t) {
                            this.initProgram(e, t)
                        }
                        init(e, t) {
                            this.initLoc()
                        }
                        resize(e, t) {
                            this.initProgram(e, t),
                            this.initLoc()
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.useProgram(this.program),
                            i.attachFramebuffer(r),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        scriptChannel() {
                            return `${this.context.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
uniform vec3 inputStrides;
uniform vec3 outputStrides;
uniform vec2 inputFold;
uniform vec2 outputFold;
uniform vec4 inputShapes;
${n.TexCoordDimScript}
vec2 coord_input(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
}

void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int IC = int(inputShapes[3]);
    int IC4 = int(ceil(float(IC) / 4.0));
    int RC = IC - (IC4 - 1) * 4;
    vec4 last4 = texture2D(input_s, coord_input(on, oh, ow, IC4 - 1));
    // get max value
    vec4 max4 = vec4(-100000.0);
    for (int ic4 = 0; ic4 < 100000; ic4++) {
        if (ic4 >= IC4 - 1) {
            break;
        }
        max4 = max(max4, texture2D(input_s, coord_input(on, oh, ow, ic4)));
    }
    float max1 = max(max(max4.x, max4.y), max(max4.z, max4.w));
    if (RC == 1) {
        max1 = max(max1, last4.x);
    } else if (RC == 2) {
        max1 = max(max(max1, last4.x), last4.y);
    } else if (RC == 3) {
        max1 = max(max(max(max1, last4.x), last4.y), last4.z);
    } else {
        max1 = max(max(max(max(max1, last4.x), last4.y), last4.z), last4.w);
    }
    max4 = vec4(max1);

    // calc exp
    vec4 sum4 = vec4(0.0);
    for (int ic4 = 0; ic4 < 100000; ++ic4) {
        if (ic4 >= IC4 - 1) {
            break;
        }
        sum4 += exp(texture2D(input_s, coord_input(on, oh, ow, ic4)) - max1);
    }
    float sum1 = sum4.x + sum4.y + sum4.z + sum4.w;
    last4 = exp(last4 - max4);

    if (RC == 1) {
        sum1 += last4.x;
    } else if (RC == 2) {
        sum1 += last4.x + last4.y;
    } else if (RC == 3) {
        sum1 += last4.x + last4.y + last4.z;
    } else {
        sum1 += last4.x + last4.y + last4.z + last4.w;
    }
    sum4 = vec4(sum1);

    vec4 in4 = texture2D(input_s, coord_input(on, oh, ow, oc4));
    gl_FragColor = exp(in4 - max4) / sum4;
}
`
                        }
                        scriptHeight() {
                            return `${this.context.precision}
        varying vec2 TexCoords;
        uniform sampler2D input_s;
        uniform vec3 inputStrides;
        uniform vec3 outputStrides;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        uniform vec4 inputShapes;
        ${n.TexCoordDimScript}
        vec2 coord_input(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
        }

    void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int IH = int(inputShapes[1]);
    vec4 out4;
    // get the max value
    vec4 maxValue = vec4(-1000.0);

    for (int ih = 0; ih < 100000; ++ih) {
        if (ih >= IH) {
            break;
        }
        maxValue = max(maxValue, texture2D(input_s, coord_input(on, ih, ow, oc4)));
    }

    // calculate sum
    vec4 sum = vec4(0.0);
    for(int ih = 0; ih < 100000; ++ih)
    {
        if (ih >= IH) {
            break;
        }
        sum += exp(texture2D(input_s, coord_input(on, ih, ow, oc4)) - maxValue);
    }

    // div sum
    vec4 in4 = texture2D(input_s, coord_input(on, oh, ow, oc4));
    out4 = exp(in4 - maxValue) / sum;

    gl_FragColor = out4;
}
`
                        }
                        scriptWidth() {
                            return `${this.context.precision}
        varying vec2 TexCoords;
        uniform sampler2D input_s;
        uniform vec3 inputStrides;
        uniform vec3 outputStrides;
        uniform vec2 inputFold;
        uniform vec2 outputFold;
        uniform vec4 inputShapes;
        int MAX_ITER = 100000;
        ${n.TexCoordDimScript}
        vec2 coord_input(int n, int h, int w, int c4) {
            return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
        }

    void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int IW = int(inputShapes[2]);
    vec4 out4;
    // get the max value
    vec4 maxValue = vec4(-100000.0);
    for (int iw = 0; iw < 100000; ++iw) {
        if (iw >= IW) {
            break;
        }
        maxValue = max(maxValue, texture2D(input_s, coord_input(on, oh, iw, oc4)));
    }

    // calculate sum
    vec4 sum = vec4(0.0);
    for(int iw = 0; iw < 100000; ++iw)
    {
        if (iw >= IW) {
            break;
        }
        sum += exp(texture2D(input_s, coord_input(on, oh, iw, oc4)) - maxValue);
    }

    // div sum
    vec4 in4 = texture2D(input_s, coord_input(on, oh, ow, oc4));
    out4 = (exp(in4 - maxValue)) / sum;

    gl_FragColor = out4;
}
`
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.Softmax)
                }
                ,
                6239: (e, t, r) => {
                    let i = r(410)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = this.context
                              , i = this.operator;
                            r.deleteProgram(this.program),
                            e[0].shape.dims.slice(-1)[0] % 4 && 1 != i.blockSize ? this.program = r.compile(this.scriptSpace2DepthDisorderedForNHWC(e[0], t[0])) : this.program = r.compile(this.scriptSpace2DepthForNHWC(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        scriptSpace2DepthForNHWC(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.blockSize
                              , [,,,s] = e.shape.dims;
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${o.scriptCoordToDims("TexCoords", ["n", "oh", "ow", "oc4"])}
    int oc = oc4 * 4;
    int ic4 = mod(oc, ${s}) / 4 ;
    int id_block = oc / ${s};
    int bw = mod(id_block, ${a});
    int bh = id_block / ${a};
    int iw = ow * ${a} + bw;
    int ih = oh * ${a} + bh;

    gl_FragColor = texture2D(input_s, coord_input(n, ih, iw, ic4));
}`
                        }
                        scriptSpace2DepthDisorderedForNHWC(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = e.storage.layout
                              , o = t.storage.layout
                              , a = r.blockSize
                              , [,,,s] = e.shape.dims;
                            return `${i.precision}
${n.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${o.scriptCoordToDims("TexCoords", ["n", "oh", "ow", "oc4"])}
    int oc = oc4 * 4;
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; i < 4; ++i) {
        int ic4 = mod(oc + i, ${s}) / 4;
        int offset = mod(mod(oc + i, ${s}), 4);
        int id_block = (oc + i) / ${s};
        int bw = mod(id_block, ${a});
        int bh = id_block / ${a};
        int iw = ow * ${a} + bw;
        int ih = oh * ${a} + bh;
        if (offset == 0)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).x;
        else if (offset == 1)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).y;
        else if (offset == 2)
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).z;
        else
            out4[i] = texture2D(input_s, coord_input(n, ih, iw, ic4)).w;
    }

    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.SpaceToDepth)
                }
                ,
                9757: (e, t, r) => {
                    let i = r(9538)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script()),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage;
                            this.operator.inplace && (i = this.context.allocTexture(t[0].type, i.layout),
                            t[0].storage = i);
                            let n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw(),
                            this.operator.inplace && this.context.releaseTexture(r)
                        }
                        script() {
                            let e = this.operator
                              , t = this.context;
                            return console.log("relu precision is %s", t.precision),
                            `${t.precision}

varying vec2 TexCoords;
uniform sampler2D input_s;
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    vec4 out4 = in4;
    if (${e.type} == 1)
    {
        out4 = in4 * vec4(0.5);
    }
    gl_FragColor = out4;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Test)
                }
                ,
                3743: (e, t, r) => {
                    let i = r(2419)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            e[0].shape.dims.slice(-1)[0] % 4 ? this.program = r.compile(this.scriptTileDisordered(e[0], t[0])) : this.program = r.compile(this.scriptTile(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        scriptTile(e, t) {
                            let r = this.context
                              , i = e.storage.layout
                              , n = t.storage.layout
                              , o = "out_axis_";
                            return `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${n.scriptCoordToDims("TexCoords", Array(t.shape.dims.length).fill(o).map( (e, t) => e + t))}
    vec4 in4 = texture2D(input_s, coord_input(${[...e.shape.dims].map( (r, i) => i != e.shape.dims.length - 1 ? `mod(${o + i}, ${e.shape.dims[i]})` : `mod(${o + i}, ${t.shape.dims[i] / e.shape.dims[i]})`).join(",")}));
    gl_FragColor = in4;
}
`
                        }
                        scriptTileDisordered(e, t) {
                            let r = this.context
                              , i = e.storage.layout
                              , n = t.storage.layout
                              , o = "out_axis_";
                            return `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
int mod(int x, int y) {
    return x - x / y * y;
}
void main() {
    ${n.scriptCoordToDims("TexCoords", Array(t.shape.dims.length).fill(o).map( (e, t) => e + t))}
    vec4 out4 = vec4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; i < 4; ++i) {
        int last_axis_index = out_axis_${t.shape.dims.length - 1} * 4 + i;
        int offset = mod(mod(last_axis_index, ${e.shape.dims.slice(-1)[0]}), 4);
        vec4 in4 = texture2D(input_s, coord_input(${[...e.shape.dims].map( (t, r) => r != e.shape.dims.length - 1 ? `mod(${o + r}, ${e.shape.dims[r]})` : `mod(last_axis_index, ${e.shape.dims[r]}) / 4`).join(",")}));
        if (offset == 0) out4[i] = in4[0];
        else if (offset == 1) out4[i] = in4[1];
        else if (offset == 2) out4[i] = in4[2];
        else  out4[i] = in4[3];
    }
    gl_FragColor = out4;
}
`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Tile)
                }
                ,
                9438: (e, t, r) => {
                    let i = r(8313)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = e[0].storage.layout
                              , i = t[0].storage.layout;
                            if (r.shape.elements !== i.shape.elements)
                                throw Error("number of element must be the same for tranpose");
                            let n = this.context;
                            n.deleteProgram(this.program),
                            this.program = n.compile(this.reindexScript(e[0], t[0])),
                            this.inputLoc = n.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        genInputIndexSubScript(e, t) {
                            let r = "int in_index_4 = ";
                            for (let i = 0; i < e - 1; ++i)
                                r += `out_axis_${i} * ${t[i]} + `;
                            return r + `out_axis_${e - 1} * ${t[e - 1]} * 4;
`
                        }
                        genInputAxesSubScript(e, t) {
                            let r = "";
                            for (let i = 0; i < e - 1; ++i)
                                r += `int in_axis_${i} = in_index / ${t[i]};
in_index -= in_axis_${i} * ${t[i]};
`;
                            return r + `int in_axis_${e - 1} = in_index / 4;
int offset = in_index - in_axis_${e - 1} * 4;
`
                        }
                        reindexScript(e, t) {
                            let r = this.context
                              , i = e.storage.layout
                              , n = t.storage.layout
                              , o = this.operator.dims
                              , a = e.shape.dims.length
                              , s = t.shape.dims.length
                              , u = "in_axis_"
                              , l = Array(a).fill(1)
                              , c = Array(s).fill(1);
                            for (let t = a - 2; t >= 0; --t)
                                l[t] = l[t + 1] * e.shape.dims[t + 1];
                            for (let e = 0; e < s; ++e)
                                c[e] = l[o[e]];
                            return `${r.precision}
${i.scriptDimsToCoord("coord_input")}
varying vec2 TexCoords;
uniform sampler2D input_s;
void main(){
    ${n.scriptCoordToDims("TexCoords", Array(a).fill("out_axis_").map( (e, t) => e + t))}
    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);
    ${this.genInputIndexSubScript(s, c)}
    for (int i = 0; i < 4; i++) {
        int in_index = in_index_4 + i * ${c[s - 1]};
        ${this.genInputAxesSubScript(a, l)}
        if (offset == 0) {
            res[i] = texture2D(input_s, coord_input(${[...e.shape.dims].map( (e, t) => u + t).join(",")})).x;
        }
        else if (offset == 1) {
            res[i] = texture2D(input_s, coord_input(${[...e.shape.dims].map( (e, t) => u + t).join(",")})).y;
        }
        else if (offset == 2) {
            res[i] = texture2D(input_s, coord_input(${[...e.shape.dims].map( (e, t) => u + t).join(",")})).z;
        }
        else {
            res[i] = texture2D(input_s, coord_input(${[...e.shape.dims].map( (e, t) => u + t).join(",")})).w;
        }
    }
    gl_FragColor = res;
}`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Transpose)
                }
                ,
                5579: (e, t, r) => {
                    let i = r(6650)
                      , n = r(9998)
                      , o = r(2426);
                    class a extends n.WebGLKernel {
                        initLoc(e, t) {
                            throw Error("Method not implemented.")
                        }
                        compileProgram(e, t) {
                            throw Error("Method not implemented.")
                        }
                        getProgramKey() {
                            throw Error("Method not implemented.")
                        }
                        resize(e, t) {
                            let r = this.context;
                            r.deleteProgram(this.program),
                            this.program = r.compile(this.script(e[0], t[0])),
                            this.inputLoc = r.getUniformLocation(this.program, "input_s")
                        }
                        execute(e, t) {
                            let r = e[0].storage
                              , i = t[0].storage
                              , n = this.context;
                            n.useProgram(this.program),
                            n.attachFramebuffer(i),
                            n.bindTexture(r, this.inputLoc, 0),
                            n.draw()
                        }
                        compute(e, t) {
                            switch (e) {
                            case i.UnaryType.Tanh:
                                return `(exp(${t}) - exp(-${t})) / (exp(${t}) + exp(-${t}))`;
                            case i.UnaryType.Exp:
                                return `exp(${t})`;
                            case i.UnaryType.Sigmoid:
                                return `1.0 / (1.0 + exp(-${t}))`;
                            case i.UnaryType.Erf:
                                return `erf(${t})`;
                            case i.UnaryType.HardSigmoid:
                                return `hard_sigmoid(${t})`;
                            case i.UnaryType.ReluHardSigmoid:
                                return `max(vec4(0.0), min(${t} + 4.0, 8.0)) / 8.0`;
                            case i.UnaryType.HardSwish:
                                return `hard_swish(${t})`;
                            case i.UnaryType.ReluHardSwish:
                                return `${t} * max(vec4(0.0), min(${t} + 4.0, 8.0)) / 8.0`;
                            case i.UnaryType.Abs:
                                return `abs(${t})`;
                            case i.UnaryType.Ceil:
                                return `ceil(${t})`;
                            case i.UnaryType.Floor:
                                return `floor(${t})`;
                            case i.UnaryType.Log:
                                return `log(${t})`;
                            case i.UnaryType.Neg:
                                return `vec4(-1.0) * ${t}`;
                            case i.UnaryType.Sqrt:
                                return `sqrt(${t})`;
                            case i.UnaryType.Softplus:
                                return `log(exp(${t}) + vec4(1.0))`;
                            case i.UnaryType.Softsign:
                                return `${t} / (vec4(1.0) + abs(${t}))`;
                            default:
                                throw Error("Unary op not supported: " + e)
                            }
                        }
                        genSubScriptByType(e) {
                            switch (e) {
                            case i.UnaryType.Erf:
                                return "const float M_PI = 3.1415926535;\nconst float a = 8.0 * (M_PI - 3.0) / (3.0 * M_PI * (4.0 - M_PI));\nvec4 erf_guts(vec4 x) {\n    vec4 x2 = x * x;\n    return exp(-x2 * (vec4(4.0) / vec4(M_PI) + vec4(a) * x2) / (vec4(1.0) + vec4(a) * x2));\n}\nvec4 erf(vec4 x) {\n    vec4 cond = step(vec4(0.0), x);\n    vec4 sign = vec4(2.0) * cond - vec4(1.0);\n    return sign * sqrt(vec4(1.0) - erf_guts(x));\n}";
                            case i.UnaryType.HardSigmoid:
                                return "\nvec4 hard_sigmoid(vec4 x) {\n    vec4 cond1 = step(x, vec4(-3.0));\n    vec4 cond2 = step(vec4(3.0), x);\n    vec4 one = vec4(1.0);\n    vec4 six = vec4(6.0);\n    vec4 half_one = vec4(0.5);\n    return (one - cond1) * (one - cond2) * x / six + half_one + cond2;\n}";
                            case i.UnaryType.HardSwish:
                                return "\nvec4 hard_swish(vec4 x) {\n    vec4 cond1 = step(x, vec4(-3.0));\n    vec4 cond2 = step(vec4(3.0), x);\n    vec4 one = vec4(1.0);\n    vec4 three = vec4(3.0);\n    vec4 six = vec4(6.0);\n    return (one - cond1) * (one - cond2) * x * (x + three) / six + cond2 * x;\n}";
                            default:
                                return ""
                            }
                        }
                        script(e, t) {
                            let r = this.operator
                              , i = this.context
                              , n = r.type;
                            return `${i.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
${this.genSubScriptByType(n)}
void main() {
    vec4 in4 = texture2D(input_s, TexCoords);
    vec4 out4 = ${this.compute(n, "in4")};
    gl_FragColor = out4;
}
`
                        }
                    }
                    o.WebGLOps.register( (e, t) => new a(e,t), i.Unary)
                }
                ,
                3571: (e, t, r) => {
                    let i = r(642)
                      , n = r(4633)
                      , o = r(9998)
                      , a = r(2426);
                    class s extends o.WebGLKernel {
                        getProgramKey() {
                            let e = this.operator;
                            return `upsampling_scale_${e.scale}_mode_${e.mode}_half_pixel_${e.halfPixel}`
                        }
                        compileProgram() {
                            let e = this.context;
                            e.deleteProgram(this.program),
                            this.program = e.compile(this.script(), this.getProgramKey())
                        }
                        initLoc() {
                            let e = this.context
                              , t = this.operator;
                            this.inputLoc = e.getUniformLocation(this.program, "input_s"),
                            this.inputStridesLoc = e.getUniformLocation(this.program, "inputStrides"),
                            this.outputStridesLoc = e.getUniformLocation(this.program, "outputStrides"),
                            this.inputFoldLoc = e.getUniformLocation(this.program, "inputFold"),
                            this.outputFoldLoc = e.getUniformLocation(this.program, "outputFold"),
                            t.mode != i.UpSamplingMode.Linear && t.mode != i.UpSamplingMode.Bilinear || (this.inputShapesLoc = e.getUniformLocation(this.program, "inputShapes"))
                        }
                        bindUniform(e, t) {
                            let r = e[0].storage
                              , n = t[0].storage
                              , o = this.context
                              , a = this.operator;
                            o.bindTexture(r, this.inputLoc, 0),
                            this.needUpadateBinding && (a.mode != i.UpSamplingMode.Linear && a.mode != i.UpSamplingMode.Bilinear || o.bindUniform4FV(this.inputShapesLoc, [...r.layout.shape.dims]),
                            o.bindUniform3FV(this.inputStridesLoc, r.layout.getStrides()),
                            o.bindUniform3FV(this.outputStridesLoc, n.layout.getStrides()),
                            o.bindUniform2FV(this.inputFoldLoc, [r.layout.folding.w, r.layout.folding.h]),
                            o.bindUniform2FV(this.outputFoldLoc, [n.layout.folding.w, n.layout.folding.h]),
                            this.needUpadateBinding = !1)
                        }
                        isPreInit() {
                            return !!this.program && !this.inputLoc
                        }
                        preInit(e, t) {
                            this.initProgram(e, t)
                        }
                        init(e, t) {
                            this.initLoc()
                        }
                        resize(e, t) {
                            this.initProgram(e, t),
                            this.initLoc()
                        }
                        execute(e, t) {
                            let r = t[0].storage
                              , i = this.context;
                            i.useProgram(this.program),
                            i.attachFramebuffer(r),
                            this.bindUniform(e, t),
                            i.draw()
                        }
                        script() {
                            let e = this.operator
                              , t = this.context
                              , r = e.mode
                              , o = 1 / e.scale
                              , a = 1 / e.scale;
                            if (r == i.UpSamplingMode.Bilinear)
                                return `${t.precision}
varying vec2 TexCoords;
uniform sampler2D input_s;
uniform vec3 inputStrides;
uniform vec3 outputStrides;
uniform vec2 inputFold;
uniform vec2 outputFold;
uniform vec4 inputShapes;

${n.TexCoordDimScript}
vec2 coord_input(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
}
vec2 coord_output(int n, int h, int w, int c4) {
    return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
}

void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    int oc = oc4 * 4;
    int IH = int(inputShapes[1]);
    int IW = int(inputShapes[2]);
    float fh = min(max(0.0, (float(oh) + 0.5) * float(${o}) - 0.5), float(IH - 1));
    int sh = int(floor(fh));
    fh -= float(sh);

    float fw = min(max(0.0, (float(ow) + 0.5) * float(${a}) - 0.5), float(IW - 1));
    int sw = int(floor(fw));
    fw -= float(sw);

    float p1 = (1.0 - fw) * (1.0 - fh);
    float p2 = (1.0 - fw) * fh;
    float p3 = fw * (1.0 - fh);
    float p4 = fw * fh;

    vec4 b1 = texture2D(input_s, coord_input(on, sh, sw, oc4));
    vec4 b2 = texture2D(input_s, coord_input(on, sh + 1, sw, oc4));
    vec4 b3 = texture2D(input_s, coord_input(on, sh, sw + 1, oc4));
    vec4 b4 = texture2D(input_s, coord_input(on, sh + 1, sw + 1, oc4));
    vec4 out4 = b1 * p1 + b2 * p2 + b3 * p3 + b4 * p4;
    gl_FragColor = out4;
}
`;
                            if (r == i.UpSamplingMode.Linear)
                                return `${t.precision}
            varying vec2 TexCoords;
            uniform sampler2D input_s;
            uniform vec3 inputStrides;
            uniform vec3 outputStrides;
            uniform vec2 inputFold;
            uniform vec2 outputFold;
            uniform vec4 inputShapes;

            ${n.TexCoordDimScript}
            vec2 coord_input(int n, int h, int w, int c4) {
                return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
            }
            vec2 coord_output(int n, int h, int w, int c4) {
                return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
            }
void main() {
    int IH = int(inputShapes[1]);
    int IW = int(inputShapes[2]);
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    float fh = (float(oh) + 0.5) * float(${o}) - 0.5;
    int sh = int(floor(fh));
    fh -= float(sh);

    float fw = (float(ow) + 0.5) * float(${a}) - 0.5;
    int sw = int(floor(fw));
    fw -= float(sw);

    float p1 = (1.0 - fw) * (1.0 - fh);
    float p2 = (1.0 - fw) * fh;
    float p3 = fw * (1.0 - fh);
    float p4 = fw * fh;

    vec4 b1 = (sh < 0 || sw < 0) ? vec4(0.0) : texture2D(input_s, coord_input(on, sh, sw, oc4));
    vec4 b2 = (sh > IH - 2 || sw < 0) ? vec4(0.0) : texture2D(input_s, coord_input(on, sh + 1, sw, oc4));
    vec4 b3 = (sh < 0 || sw > IW - 2) ? vec4(0.0) : texture2D(input_s, coord_input(on, sh, sw + 1, oc4));
    vec4 b4 = (sh > IH - 2 || sw > IW - 2) ? vec4(0.0) : texture2D(input_s, coord_input(on, sh + 1, sw + 1, oc4));
    vec4 out4 = b1 * p1 + b2 * p2 + b3 * p3 + b4 * p4;
    gl_FragColor = out4;
}
`;
                            if (r == i.UpSamplingMode.Nearest)
                                return `${t.precision}
            varying vec2 TexCoords;
            uniform sampler2D input_s;
            uniform vec3 inputStrides;
            uniform vec3 outputStrides;
            uniform vec2 inputFold;
            uniform vec2 outputFold;
            // uniform vec4 inputShapes;

            ${n.TexCoordDimScript}
            vec2 coord_input(int n, int h, int w, int c4) {
                return dim4ToTexCoord(vec4(n, h, w, c4), inputStrides, inputFold);
            }
            vec2 coord_output(int n, int h, int w, int c4) {
                return dim4ToTexCoord(vec4(n, h, w, c4), outputStrides, outputFold);
            }
void main() {
    vec4 dims = texCoordToDim4(TexCoords, outputStrides, outputFold);
    int on = int(dims[0]);
    int oh = int(dims[1]);
    int ow = int(dims[2]);
    int oc4 = int(dims[3]);
    float fh = floor(${e.halfPixel} ? (float(oh) + 0.5) * float(${o}) - 0.5 : float(oh) * float(${o}));
    float fw = floor(${e.halfPixel} ? (float(ow) + 0.5) * float(${a}) - 0.5 : float(ow) * float(${a}));
    gl_FragColor = texture2D(input_s, coord_input(on, int(fh), int(fw), oc4));
}
`;
                            throw Error("Not Supported Interpolation Method " + r)
                        }
                    }
                    a.WebGLOps.register( (e, t) => new s(e,t), i.UpSampling)
                }
                ,
                8137: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGLLayout = t.upDiv = void 0;
                    let i = r(5249)
                      , n = r(2810);
                    function o(e, t) {
                        return Math.floor((e + t - 1) / t)
                    }
                    t.upDiv = o;
                    class a {
                        constructor(e, t, r, i) {
                            this.shape = e,
                            this.folding = t,
                            this.wcomp = r,
                            this.hcomp = i
                        }
                        getStrides() {
                            let e = [...this.shape.dims]
                              , t = e.length;
                            if (e[t - 1] = o(e[t - 1], 4),
                            t <= 1)
                                return [];
                            let r = Array(t - 1)
                              , i = 1;
                            for (let n = t - 2; n >= 0; n--)
                                i *= e[n + 1],
                                r[n] = i;
                            return r
                        }
                        static foldShape(e, t) {
                            let r = [...e.dims]
                              , i = r.length;
                            if (0 == i)
                                return [[1, 1], [[1], [1]]];
                            let a = r.map( (e, t) => t == r.length - 1 ? o(e, 4) : e)
                              , s = a.reduce( (e, t) => e * t);
                            if (s > t * t)
                                return n.trace.error( () => "shape size > maximum texture size"),
                                [[1, 1], [[1], [1]]];
                            if (a.some(e => e > t))
                                return [[t, o(s, t)], void 0];
                            let u = 1
                              , l = 1
                              , c = 0
                              , p = []
                              , d = [];
                            for (; c < i - 1; ) {
                                let e = l * a[c];
                                if (e > t)
                                    break;
                                d.push(a[c]),
                                l = e,
                                c++
                            }
                            for (; c < i; ) {
                                let e = u * a[c];
                                if (e > t)
                                    break;
                                p.push(a[c]),
                                u = e,
                                c++
                            }
                            return c == i ? [[u, l], [p, d]] : [[t, o(s, t)], void 0]
                        }
                        unfoldXY(e, t) {
                            if (this.wcomp && this.hcomp) {
                                let e = (e, t) => t.map( (r, i) => {
                                    let n = t.slice(i + 1).reduce( (e, t) => e * t, 1);
                                    return `${e[i]} * ${n}`
                                }
                                )
                                  , r = e(t, this.hcomp)
                                  , i = e(t.slice(this.hcomp.length), this.wcomp);
                                return `int _y = ${r.length > 0 ? r.join(" + ") : "0"};
	int _x = ${i.length > 0 ? i.join(" + ") : "0"};`
                            }
                            {
                                let e = [...this.shape.dims]
                                  , r = e.map( (t, r) => r == e.length - 1 ? o(t, 4) : t);
                                return `int _index = ${t.map( (e, t) => `${e} * ${r.slice(t + 1).reduce( (e, t) => e * t, 1)}`).join(" + ")};
	 int _y = _index / ${this.folding.w};
	 int _x = _index - _y * ${this.folding.w};`
                            }
                        }
                        scriptDimsToCoord(e, t) {
                            n.trace.assert( () => !t || t.length == this.shape.dims.length),
                            t = t || [...this.shape.dims].map( (e, t) => `n${t}`);
                            let r = this.unfoldXY(e, t);
                            return `vec2 ${e}(${t.map(e => "int " + e).join(",")}) {
    ${r}
    return (vec2(_x, _y) + vec2(0.5, 0.5)) / vec2(${this.folding.w}, ${this.folding.h});
}`
                        }
                        scriptCoordToDims(e, t) {
                            n.trace.assert( () => t.length == this.shape.dims.length);
                            let r = (e, t) => 1 == t ? e : e + " * " + t
                              , i = (e, t) => 1 == t ? e : e + " / " + t
                              , a = `int _y = int(${e}.t * float(${this.folding.h}));`
                              , s = `int _x = int(${e}.s * float(${this.folding.w}));`;
                            if (this.wcomp && this.hcomp) {
                                let e = (e, t, n) => t.map( (o, a) => {
                                    let s = t.slice(a + 1).reduce( (e, t) => e * t, 1)
                                      , u = a < t.length - 1 ? `_${n} = _${n} - ${r(e[a], s)};` : "";
                                    return `${e[a]} = ${i(`_${n}`, s)}; ${u}`
                                }
                                )
                                  , n = e(t, this.hcomp, "y").join("\n	")
                                  , o = e(t.slice(this.hcomp.length), this.wcomp, "x").join("\n	");
                                return `int ${t.join(", ")}; { 
	${a}
	${s}
	${n}
	${o}
}`
                            }
                            {
                                let e = [...this.shape.dims]
                                  , n = e.map( (t, r) => r == e.length - 1 ? o(t, 4) : t)
                                  , u = `int _index = _y * ${this.folding.w} + _x;`
                                  , l = t.map( (e, o) => {
                                    let a = n.slice(o + 1).reduce( (e, t) => e * t, 1)
                                      , s = o < t.length - 1 ? `_index = _index - ${r(e, a)};` : "";
                                    return `${e} = ${i("_index", a)}; ${s}`
                                }
                                ).join("\n	");
                                return `int ${t.join(", ")}; { 
	${a}
	${s}
	${u}
	${l}
}`
                            }
                        }
                        static folded(e) {
                            let t = e instanceof i.Shape ? e : new i.Shape(i.DataFormat.NHWC,e)
                              , r = 0
                              , n = 0
                              , o = 0
                              , s = 0;
                            t.format == i.DataFormat.NHWC ? [r,n,o,s] = t.dims : [r,s,n,o] = t.dims;
                            let u = ~~((s + 3) / 4);
                            return new a(t,{
                                w: o * u,
                                h: r * n
                            },[o, u],[r, n])
                        }
                        static fold(e, t) {
                            let r = e instanceof i.Shape ? e : new i.Shape(i.DataFormat.NHWC,e)
                              , [n,o] = this.foldShape(r, t.maxTextureSize)
                              , s = o ? o[0] : void 0
                              , u = o ? o[1] : void 0;
                            return new a(r,{
                                w: n[0],
                                h: n[1]
                            },s,u)
                        }
                        reorderAsData(e) {
                            let t = [...this.shape.dims]
                              , r = t.slice(0, -1).reduce( (e, t) => e * t, 1)
                              , i = t[t.length - 1]
                              , n = 4 * o(i, 4);
                            if (i == n)
                                return e;
                            this.stagedDataArray && this.stagedDataArray.length == r * i && typeof e == typeof this.stagedDataArray || (this.stagedDataArray = new e.constructor(r * i));
                            for (let t = 0; t < r; t++)
                                this.stagedDataArray.set(e.subarray(t * n, t * n + i), t * i);
                            return this.stagedDataArray
                        }
                        reorderAsTexture(e) {
                            let t = [...this.shape.dims]
                              , r = t.slice(0, -1).reduce( (e, t) => e * t, 1)
                              , i = t[t.length - 1]
                              , n = 4 * o(i, 4);
                            if (i == n)
                                return e;
                            this.stagedTextureArray && this.stagedTextureArray.length == r * i && typeof e == typeof this.stagedTextureArray || (this.stagedTextureArray = new e.constructor(this.folding.w * this.folding.h * 4));
                            for (let t = 0; t < r; t++)
                                this.stagedTextureArray.set(e.subarray(t * i, t * i + i), t * n);
                            return this.stagedTextureArray
                        }
                    }
                    t.WebGLLayout = a
                }
                ,
                2638: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGLPrecision = void 0,
                    function(e) {
                        e[e.High = 0] = "High",
                        e[e.Medium = 1] = "Medium",
                        e[e.Low = 2] = "Low"
                    }(t.WebGLPrecision || (t.WebGLPrecision = {}))
                }
                ,
                4633: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.TexCoordDimScript = t.texCoordToDimScript = t.DimToTexCoordScript = void 0,
                    t.DimToTexCoordScript = () => "\n    vec2 indexToTexCoord(int index, vec2 fold) {\n        int y = index / int(fold.x);\n        int x = index - y * int(fold.x);\n        return (vec2(x, y) + vec2(0.5, 0.5)) / vec2(fold.x, fold.y);\n    }\n    vec2 dim1ToTexCoord(int n1, vec2 fold) {\n        return indexToTexCoord(n1, fold);\n    }\n    vec2 dim2ToTexCoord(vec2 dims, int stride, vec2 fold) {\n        int index = int(dims.x) * stride + int(dims.y);\n        return indexToTexCoord(index, fold);\n    }\n    vec2 dim3ToTexCoord(vec3 dims, vec2 strides, vec2 fold) {\n        int index = int(dims.x * strides.x + dims.y * strides.y + dims.z);\n        return indexToTexCoord(index, fold);\n    }\n    vec2 dim4ToTexCoord(vec4 dims, vec3 strides, vec2 fold) {\n        int index = int(dims.x * strides.x + dims.y * strides.y + dims.z * strides.z + dims.w);\n        return indexToTexCoord(index, fold);\n    }\n    ",
                    t.texCoordToDimScript = () => "\n    int texCoordToIndex(vec2 coord, vec2 fold) {\n        int x = int(coord.x * fold.x);\n        int y = int(coord.y * fold.y);\n        int index = y * int(fold.x) + x;\n        return index;\n    }\n    int texCoordToDim1(vec2 coord, vec2 fold) {\n        int index = texCoordToIndex(coord, fold);\n        return index;\n    }\n\n    vec2 texCoordToDim2(vec2 coord, int stride, vec2 fold) {\n        int index = texCoordToIndex(coord, fold);\n        int n1 = int(index / stride);\n        int n2 = index - n1 * stride;\n        return vec2(n1, n2);\n    }\n\n    vec3 texCoordToDim3(vec2 coord, vec2 strides, vec2 fold) {\n        int index = texCoordToIndex(coord, fold);\n        int n1 = index / int(strides.x);\n        index -= n1 * int(strides.x);\n        int n2 = index / int(strides.y);\n        int n3 = index - n2 * int(strides.y);\n        return vec3(n1, n2, n3);\n    }\n\n    vec4 texCoordToDim4(vec2 coord, vec3 strides, vec2 fold) {\n        int index = texCoordToIndex(coord, fold);\n        int n1 =  index / int(strides.x);\n        index -= n1 * int(strides.x);\n        int n2 = index / int(strides.y);\n        index -= n2 * int(strides.y);\n        int n3 = index / int(strides.z);\n        int n4 = index - n3 * int(strides.z);\n        return vec4(n1, n2, n3, n4);\n    }\n\n    ",
                    t.TexCoordDimScript = `
    ${t.DimToTexCoordScript()}
    ${t.texCoordToDimScript()}
`
                }
                ,
                1108: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.indexValueOfVec4 = void 0,
                    t.indexValueOfVec4 = function(e, t, r) {
                        let i = r ? `${r} =` : "return";
                        return `if (${t} == 0) {
    ${i} ${e}.x;
} else if (${t} == 1) {
    ${i} ${e}.y;
} else if (${t} == 2) {
    ${i} ${e}.z;
} else {
    ${i} ${e}.w;
}`
                    }
                }
                ,
                6480: function(e, t, r) {
                    var i = this && this.__createBinding || (Object.create ? function(e, t, r, i) {
                        void 0 === i && (i = r),
                        Object.defineProperty(e, i, {
                            enumerable: !0,
                            get: function() {
                                return t[r]
                            }
                        })
                    }
                    : function(e, t, r, i) {
                        void 0 === i && (i = r),
                        e[i] = t[r]
                    }
                    )
                      , n = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                        Object.defineProperty(e, "default", {
                            enumerable: !0,
                            value: t
                        })
                    }
                    : function(e, t) {
                        e.default = t
                    }
                    )
                      , o = this && this.__importStar || function(e) {
                        if (e && e.__esModule)
                            return e;
                        var t = {};
                        if (null != e)
                            for (var r in e)
                                "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && i(t, e, r);
                        return n(t, e),
                        t
                    }
                    ;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGL1Fp16Context = t.WebGL1Fp32Context = void 0;
                    let a = r(5249)
                      , s = r(6825)
                      , u = r(8137)
                      , l = o(r(1108));
                    class c extends s.WebGLContext {
                        dataTexType() {
                            return WebGLRenderingContext.FLOAT
                        }
                        nullTexType() {
                            return WebGLRenderingContext.FLOAT
                        }
                        internalTexFormat() {
                            return WebGLRenderingContext.RGBA
                        }
                    }
                    t.WebGL1Fp32Context = c;
                    class p extends s.WebGLContext {
                        constructor(e, t, r, i, n) {
                            super(e, t, r, i),
                            this.halfTexType = n.HALF_FLOAT_OES
                        }
                        dataTexType() {
                            return WebGLRenderingContext.FLOAT
                        }
                        nullTexType() {
                            return this.halfTexType
                        }
                        internalTexFormat() {
                            return WebGLRenderingContext.RGBA
                        }
                        dispose() {
                            this.releaseTexture(this.downloadTexture),
                            this.deleteProgram(this.downloadProgram),
                            delete this.downloadLocation,
                            super.dispose()
                        }
                        castFp32ToU8(e) {
                            return `precision highp float;
precision highp int;
precision highp sampler2D;

varying vec2 TexCoords;
uniform sampler2D input_s;

bool isNaN(float val) {
    return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
}
highp vec4 castToU8(highp float f) {
    if (isNaN(f)) return vec4(255, 255, 255, 255);

    highp float F = abs(f);
    highp float sign = step(0.0, -f);
    highp float exponent = floor(log2(F));
    highp float mantissa = (exp2(-exponent) * F);
    exponent = floor(log2(F) + 127.0) + floor(log2(mantissa));

    highp vec4 rgba;
    rgba[3] = 128.0 * sign + floor(exponent * 0.5);
    rgba[2] = 128.0 * mod(exponent, 2.0) + mod(floor(mantissa * 128.0), 128.0);
    rgba[1] = floor(mod(floor(mantissa * 32768.0), 256.0));
    rgba[0] = floor(8388608.0 * mod(mantissa, 0.000030517578125));
    return rgba / 255.0;
}
void main() {
    int oy = int(TexCoords.t * float(${this.downloadTexture.height}));
    int ox = int(TexCoords.s * float(${this.downloadTexture.width}));
    int uIndex = oy * ${this.downloadTexture.width} + ox;
    int fIndex = uIndex / 4;
    int mod = uIndex - fIndex * 4;
    int iy = fIndex / ${e.width};
    int ix = fIndex - iy * ${e.width};

    vec2 icoords = (vec2(ivec2(ix, iy)) + vec2(0.5, 0.5)) / vec2(${e.width}, ${e.height});
    vec4 v4 = texture2D(input_s, icoords);
    float value;
    ${l.indexValueOfVec4("v4", "mod", "value")}
    gl_FragColor = castToU8(value);
}`
                        }
                        readTexture(e) {
                            if (!e.layout.shape.equals(this.downloadSourceShape) || !this.downloadLocation) {
                                let t = u.WebGLLayout.fold([e.width * e.height * 4, 4], this);
                                this.releaseTexture(this.downloadTexture),
                                this.downloadTexture = this.allocUint8Texture(null, t),
                                this.deleteProgram(this.downloadProgram),
                                this.downloadProgram = this.compile(this.castFp32ToU8(e)),
                                this.downloadLocation = this.getUniformLocation(this.downloadProgram, "input_s")
                            }
                            this.useProgram(this.downloadProgram),
                            this.attachFramebuffer(this.downloadTexture),
                            this.bindTexture(e, this.downloadLocation, 0),
                            this.draw();
                            let t = new Uint8Array(this.downloadTexture.width * this.downloadTexture.height * 4)
                              , r = this.gl;
                            r.readPixels(0, 0, this.downloadTexture.width, this.downloadTexture.height, r.RGBA, r.UNSIGNED_BYTE, t);
                            let i = new Float32Array(t.buffer,0,e.width * e.height * 4);
                            switch (e.type) {
                            case a.DataType.Float32:
                                return i;
                            case a.DataType.Int8:
                                return new Int8Array(i);
                            case a.DataType.Uint8:
                                return new Uint8Array(i);
                            default:
                                throw Error(`[webgl] invalid data type ${e.type} for reading.`)
                            }
                        }
                    }
                    t.WebGL1Fp16Context = p
                },
                4329: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGL2Fp16Context = t.WebGL2Fp32Context = void 0;
                    let i = r(6825);
                    class n extends i.WebGLContext {
                        dataTexType() {
                            return WebGL2RenderingContext.FLOAT
                        }
                        nullTexType() {
                            return WebGL2RenderingContext.FLOAT
                        }
                        internalTexFormat() {
                            return WebGL2RenderingContext.RGBA32F
                        }
                    }
                    t.WebGL2Fp32Context = n;
                    class o extends i.WebGLContext {
                        dataTexType() {
                            return WebGL2RenderingContext.FLOAT
                        }
                        nullTexType() {
                            return WebGL2RenderingContext.FLOAT
                        }
                        internalTexFormat() {
                            return WebGL2RenderingContext.RGBA16F
                        }
                    }
                    t.WebGL2Fp16Context = o
                }
                ,
                4014: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUContext = void 0;
                    let i = r(7693)
                      , n = r(2810)
                      , o = r(6484)
                      , a = r(8960)
                      , s = r(2332);
                    class u {
                        constructor(e) {
                            this.gpuDevice = e,
                            this.timers = [],
                            this.bufferMemory = [],
                            this.commandEncoder = null,
                            this.computePassEncoder = null,
                            this.commandBuffer = null,
                            this.gpuQueue = this.gpuDevice.queue,
                            this.supportTimeQuery = e.features.has("timestamp-query"),
                            console.log("support time query", this.supportTimeQuery),
                            this.supportTimeQuery && (this.querySet = e.createQuerySet({
                                type: "timestamp",
                                count: 2
                            }))
                        }
                        alloc(e) {
                            n.trace.assert( () => !e.storage || e.storage instanceof s.WebGPUStorage && e.storage.context == this),
                            e.storage = this.allocWebGPUStorage(e.type ? e.type : i.DataType.Float32, e.shape)
                        }
                        releaseStorage(e) {
                            e && e.buffer && e.buffer.destroy()
                        }
                        releaseBuffer(e) {
                            e && e.destroy()
                        }
                        allocBuffer(e, t, r=!1) {
                            let i = {
                                buffer: this.gpuDevice.createBuffer({
                                    size: e,
                                    usage: t,
                                    mappedAtCreation: r
                                }),
                                id: this.bufferMemory.length++
                            };
                            return this.bufferMemory.push(i),
                            i
                        }
                        printAcvtiveBufferMemory() {
                            console.log(this.bufferMemory)
                        }
                        async waitCommanBufferComplete() {
                            this.commandBuffer && await this.commandBuffer
                        }
                        async startTimeProfile() {
                            this.timers = []
                        }
                        makeUniform(e) {
                            let t = 0
                              , r = 0
                              , n = []
                              , o = 1;
                            e.forEach(e => {
                                let i;
                                switch (0 === e.data.length && (e.data = [1]),
                                e.data.length) {
                                case 1:
                                    i = 4;
                                    break;
                                case 2:
                                    i = 8;
                                    break;
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                    i = 16;
                                    break;
                                default:
                                    throw TypeError(`Unsupported ${e.data.length}D shape`)
                                }
                                5 !== r && 6 !== r || (i = 16),
                                i > o && (o = i),
                                t = Math.ceil(t / i) * i,
                                r = e.data.length,
                                n.push(t),
                                t += 4 * e.data.length
                            }
                            );
                            let a = new ArrayBuffer(t = Math.ceil(t / o) * o);
                            e.forEach( (e, t) => {
                                let r = n[t];
                                e.type === i.DataType.Int32 ? new Int32Array(a,r,e.data.length).set(e.data) : e.type === i.DataType.Uint16 ? new Uint32Array(a,r,e.data.length).set(e.data) : new Float32Array(a,r,e.data.length).set(e.data)
                            }
                            );
                            let s = this.allocBuffer(t, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
                            return this.gpuQueue.writeBuffer(s.buffer, 0, a, 0, t),
                            {
                                offset: 0,
                                size: t,
                                buffer: s.buffer
                            }
                        }
                        async profileTime() {
                            let e = this.timers?.map(e => e.name)
                              , t = this.timers?.map(e => e.query)
                              , r = await Promise.all(t)
                              , i = {
                                kernelMs: 0
                            };
                            return i.kernelMs = r.reduce( (e, t) => e + t),
                            i.getExtraProfileInfo = () => r.map( (t, r) => `${e[r]}: ${t}ms`).join(", "),
                            this.timers = [],
                            i
                        }
                        async time(e) {
                            this.timers,
                            e();
                            let t = this.timers?.map(e => e.name)
                              , r = this.timers?.map(e => e.query)
                              , i = await Promise.all(r)
                              , n = {
                                kernelMs: 0
                            };
                            return n.kernelMs = i.reduce( (e, t) => e + t),
                            n.getExtraProfileInfo = () => i.map( (e, r) => `${t[r]}: ${e}ms}`).join(", "),
                            this.timers = [],
                            n
                        }
                        async getTimeFromQuerySet(e) {
                            let t = this.allocBuffer(16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE)
                              , r = this.allocBuffer(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
                            this.prepareCommandEncoder(),
                            this.endComputePassEncoder(),
                            this.commandEncoder?.resolveQuerySet(e, 0, 2, t.buffer, 0),
                            this.commandEncoder?.copyBufferToBuffer(t.buffer, 0, r.buffer, 0, 16),
                            this.submitEncodedCommands(),
                            await r.buffer.mapAsync(GPUMapMode.READ);
                            let i = new BigUint64Array(r.buffer.getMappedRange())
                              , n = Number(i[1] - i[0]) / 1e6;
                            return r.buffer.unmap(),
                            this.releaseBuffer(r.buffer),
                            this.releaseBuffer(t.buffer),
                            n
                        }
                        async getQueryTime(e) {
                            return this.supportTimeQuery ? this.getTimeFromQuerySet(e) : 0
                        }
                        allocWebGPUStorage(e, t, r) {
                            e || (e = i.DataType.Float32);
                            let n = new o.WebGPULayout(t)
                              , a = n.getReorderedVec4ElementSize()
                              , u = this.allocBuffer(a * i.bytesForDataType(e), GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE);
                            if (r) {
                                let t = n.reorderDataToVec4Arr(r)
                                  , o = this.gpuDevice.createBuffer({
                                    size: t.byteLength,
                                    usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
                                    mappedAtCreation: !0
                                })
                                  , a = o.getMappedRange();
                                e == i.DataType.Int32 ? new Int32Array(a).set(t) : new Float32Array(a).set(t),
                                o.unmap(),
                                this.prepareCommandEncoder(),
                                this.endComputePassEncoder(),
                                this.commandEncoder?.copyBufferToBuffer(o, 0, u.buffer, 0, t.byteLength)
                            }
                            return new s.WebGPUStorage(this,u.id,u.buffer,n,e,t.elements)
                        }
                        release(e) {
                            this.releaseBuffer(e.storage.buffer)
                        }
                        dispose() {
                            throw Error("Method not implemented.")
                        }
                        prepareCommandEncoder() {
                            this.commandEncoder || (this.commandEncoder = this.gpuDevice.createCommandEncoder())
                        }
                        endComputePassEncoder() {
                            this.computePassEncoder && (this.computePassEncoder.end(),
                            this.computePassEncoder = null)
                        }
                        submitEncodedCommands() {
                            this.commandEncoder && (this.endComputePassEncoder(),
                            this.gpuQueue.submit([this.commandEncoder.finish()]),
                            this.commandEncoder = null,
                            u.curPassCount = 0)
                        }
                        createBufferFromTexture(e, t, r) {
                            this.prepareCommandEncoder(),
                            this.endComputePassEncoder(),
                            this.submitEncodedCommands(),
                            this.gpuDevice.createBuffer({
                                size: e.width * e.height * 4,
                                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                                mappedAtCreation: !0
                            })
                        }
                        uploadDataToBuffer(e, t, r) {
                            let n = this.gpuDevice.createBuffer({
                                size: t.byteLength,
                                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC,
                                mappedAtCreation: !0
                            })
                              , o = n.getMappedRange();
                            r == i.DataType.Int32 ? new Int32Array(o).set(t) : new Float32Array(o).set(t),
                            n.unmap(),
                            this.prepareCommandEncoder(),
                            this.endComputePassEncoder(),
                            this.commandEncoder?.copyBufferToBuffer(n, 0, e, 0, t.byteLength),
                            this.submitEncodedCommands()
                        }
                        clearBuffer() {
                            for (let e = 0; e < this.bufferMemory.length; e++)
                                if (this.bufferMemory[e]?.buffer?.size > 0)
                                    try {
                                        this.releaseBuffer(this.bufferMemory[e].buffer)
                                    } catch {
                                        continue
                                    }
                        }
                        readStorageSync(e) {
                            let t = e.buffer
                              , r = t.size
                              , i = 256
                              , n = 256
                              , o = ["opaque", "premultiplied"]
                              , a = o.map(e => new OffscreenCanvas(i,n))
                              , s = new OffscreenCanvas(i,n);
                            this.endComputePassEncoder();
                            let u = r / 4
                              , l = new ArrayBuffer(r)
                              , c = e.layout;
                            return a.map( (e, t) => {
                                let r = e.getContext("webgpu");
                                return r.configure({
                                    device: this.gpuDevice,
                                    format: "bgra8unorm",
                                    usage: GPUTextureUsage.COPY_DST,
                                    alphaMode: o[t]
                                }),
                                r.getCurrentTexture()
                            }
                            ).map( (e, r) => {
                                let c = (i, n, u) => {
                                    this.prepareCommandEncoder(),
                                    this.commandEncoder?.copyBufferToTexture({
                                        buffer: t,
                                        bytesPerRow: 1024,
                                        offset: u
                                    }, {
                                        texture: e
                                    }, {
                                        width: i,
                                        height: n
                                    }),
                                    this.submitEncodedCommands();
                                    let c = s.getContext("2d", {
                                        willReadFrequently: !0
                                    });
                                    c.clearRect(0, 0, i, n),
                                    c.drawImage(a[r], 0, 0);
                                    let p = c.getImageData(0, 0, i, n).data
                                      , d = o[r]
                                      , f = new Uint8ClampedArray(l,u,i * n * 4);
                                    for (let e = 0; e < f.length; e += 4)
                                        if ("premultiplied" === d)
                                            f[e + 3] = p[e + 3];
                                        else {
                                            let t = p[e];
                                            f[e] = p[e + 2],
                                            f[e + 1] = p[e + 1],
                                            f[e + 2] = t
                                        }
                                }
                                  , p = Math.floor(u / 65536)
                                  , d = i
                                  , f = n
                                  , m = 0;
                                for (let e = 0; e < p; e++)
                                    c(d, f, m),
                                    m += 262144;
                                let h = u % 65536;
                                (f = Math.floor(h / i)) > 0 && (c(d, f, m),
                                m += 1024 * f),
                                (d = h % i) > 0 && c(d, 1, m)
                            }
                            ),
                            c.reorderVec4ArrayAsData(new Float32Array(l))
                        }
                        async readStorage(e) {
                            let t;
                            let r = this.gpuDevice.createBuffer({
                                size: e.buffer.size,
                                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                            })
                              , n = e.layout;
                            this.prepareCommandEncoder(),
                            this.endComputePassEncoder(),
                            this.commandEncoder?.copyBufferToBuffer(e.buffer, 0, r, 0, e.buffer.size),
                            this.submitEncodedCommands(),
                            await r.mapAsync(GPUMapMode.READ);
                            let o = r.getMappedRange();
                            switch (e.type) {
                            case i.DataType.Float32:
                                t = n.reorderVec4ArrayAsData(new Float32Array(o));
                                break;
                            case i.DataType.Int8:
                                t = n.reorderVec4ArrayAsData(new Int8Array(o));
                                break;
                            case i.DataType.Uint8:
                                t = n.reorderVec4ArrayAsData(new Uint8Array(o));
                                break;
                            default:
                                throw Error(`[webgl] invalid data type ${e.type} for reading.`)
                            }
                            return r.unmap(),
                            r && this.releaseBuffer(r),
                            t
                        }
                        createBindGroupLayout(e, t=[]) {
                            let r = [...e, ...t].map( (e, t) => ({
                                binding: t,
                                visibility: GPUShaderStage.COMPUTE
                            }));
                            return this.gpuDevice.createBindGroupLayout({
                                entries: r
                            })
                        }
                        createBindGroup(e, t, r=[]) {
                            let i = t.map( (e, t) => ({
                                binding: t,
                                resource: {
                                    buffer: e.storage.buffer
                                }
                            }));
                            return r.length && i.push({
                                binding: t.length,
                                resource: this.makeUniform(r)
                            }),
                            this.gpuDevice.createBindGroup({
                                layout: e.getBindGroupLayout(0),
                                entries: i
                            })
                        }
                        createComputePipeline(e, t, r) {
                            return this.gpuDevice.createComputePipeline({
                                layout: "auto",
                                compute: {
                                    module: this.gpuDevice.createShaderModule({
                                        code: t,
                                        label: r
                                    }),
                                    entryPoint: "main"
                                }
                            })
                        }
                        copyTextureToTexture(e, t) {
                            this.prepareCommandEncoder(),
                            this.endComputePassEncoder(),
                            this.commandEncoder?.copyTextureToTexture({
                                texture: e
                            }, {
                                texture: t
                            }, {
                                width: e.width,
                                height: e.height
                            }),
                            this.submitEncodedCommands()
                        }
                        createComputePipelineAsync(e, t, r) {
                            return this.gpuDevice.createComputePipelineAsync({
                                layout: this.gpuDevice.createPipelineLayout({
                                    bindGroupLayouts: [e]
                                }),
                                compute: {
                                    module: this.gpuDevice.createShaderModule({
                                        code: t,
                                        label: r
                                    }),
                                    entryPoint: "main"
                                }
                            })
                        }
                        executeGPUComputePipeline(e, t, r) {
                            if (this.prepareCommandEncoder(),
                            this.commandEncoder) {
                                let i = {};
                                if (!this.querySet && this.supportTimeQuery && (this.querySet = this.gpuDevice.createQuerySet({
                                    type: "timestamp",
                                    count: 2
                                })),
                                this.supportTimeQuery && this.querySet && (i.timestampWrites = {
                                    querySet: this.querySet,
                                    beginningOfPassWriteIndex: 0,
                                    endOfPassWriteIndex: 1
                                }),
                                this.endComputePassEncoder(),
                                this.computePassEncoder = this.commandEncoder.beginComputePass(i),
                                this.computePassEncoder.setPipeline(e),
                                this.computePassEncoder.setBindGroup(0, t),
                                this.computePassEncoder.dispatchWorkgroups(r[0], r[1], r[2]),
                                u.curPassCount += 1,
                                u.curPassCount >= 15 && this.submitEncodedCommands(),
                                this.supportTimeQuery) {
                                    let e = this.getQueryTime(this.querySet);
                                    this.timers.push({
                                        name: this.timers.length.toString(),
                                        query: e
                                    })
                                }
                            }
                        }
                        createTexToBufPipeleine(e) {
                            let t = a.getGpuType(e)
                              , r = `

        struct Uniform {
            textureSize: vec2<i32>,
            zero: f32,
            scale: f32
        };

        @group(0) @binding(0) var tex: texture_2d<f32>;
        @group(0) @binding(1) var<storage, read_write> buf: array<vec4<${t}>>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
        fn getGlobalIndex() -> i32 {
            return i32((workgroupId.x + workgroupId.y * numWorkgroups.x + workgroupId.z * numWorkgroups.x * numWorkgroups.y) * 256 + localIndex);
        }
        fn getTextureCoord(index: i32) -> vec2<i32> {
            return vec2<i32>(i32(index % uniforms.textureSize[0]), i32(index / uniforms.textureSize[0]));
        }

        var<private> localId: vec3<u32>;
        var<private> localIndex: u32;
        var<private> globalId: vec3<u32>;
        var<private> numWorkgroups: vec3<u32>;
        var<private> workgroupId: vec3<u32>;

        @compute @workgroup_size(256, 1, 1)
        fn main(
            @builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(local_invocation_index) LocalIndex: u32,
            @builtin(workgroup_id) WorkgroupId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {

            localId = LocalId;
            localIndex = LocalIndex;
            globalId = GlobalId;
            numWorkgroups = NumWorkgroups;
            workgroupId = WorkgroupId;

            let index = getGlobalIndex();
            if (index >= uniforms.textureSize.x * uniforms.textureSize.y) {
                return;
            }
            let coords: vec2<i32> = getTextureCoord(index);
            buf[index] = (textureLoad(tex, coords, 0) * vec4<${t}>(255) - vec4<${t}>(uniforms.zero)) * vec4<${t}>(uniforms.scale);
            buf[index] = textureLoad(tex, coords, 0);
            return;
        }
        `;
                            this.texToBufPipeline = this.gpuDevice.createComputePipeline({
                                layout: "auto",
                                compute: {
                                    module: this.gpuDevice.createShaderModule({
                                        code: r,
                                        label: "texToBuf"
                                    }),
                                    entryPoint: "main"
                                }
                            })
                        }
                        createTexture(e) {
                            return this.gpuDevice.createTexture(e)
                        }
                        createBufToTexPipeleine(e) {
                            let t = a.getGpuType(e)
                              , r = `

        struct Uniform {
            textureSize: vec2<i32>,
            zero: f32,
            scale: f32
        };

        @group(0) @binding(0) var<storage, read_write> buf: array<vec4<${t}>>;
        @group(0) @binding(1) var tex: texture_storage_2d<bgra8unorm, write>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;

        fn getGlobalIndex() -> i32 {
            return i32((workgroupId.x + workgroupId.y * numWorkgroups.x + workgroupId.z * numWorkgroups.x * numWorkgroups.y) * 256 + localIndex);
        }
        fn getTextureCoord(index: i32) -> vec2<i32> {
            return vec2<i32>(i32(index % uniforms.textureSize[0]), i32(index / uniforms.textureSize[0]));
        }
        var<private> localId: vec3<u32>;
        var<private> localIndex: u32;
        var<private> globalId: vec3<u32>;
        var<private> numWorkgroups: vec3<u32>;
        var<private> workgroupId: vec3<u32>;

        @compute @workgroup_size(256, 1, 1)
        fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {

            localId = LocalId;
            localIndex = LocalIndex;
            globalId = GlobalId;
            numWorkgroups = NumWorkgroups;
            workgroupId = WorkgroupId;

            let index = getGlobalIndex();
            let coords: vec2<i32> = getTextureCoord(index);
            // let out: vec4<${t}> = (buf[index] - vec4<${t}>(uniforms.range[0])) / vec4<${t}>(uniforms.range[1] - uniforms.range[0]);
            let out: vec4<f32> = (vec4<f32>(buf[index]) / vec4<f32>(uniforms.scale) + vec4<f32>(uniforms.zero)) / vec4<f32>(255.0);
            textureStore(tex, coords, out);
            return;
        }
        `;
                            this.bufToTexPipeline = this.gpuDevice.createComputePipeline({
                                layout: "auto",
                                compute: {
                                    module: this.gpuDevice.createShaderModule({
                                        code: r,
                                        label: "bufToTex"
                                    }),
                                    entryPoint: "main"
                                }
                            })
                        }
                        textureToBuffer(e, t, r, n=[0, 1]) {
                            this.texToBufPipeline || this.createTexToBufPipeleine(r);
                            let o = [{
                                binding: 0,
                                resource: e.createView()
                            }, {
                                binding: 1,
                                resource: {
                                    buffer: t
                                }
                            }, {
                                binding: 2,
                                resource: this.makeUniform([{
                                    type: i.DataType.Int32,
                                    data: [e.width, e.height],
                                    name: "textureSize"
                                }, {
                                    type: i.DataType.Float32,
                                    data: [n[0]],
                                    name: "zero"
                                }, {
                                    type: i.DataType.Float32,
                                    data: [n[1]],
                                    name: "scale"
                                }])
                            }]
                              , a = this.gpuDevice.createBindGroup({
                                layout: this.texToBufPipeline.getBindGroupLayout(0),
                                entries: o
                            })
                              , s = e.width * e.height;
                            this.executeGPUComputePipeline(this.texToBufPipeline, a, [Math.ceil(s / 256), 1, 1]),
                            this.submitEncodedCommands()
                        }
                        bufferToTexture(e, t, r, n=[0, 1]) {
                            this.bufToTexPipeline || this.createBufToTexPipeleine(r);
                            let o = [{
                                binding: 0,
                                resource: {
                                    buffer: t
                                }
                            }, {
                                binding: 1,
                                resource: e.createView()
                            }, {
                                binding: 2,
                                resource: this.makeUniform([{
                                    type: i.DataType.Int32,
                                    data: [e.width, e.height],
                                    name: "textureSize"
                                }, {
                                    type: i.DataType.Float32,
                                    data: [n[0]],
                                    name: "zero"
                                }, {
                                    type: i.DataType.Float32,
                                    data: [n[1]],
                                    name: "scale"
                                }])
                            }]
                              , a = this.gpuDevice.createBindGroup({
                                layout: this.bufToTexPipeline.getBindGroupLayout(0),
                                entries: o
                            })
                              , s = e.width * e.height;
                            this.executeGPUComputePipeline(this.bufToTexPipeline, a, [Math.ceil(s / 256), 1, 1]),
                            this.submitEncodedCommands()
                        }
                        runWebGPUProgram(e, t, r, i) {
                            let n = this.createBindGroupLayout(e)
                              , o = this.createComputePipeline(n, r, i)
                              , a = this.createBindGroup(o, e);
                            this.executeGPUComputePipeline(o, a, t),
                            this.submitEncodedCommands()
                        }
                    }
                    t.WebGPUContext = u,
                    u.curPassCount = 0
                }
                ,
                9121: (e, t, r) => {
                    t.WebGPUDevice = void 0;
                    let i = r(5249)
                      , n = r(4014)
                      , o = r(6437)
                      , a = r(9676)
                      , s = r(6484)
                      , u = r(2332);
                    class l {
                        constructor(e, t, r) {
                            if (e) {
                                this.gpuDeivce = e,
                                this.context = new n.WebGPUContext(e),
                                this.gpuCanvas = r || document.createElement("canvas");
                                let i = this.gpuCanvas.getContext("webgpu");
                                i && i instanceof GPUCanvasContext && (this.gpuCanvasContext = i);
                                let o = navigator.gpu.getPreferredCanvasFormat();
                                if (this.gpuCanvasContext.configure({
                                    device: e,
                                    format: o,
                                    colorSpace: "srgb",
                                    usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                                    alphaMode: "premultiplied"
                                }),
                                t) {
                                    this.glCanvas = t;
                                    let e = this.glCanvas.getContext("webgl2", {
                                        premultipliedAlpha: !0,
                                        alpha: !0
                                    });
                                    e && (this.glCanvasContext = e)
                                } else {
                                    this.glCanvas = new OffscreenCanvas(100,100);
                                    let e = this.glCanvas.getContext("webgl2", {
                                        premultipliedAlpha: !0,
                                        alpha: !0
                                    });
                                    e && (this.glCanvasContext = e)
                                }
                            } else
                                this.initContext()
                        }
                        async initContext() {
                            let e = await l.aquireGPUDevice();
                            this.gpuDeivce = e,
                            this.context = new n.WebGPUContext(e),
                            this.gpuCanvas = document.createElement("canvas");
                            let t = this.gpuCanvas.getContext("webgpu");
                            t && (this.gpuCanvasContext = t);
                            let r = navigator.gpu.getPreferredCanvasFormat();
                            this.gpuCanvasContext.configure({
                                device: e,
                                format: r,
                                colorSpace: "srgb",
                                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                                alphaMode: "premultiplied"
                            }),
                            this.glCanvas = new OffscreenCanvas(100,100);
                            let i = this.glCanvas.getContext("webgl2", {
                                premultipliedAlpha: !0,
                                alpha: !0
                            });
                            i && (this.glCanvasContext = i)
                        }
                        static async aquireGPUDevice() {
                            let e;
                            let t = await navigator.gpu?.requestAdapter();
                            try {
                                e = await t?.requestDevice({
                                    requiredFeatures: ["timestamp-query"]
                                }),
                                console.log("timestamp-query")
                            } catch {
                                e = await t?.requestDevice()
                            }
                            if (e)
                                return e;
                            throw TypeError("need a browser that supports WebGPU")
                        }
                        assertContext() {
                            if (!this.context)
                                throw TypeError("Should init context first")
                        }
                        getContext() {
                            return this.context
                        }
                        build(e) {
                            this.assertContext();
                            let t = a.WebGPUOps.builder(e);
                            return t ? t(e, this.context) : void 0
                        }
                        dispose() {
                            this.context.clearBuffer()
                        }
                        tensorFromData(e, t, r) {
                            null != r && null != r || (r = i.DataType.Float32),
                            e instanceof i.Shape || (e = new i.Shape(i.DataFormat.NHWC,e));
                            let n = this.context.allocWebGPUStorage(r, e, t);
                            return new i.Tensor(e,r,n)
                        }
                        tensorToTexture(e, t, r=0, i=1) {
                            this.context.bufferToTexture(t, e.storage.buffer, e.type, [r, i])
                        }
                        tensorFromGPUBuffer(e, t, r) {
                            e instanceof i.Shape || (e = new i.Shape(i.DataFormat.NHWC,e));
                            let n = new s.WebGPULayout(e);
                            return new i.Tensor(n.shape,t,new u.WebGPUStorage(this.context,-1,r,n,t,r.size))
                        }
                        tensorFromWebGLTexture(e, t, r, n, a, l=0, c=1, p) {
                            e instanceof i.Shape || (e = new i.Shape(i.DataFormat.NHWC,e));
                            let d = new s.WebGPULayout(e)
                              , f = this.gpuDeivce.createTexture({
                                size: [n, a],
                                dimension: "2d",
                                format: "rgba32float",
                                sampleCount: 1,
                                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
                            });
                            if (o.loadTextureFromWebGLToWebGPU(r, f, this.gpuDeivce, n, a, this.glCanvas, this.glCanvasContext),
                            p) {
                                let e = p.storage.buffer;
                                return this.context.textureToBuffer(f, e, i.DataType.Float32, [l, c]),
                                p
                            }
                            {
                                let e = this.context.allocBuffer(n * a * 16, GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC).buffer;
                                return this.context.textureToBuffer(f, e, i.DataType.Float32, [l, c]),
                                new i.Tensor(d.shape,t,new u.WebGPUStorage(this.context,-1,e,d,t,e.size))
                            }
                        }
                        tensorToWebGLTexture(e, t, r, i, n=0, a=1) {
                            let s = this.context.createTexture({
                                size: [r, i],
                                format: "bgra8unorm",
                                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_SRC
                            });
                            this.tensorToTexture(e, s, n, a),
                            o.loadTextureFromWebGPUToWebGL(t, s, this.gpuDeivce, this.gpuCanvas, this.gpuCanvasContext, this.glCanvasContext)
                        }
                        static async create() {
                            let e = await l.aquireGPUDevice();
                            return new l(e)
                        }
                        static createDeviceWithWebGPUDevice(e) {
                            return new l(e)
                        }
                        static createDeviceWithContext(e, t, r) {
                            return new l(e,t,r)
                        }
                    }
                    t.WebGPUDevice = l
                }
                ,
                1614: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUFunction = void 0,
                    t.WebGPUFunction = class {
                        constructor(e) {
                            this.type = e
                        }
                    }
                }
                ,
                199: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.MatMulVec4Function = t.MatMulVec4NaiveFunction = t.MatMulReduceVec4Function = void 0;
                    let i = r(8960)
                      , n = r(1614);
                    class o extends n.WebGPUFunction {
                        constructor(e, t, r={
                            input0: "input0",
                            input1: "input1",
                            output: "output",
                            input0Strides: "uniforms.input0Strides",
                            input1Strides: "uniforms.input1Strides",
                            outputStrides: "uniforms.outputStrides",
                            input0Shape: "uniforms.input0Shape",
                            input1Shape: "uniforms.input1Shape",
                            outputSize: "uniforms.outputSize",
                            dimInner: "uniforms.dimInner",
                            size: "uniforms.size"
                        }) {
                            super(e),
                            this.workgroupSize = t,
                            this.paramNames = r
                        }
                        getFunctionScript(e="matmul") {
                            let {input0: t, input1: r, output: n, dimInner: o, size: a, outputStrides: s, input0Strides: u, input1Strides: l, input0Shape: c, input1Shape: p} = this.paramNames
                              , d = i.getGpuType(this.type);
                            return `
        var<workgroup> sumVals : array<vec4<${d}>, ${this.workgroupSize[0]}>;
        fn ${e}() {
            let index = i32((workgroupId.x + workgroupId.y * numWorkgroups.x + workgroupId.z * numWorkgroups.y * numWorkgroups.x));
            // if (index >= ${a}) {
            //     return;
            // }
            let coord = getCoordFromIndexDim3(index, ${s});
            let on = coord.x;
            let oh = coord.y;
            let ow4 = coord.z * 4;
            let on0 = on % ${c}[0];
            let on1 = on % ${p}[0];
            var sum = vec4(0.0);
            for (var k = i32(localId.x); k < ${o} / 4; k = k + ${this.workgroupSize[0]}) {
                let k4 = k * 4;
                let aVal = ${t}[getIndexFromCoordDim3(on0, oh, k, ${u})];
                let bVal0 = ${r}[getIndexFromCoordDim3(on1, k4, ow4, ${l})];
                let bVal1 = ${r}[getIndexFromCoordDim3(on1, k4 + 1, ow4, ${l})];
                let bVal2 = ${r}[getIndexFromCoordDim3(on1, k4 + 2, ow4, ${l})];
                let bVal3 = ${r}[getIndexFromCoordDim3(on1, k4 + 3, ow4, ${l})];
                let cVal0 = vec4(bVal0[0], bVal1[0], bVal2[0], bVal3[0]);
                let cVal1 = vec4(bVal0[1], bVal1[1], bVal2[1], bVal3[1]);
                let cVal2 = vec4(bVal0[2], bVal1[2], bVal2[2], bVal3[2]);
                let cVal3 = vec4(bVal0[3], bVal1[3], bVal2[3], bVal3[3]);
                sum += vec4<${d}>(dot(aVal, cVal0), dot(aVal, cVal1), dot(aVal, cVal2), dot(aVal, cVal3));
            }
            sumVals[localId.x] = sum;
            workgroupBarrier();

            for (var k = ${this.workgroupSize[0] / 2}u; k > 1u; k = k / 2u) {
                if (localId.x < k) {
                    sumVals[localId.x] += sumVals[localId.x + k];
                }
                workgroupBarrier();
            }
            if (localId.x == 0u) {
                sum = sumVals[0] + sumVals[1];
                output[index] = sum;
            }

        }
        `
                        }
                    }
                    t.MatMulReduceVec4Function = o;
                    class a extends n.WebGPUFunction {
                        constructor(e, t={
                            input0: "input0",
                            input1: "input1",
                            output: "output",
                            input0Strides: "uniforms.input0Strides",
                            input1Strides: "uniforms.input1Strides",
                            outputStrides: "uniforms.outputStrides",
                            input0Shape: "uniforms.input0Shape",
                            input1Shape: "uniforms.input1Shape",
                            outputSize: "uniforms.outputSize",
                            dimInner: "uniforms.dimInner",
                            size: "uniforms.size"
                        }) {
                            super(e),
                            this.paramNames = t
                        }
                        getFunctionScript(e="matmul") {
                            let t = i.getGpuType(this.type)
                              , {input0: r, input1: n, output: o, dimInner: a, size: s, outputStrides: u, input0Strides: l, input1Strides: c} = this.paramNames;
                            return `
        fn ${e}() {
            let index = getGlobalIndex();
            if (index < ${s}) {
                let coord = getCoordFromIndexDim3(index, ${u});
                let on = coord.x;
                let oh = coord.y;
                let ow4 = coord.z;
                var res: vec4<${t}>;
                var i4 = 0;
                for (var i = 0; i < (${a} - 1) / 4 + 1; i++) {
                    let v0 = ${r}[getIndexFromCoordDim3(on, oh, i, ${l})];
                    let v1_0 = ${n}[getIndexFromCoordDim3(on, i4, ow4, ${c})];
                    let v1_1 = ${n}[getIndexFromCoordDim3(on, i4 + 1, ow4, ${c})];
                    let v1_2 = ${n}[getIndexFromCoordDim3(on, i4 + 2, ow4, ${c})];
                    let v1_3 = ${n}[getIndexFromCoordDim3(on, i4 + 3, ow4, ${c})];
                    res += vec4(dot(v0, v1_0), dot(v0, v1_1), dot(v0, v1_2), dot(v0, v1_3));
                    i4 += 4;
                }
                ${o}[index] = res;
            }
        }
        `
                        }
                    }
                    t.MatMulVec4NaiveFunction = a;
                    class s extends n.WebGPUFunction {
                        constructor(e, t, r=32, i={
                            input0: "input0",
                            input1: "input1",
                            output: "output",
                            input0Strides: "uniforms.input0Strides",
                            input1Strides: "uniforms.input1Strides",
                            outputStrides: "uniforms.outputStrides",
                            input0Shape: "uniforms.input0Shape",
                            input1Shape: "uniforms.input1Shape",
                            outputSize: "uniforms.outputSize",
                            dimInner: "uniforms.dimInner"
                        }) {
                            super(e),
                            this.workgroupSize = t,
                            this.innerSize = r,
                            this.paramNames = i
                        }
                        getFunctionScript(e="matmul") {
                            let t = i.getGpuType(this.type)
                              , r = 4 * this.workgroupSize[0]
                              , n = 4 * this.workgroupSize[1]
                              , o = this.innerSize;
                            return `
        var<workgroup> mm0 : array<array<vec4<${t}>, ${o / 4}>, ${r}>;
        var<workgroup> mm1 : array<array<vec4<${t}>, ${n / 4}>, ${o}>;

        fn getInput0(n: i32, h: i32, w: i32) -> vec4<${t}> {
            return ${this.paramNames.input0}[getIndexFromCoordDim3(n, h, w, ${this.paramNames.input0Strides})];
        }
        fn getInput1(n: i32, h: i32, w: i32) -> vec4<${t}> {
            return ${this.paramNames.input1}[getIndexFromCoordDim3(n, h, w, ${this.paramNames.input1Strides})];
        }
        fn ${e}() {

            // if (index >= uniforms.outputSize) {
            //     return;
            // }

            let t_col = i32(localId.y);
            let t_row = i32(localId.x) * 4;
            let g_col = i32(globalId.y);
            let g_row = i32(globalId.x) * 4;

            let g_batch = i32(globalId.z);
            let n0 = g_batch % ${this.paramNames.input0Shape}[0];
            let n1 = g_batch % ${this.paramNames.input1Shape}[0];

            let n_tiles = (uniforms.dimInner - 1) / ${o} + 1;

            var res: array<vec4<${t}>, 4>;
            var tile_s: i32 = 0;

            for (var t = 0; t < n_tiles; t++) {
                // load input0 tile
                for (var i = 0; i < 4; i++) {
                    let i_row = t_row + i;
                    let i_col = t_col;
                    mm0[i_row][i_col] = getInput0(n0, g_row + i, tile_s + t_col);
                }
                // load input1 tile
                for (var i = 0; i < 4; i++) {
                    let i_row = t_row + i;
                    let i_col = t_col;
                    mm1[i_row][i_col] = getInput1(n1, tile_s * 4 + i_row, g_col);
                }

                tile_s += ${o / 4};
                workgroupBarrier();

                for (var k = 0; k < ${o / 4}; k++) {
                    var row1_s = k * 4;
                    for (var i = 0; i < 4; i++) {
                        let input0_val = mm0[t_row + i][k];
                        let input1_val0 = mm1[row1_s][t_col];
                        let input1_val1 = mm1[row1_s + 1][t_col];
                        let input1_val2 = mm1[row1_s + 2][t_col];
                        let input1_val3 = mm1[row1_s + 3][t_col];
                        let o0 = dot(input0_val, vec4(input1_val0[0], input1_val1[0], input1_val2[0], input1_val3[0]));
                        let o1 = dot(input0_val, vec4(input1_val0[1], input1_val1[1], input1_val2[1], input1_val3[1]));
                        let o2 = dot(input0_val, vec4(input1_val0[2], input1_val1[2], input1_val2[2], input1_val3[2]));
                        let o3 = dot(input0_val, vec4(input1_val0[3], input1_val1[3], input1_val2[3], input1_val3[3]));
                        res[i] += vec4<${t}>(o0, o1, o2, o3);
                    }
                }
                workgroupBarrier();
            }

            for (var i = 0; i < 4; i++) {
                let index = getIndexFromCoordDim3(g_batch, g_row + i, g_col, ${this.paramNames.outputStrides});
                output[index] = res[i];
            }
        }
        `
                        }
                    }
                    t.MatMulVec4Function = s
                }
                ,
                8448: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.SeScaleFunction = void 0;
                    let i = r(8960)
                      , n = r(1614);
                    class o extends n.WebGPUFunction {
                        constructor(e, t=!1, r={
                            input: "input",
                            scale: "scale",
                            output: "output",
                            scaleStrides: "uniforms.scaleStrides",
                            outputStrides: "uniforms.outputStrides",
                            size: "uniforms.size"
                        }) {
                            super(e),
                            this.reluTerm = t,
                            this.paramNames = r
                        }
                        getFunctionScript(e="sescale") {
                            i.getGpuType(this.type);
                            let {input: t, size: r, scale: n, scaleStrides: o, outputStrides: a} = this.paramNames;
                            return `
            fn ${e}() {
                let index = getGlobalIndex();
                if (index < ${r}) {
                    let coord = getCoordFromIndexDim4(index, ${a});
                    let on = coord.x;
                    let oh = coord.y;
                    let ow = coord.z;
                    let oc4 = coord.w;
                    let in4 = ${t}[getIndexFromCoordDim4(on, oh, ow, oc4, ${a})];
                    let scale4 = ${n}[getIndexFromCoordDim4(on, 0, 0, oc4, ${o})];
                    let out4 = in4 * scale4;
                    output[index] = ${this.reluTerm ? "max(out4, vec4(0.0))" : "out4"};
                }
            }
        `
                        }
                    }
                    t.SeScaleFunction = o
                }
                ,
                1649: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.TransposeFunction = void 0;
                    let i = r(8960)
                      , n = r(1614);
                    class o extends n.WebGPUFunction {
                        constructor(e, t, r={
                            input: "input",
                            output: "output",
                            inputStrides: "uniforms.inputStrides",
                            outputStrides: "uniforms.outputStrides",
                            outputSize: "uniforms.outputSize"
                        }) {
                            super(e),
                            this.dims = t,
                            this.paramNames = r,
                            this.getInputCoordScript = () => this.inverseDims.map( (e, t) => {
                                let r = e == this.dims.length - 1 && e !== t ? `o${e} + i` : `o${e}`;
                                return t == this.dims.length - 1 ? `(${r}) / 4` : r
                            }
                            );
                            let i = Array(this.dims.length).fill(0);
                            for (let e = 0; e < this.dims.length; e++)
                                i[this.dims[e]] = e;
                            this.inverseDims = i,
                            this.rank = this.dims.length
                        }
                        getOutputCoordsScript() {
                            let e = [];
                            for (let t = 0; t < this.dims.length - 1; t++)
                                e.push(`
            let o${t}: i32 = coords[${t}];
            `);
                            return e.push(`
        let o${this.rank - 1} = coords[${this.rank - 1}] * 4;
        `),
                            `
        let coords = getCoordFromIndexDim${this.dims.length}(index, ${this.paramNames.outputStrides});
        ${e.join("")}
        `
                        }
                        getFunctionScript(e="transpose") {
                            let t = i.getGpuType(this.type);
                            return `
        fn ${e}(
            index: i32
        ) {
            if (index >= uniforms.outputSize) {
                return;
            }
            ${this.getOutputCoordsScript()}
            var res: vec4<${t}> = vec4<${t}>(0);
            ${this.inverseDims[this.rank - 1] == this.rank - 1 ? `
            let inId = getIndexFromCoordDim${this.rank}(${this.getInputCoordScript().join(", ")}, ${this.paramNames.inputStrides});
            res = input[inId];
        ` : `
            for (var i = 0; i < 4; i++) {
                let inId = getIndexFromCoordDim${this.rank}(${this.getInputCoordScript().join(", ")}, ${this.paramNames.inputStrides});
                let inVal = input[inId];
                let offset = o${this.inverseDims[this.rank - 1]} % 4;
                if (offset == 0) {
                    res[i] = inVal.x;
                } else if (offset == 1) {
                    res[i] = inVal.y;
                } else if (offset == 2) {
                    res[i] = inVal.z;
                } else {
                    res[i] = inVal.w;
                }
        }
        `}
            output[index] = res;
        }
        `
                        }
                    }
                    t.TransposeFunction = o
                }
                ,
                6437: (e, t) => {
                    function r(e, t, r) {
                        let i = e.createShader(r);
                        if (!i)
                            throw Error(`[webgl] failed to create shader with type ${r}.`);
                        if (e.shaderSource(i, t),
                        e.compileShader(i),
                        !1 === e.getShaderParameter(i, e.COMPILE_STATUS))
                            throw Error(`[webgl] failed to compile shader: ${e.getShaderInfoLog(i)}`);
                        return i
                    }
                    function i(e, t, i, n) {
                        e.viewport(0, 0, i, n),
                        e.scissor(0, 0, i, n),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null);
                        let o = e.createProgram();
                        if (!o)
                            throw Error("Cannot create webgl program");
                        let a = r(e, "\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nuniform vec2 u_resolution;\nvarying vec2 v_texcoord;\n\nvoid main()\n{\n    vec2 zeroToOne = a_position / u_resolution;\n    vec2 clipSpace = zeroToOne * 2.0 - 1.0;\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    v_texcoord = a_texcoord;\n}", e.VERTEX_SHADER)
                          , s = r(e, "\nprecision mediump float;\nvarying vec2 v_texcoord;\nuniform sampler2D u_texture;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_texcoord);\n}\n", e.FRAGMENT_SHADER);
                        e.attachShader(o, a),
                        e.attachShader(o, s),
                        e.linkProgram(o),
                        e.useProgram(o);
                        let u = e.getAttribLocation(o, "a_position")
                          , l = e.getAttribLocation(o, "a_texcoord")
                          , c = e.getUniformLocation(o, "u_resolution")
                          , p = e.createBuffer();
                        e.bindBuffer(e.ARRAY_BUFFER, p),
                        function(e, t, r, i, n) {
                            let o = 0
                              , a = t + i
                              , s = 0
                              , u = r + n;
                            e.bufferData(e.ARRAY_BUFFER, new Float32Array([o, s, a, s, o, u, o, u, a, s, a, u]), e.STATIC_DRAW)
                        }(e, 0, 0, i, n);
                        let d = e.createBuffer();
                        e.bindBuffer(e.ARRAY_BUFFER, d),
                        e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        e.enableVertexAttribArray(u),
                        e.bindBuffer(e.ARRAY_BUFFER, p),
                        e.vertexAttribPointer(u, 2, e.FLOAT, !1, 0, 0),
                        e.enableVertexAttribArray(l),
                        e.bindBuffer(e.ARRAY_BUFFER, d),
                        e.vertexAttribPointer(l, 2, e.FLOAT, !1, 0, 0),
                        e.uniform2f(c, e.canvas.width, e.canvas.height),
                        e.bindTexture(e.TEXTURE_2D, t),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                        e.viewport(0, 0, i, n),
                        e.drawArrays(e.TRIANGLES, 0, 6)
                    }
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.loadTextureFromWebGLToWebGPU = t.loadTextureFromWebGPUToWebGL = t.readGPUBuffer = void 0,
                    t.readGPUBuffer = async function(e, t) {
                        let r = e.createCommandEncoder()
                          , i = e.createBuffer({
                            size: t.size,
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                        });
                        r.copyBufferToBuffer(t, 0, i, 0, t.size),
                        e.queue.submit([r.finish()]),
                        await i.mapAsync(GPUMapMode.READ),
                        console.log(new Float32Array(i.getMappedRange().slice(0)))
                    }
                    ,
                    t.loadTextureFromWebGPUToWebGL = function(e, t, r, n, o, a) {
                        (function(e, t, r, i) {
                            t.width = i.width,
                            t.height = i.height,
                            r.configure({
                                device: e,
                                colorSpace: "srgb",
                                format: "bgra8unorm",
                                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                                alphaMode: "premultiplied"
                            });
                            let n = e.createCommandEncoder();
                            n.copyTextureToTexture({
                                texture: i
                            }, {
                                texture: r.getCurrentTexture()
                            }, {
                                width: i.width,
                                height: i.height,
                                depthOrArrayLayers: 1
                            }),
                            e.queue.submit([n.finish()])
                        }
                        )(r, n, o, t),
                        a.bindTexture(a.TEXTURE_2D, e),
                        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
                        a.texImage2D(a.TEXTURE_2D, 0, a.RGBA8, t.width, t.height, 0, a.RGBA, a.UNSIGNED_BYTE, n),
                        i(a, e, t.width, t.height)
                    }
                    ,
                    t.loadTextureFromWebGLToWebGPU = function(e, t, r, n, o, a, s) {
                        i(s, e, n, o),
                        r.queue.copyExternalImageToTexture({
                            source: a
                        }, {
                            texture: t
                        }, {
                            width: n,
                            height: o
                        })
                    }
                }
                ,
                5421: (e, t, r) => {
                    let i = r(9120)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScript(e, t) {
                            t.storage.layout;
                            let r = e.storage.layout
                              , i = n.getGpuType(t.type)
                              , o = this.operator
                              , [,a,s] = e.shape.dims;
                            return `
        ${r.scriptCoordToIndex("getInputIndexFromCoord")}
        fn start() {
            let index: i32 = getGlobalIndex();
            let inVal: vec4<${i}> = vec4<${i}>(input[index]);
            output[index] = min(vec4<${i}>(${o.maxValue}), max(vec4<${i}>(${o.minValue}), inVal));
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Clip)
                }
                ,
                2877: (e, t, r) => {
                    let i = r(9120)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScript(e, t) {
                            let r = this.operator
                              , i = t.storage.layout;
                            if (2 == r.input_size) {
                                let o = e[0].storage.layout
                                  , a = e[1].storage.layout
                                  , s = n.getGpuType(t.type)
                                  , u = r.axis
                                  , l = i.getReorderedVec4Size();
                                if (0 == u)
                                    return `
                ${i.scriptIndexToCoords("getOutputCoordByIndex")}
                ${o.scriptCoordToIndex("getInput0IndexByCoord")}
                ${a.scriptCoordToIndex("getInput1IndexByCoord")}
                fn start() {
                    let index = getGlobalIndex();
                    if (index >= ${l}) {
                        return;
                    }
                    let coord = getOutputCoordByIndex(index);
                    let on = coord.x;
                    let oh = coord.y;
                    let ow = coord.z;
                    let oc4 = coord.w;
                    let input0_n = ${e[0].shape.dims[u]};
                    var out4: vec4<${s}>;
                    if (on >= 0 && on < input0_n) {
                        out4 = vec4<${s}>(getInput0IndexByCoord(on, oh, ow, oc4));
                    } else {
                        out4 = vec4<${s}>(getInput1IndexByCoord(on - input0_n, oh, ow, oc4));
                    }
                    output[index] = out4;
                }
                `;
                                if (3 == u) {
                                    let t = Math.ceil(e[0].shape.dims[u] / 4);
                                    return `
                ${i.scriptIndexToCoords("getOutputCoordByIndex")}
                ${o.scriptCoordToIndex("getInput0IndexByCoord")}
                ${a.scriptCoordToIndex("getInput1IndexByCoord")}
                fn start() {
                    let index = getGlobalIndex();
                    if (index >= ${l}) {
                        return;
                    }
                    let coord = getOutputCoordByIndex(index);
                    let on = coord.x;
                    let oh = coord.y;
                    let ow = coord.z;
                    let oc4 = coord.w;
                    let channel0_mod: i32 = i32(${e[0].shape.dims[3] % 4});
                    var out4: vec4<${s}> = vec4<${s}>(0);
                    if (channel0_mod == i32(0)) {
                        if (oc4 >= 0 && oc4 < ${t}) {
                            out4 = vec4<${s}>(input0[getInput0IndexByCoord(on, oh, ow, oc4)]);
                        } else {
                            out4 = vec4<${s}>(input1[getInput1IndexByCoord(on, oh, ow, oc4 - ${t})]);
                        }
                    } else {
                        if (oc4 >= 0 && oc4 < ${t} - 1) {
                            out4 = vec4<${s}>(input0[getInput0IndexByCoord(on, oh, ow, oc4)]);
                        } else if (oc4 == ${t - 1}) {
                            let in0 = input0[getInput0IndexByCoord(on, oh, ow, oc4)];
                            let in1 = input1[getInput1IndexByCoord(on, oh, ow, 0)];
                            if (channel0_mod == 1) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in1.x), ${s}(in1.y), ${s}(in1.w));
                            }
                            else if (channel0_mod == 2) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in0.y), ${s}(in1.x), ${s}(in1.y));
                            }
                            else if (channel0_mod == 3) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in0.y), ${s}(in0.z), ${s}(in1.x));
                            }
                        } else {
                            let in0 = input0[getInput1IndexByCoord(on, oh, ow, oc4 - ${t})];
                            let in1 = input1[getInput1IndexByCoord(on, oh, ow, oc4 - ${t} + 1)];
                            if (channel0_mod == 1) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in1.x), ${s}(in1.y), ${s}(in1.w));
                            }
                            else if (channel0_mod == 2) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in0.y), ${s}(in1.x), ${s}(in1.y));
                            }
                            else if (channel0_mod == 3) {
                                out4 = vec4<${s}>(${s}(in0.x), ${s}(in0.y), ${s}(in0.z), ${s}(in1.x));
                            }
                        }
                    }
                    output[index] = out4;
                }
                `
                                }
                            }
                            throw Error("TODO: Unsupported")
                        }
                        resize(e, t) {
                            let r = this.getScript(e, t[0]);
                            this.createPipelineByUserCode(r, [e[0], e[1], t[0]], ["input0", "input1", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], e[1], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Concat)
                }
                ,
                7189: (e, t, r) => {
                    let i = r(8024)
                      , n = r(9120)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        execute(e, t) {
                            let r = this.operator
                              , n = this.context
                              , o = new i.Shape(i.DataFormat.NHWC,r.constShape);
                            console.log("const value", r.constValue),
                            t[0].storage = n.allocWebGPUStorage(t[0].type, o, r.constValue),
                            this.getDispathGridSize(t[0])
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), n.Constant)
                }
                ,
                1690: (e, t, r) => {
                    let i = r(8024)
                      , n = r(9120)
                      , o = r(7115)
                      , a = r(8960)
                      , s = r(4064)
                      , u = r(9676);
                    class l extends s.WebGPUKernel {
                        execute(e, t) {
                            throw Error("Method not implemented.")
                        }
                        allocWeightAndBias(e) {
                            throw Error("Method not implemented.")
                        }
                    }
                    class c extends l {
                        is1x1() {
                            let e = !1
                              , t = this.operator;
                            return 1 === t.kernel.h && 1 === t.kernel.w && 1 === t.stride.x && 1 === t.stride.y && 0 === t.padding.bottom && 0 === t.padding.top && 0 === t.padding.left && 0 === t.padding.right && (e = !0),
                            e
                        }
                        allocWeightAndBias(e) {
                            let t = this.operator
                              , r = this.context;
                            if (!this.weightTensor) {
                                let n = new i.Shape(i.DataFormat.NHWC,[t.channel.out, t.kernel.h, t.kernel.w, t.channel.in])
                                  , o = r.allocWebGPUStorage(e, n, t.weight);
                                this.weightTensor = new i.Tensor(n,e,o)
                            }
                            if (!this.biasTensor && t.bias) {
                                let n = new i.Shape(i.DataFormat.NHWC,[t.channel.out])
                                  , o = r.allocWebGPUStorage(e, n, t.bias);
                                this.biasTensor = new i.Tensor(n,e,o)
                            }
                        }
                        getOutWidthStep(e) {
                            return Math.ceil(e.shape.dims[2] / 4)
                        }
                        getScriptCommon(e, t) {
                            let r = this.operator
                              , i = e.storage.layout
                              , n = t.storage.layout
                              , s = this.weightTensor.storage.layout
                              , [,u,l,c] = e.shape.dims
                              , [p,d,f,m] = t.shape.dims
                              , h = r.kernel.h
                              , g = r.kernel.w
                              , _ = r.dilation.y
                              , v = r.dilation.x
                              , x = a.getGpuType(t.type)
                              , b = n.getReorderedVec4Size();
                            return `
        ${i.scriptCoordToIndex("getInputIndexByCoord")}
        ${n.scriptIndexToCoords("getOutputCoordByIndex")}
        ${n.scriptCoordToIndex("getOutputIndexByCoord")}
        ${s.scriptCoordToIndex("getWeightIndexByCoord")}
        fn start() {
            let index = getGlobalIndex();
            if (index  >= ${b}) {
                return;
            }

            let coord: vec4<i32> = getOutputCoordByIndex(index);
            let on: i32 = coord.x;
            let oh: i32 = coord.y;
            let ow: i32 = coord.z;
            let oc4: i32 = coord.w;
            let oc = oc4 * 4;
            let ow_step = ${this.getOutWidthStep(t)};

            var out0: vec4<${x}> = vec4<${x}>(bias[oc4]);
            var out1: vec4<${x}> = out0;
            var out2: vec4<${x}> = out0;
            var out3: vec4<${x}> = out0;

            var ih: i32 = oh * ${r.stride.y} - ${r.padding.top};
            var iw0: i32 = ow * ${r.stride.x} - ${r.padding.left};
            var iw1: i32 = (ow + ow_step) * ${r.stride.x} - ${r.padding.left};
            var iw2: i32 = (ow + ow_step * 2) * ${r.stride.x} - ${r.padding.left};
            var iw3: i32 = (ow + ow_step * 3) * ${r.stride.x} - ${r.padding.left};

            for (var kh = 0; kh < ${h}; kh++) {
                if (ih + kh * ${_} < 0 || ih + kh * ${_} >= ${u}) {
                    continue;
                }
                for (var kw = 0; kw < ${g}; kw++) {
                    for (var ic4 = 0; ic4 < ${Math.ceil(c / 4)}; ic4++) {
                        let w0: vec4<${x}> = vec4<${x}>(weight[getWeightIndexByCoord(oc, kh, kw, ic4)]);
                        let w1: vec4<${x}> = vec4<${x}>(weight[getWeightIndexByCoord(oc + 1, kh, kw, ic4)]);
                        let w2: vec4<${x}> = vec4<${x}>(weight[getWeightIndexByCoord(oc + 2, kh, kw, ic4)]);
                        let w3: vec4<${x}> = vec4<${x}>(weight[getWeightIndexByCoord(oc + 3, kh, kw, ic4)]);

                        if (iw0 + kw * ${v} >= 0 && iw0 + kw * ${v} < ${l}) {
                            var in4 = input[getInputIndexByCoord(on, ih + kh * ${_}, iw0 + kw * ${v}, ic4)];
                            out0 += vec4<${x}>(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                        }
                        // if (iw1 + kw * ${v} >= 0 && iw1 + kw * ${v} < ${l}) {
                        //     var in4 = input[getInputIndexByCoord(on, ih + kh * ${_}, iw1 + kw * ${v}, ic4)];
                        //     out1 += vec4<${x}>(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                        // }
                        // if (iw2 + kw * ${v} >= 0 && iw2 + kw * ${v} < ${l}) {
                        //     var in4 = input[getInputIndexByCoord(on, ih + kh * ${_}, iw2 + kw * ${v}, ic4)];
                        //     out2 += vec4<${x}>(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                        // }
                        // if (iw2 + kw * ${v} >= 0 && iw3 + kw * ${v} < ${l}) {
                        //     var in4 = input[getInputIndexByCoord(on, ih + kh * ${_}, iw3 + kw * ${v}, ic4)];
                        //     out3 += vec4<${x}>(dot(in4, w0), dot(in4, w1), dot(in4, w2), dot(in4, w3));
                        // }
                    }
                }
            }
            output[index] = ${r.activation == o.Activation.ReLU ? `max(out0, vec4<${x}>(0.0))` : "out0"};
            // if (ow + ow_step < ${f}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out1, vec4<${x}>(0.0))` : "out1"};
            // }
            // if (ow + ow_step * 2 < ${f}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step * 2, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out2, vec4<${x}>(0.0))` : "out2"};
            // }
            // if (ow + ow_step * 3 < ${f}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step * 3, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out3, vec4<${x}>(0.0))` : "out3"};
            // }
        }
        `
                        }
                        getScript1x1(e, t) {
                            let r = this.operator
                              , i = (this.context,
                            a.getGpuType(t.type))
                              , n = t.storage.layout
                              , s = e.storage.layout
                              , u = this.weightTensor.storage.layout
                              , [l,c,p,d] = e.shape.dims
                              , [f,m,h,g] = t.shape.dims
                              , [_,v,x] = this.getTotalDispatchSize(t)
                              , b = n.getReorderedVec4Size();
                            return `
        ${s.scriptCoordToIndex("getInputIndexByCoord")}
        ${n.scriptIndexToCoords("getOutputCoordByIndex")}
        ${n.scriptCoordToIndex("getOutputIndexByCoord")}
        ${u.scriptCoordToIndex("getWeightIndexByCoord")}
        fn start(
        ) {
            let index: i32 = getGlobalIndex();
            if (index >= ${b}) {
                return;
            }
            let coord = getOutputCoordByIndex(index);
            let on = coord[0];
            let oh = coord[1];
            let ow = coord[2];
            let oc4 = coord[3];
            let oc = oc4 * 4;
            let ow_step = ${this.getOutWidthStep(t)};
            let iwc_step = ${this.getOutWidthStep(t) * Math.ceil(d / 4)};

            var out0: vec4<${i}>;
            var out1: vec4<${i}>;
            var out2: vec4<${i}>;
            var out3: vec4<${i}>;

            out0 = bias[oc4];
            out1 = out0;
            out2 = out0;
            out3 = out0;

            for (var ic4 = 0; ic4 < ${Math.ceil(d / 4)}; ic4++) {
                var idx0 = getInputIndexByCoord(on, oh, ow, ic4);
                var idx1 = idx0 + iwc_step;
                var idx2 = idx1 + iwc_step;
                var idx3 = idx2 + iwc_step;

                let in0: vec4<${i}> = vec4<${i}>(input[idx0]);
                // let in1: vec4<${i}> = vec4<${i}>(input[idx1]);
                // let in2: vec4<${i}> = vec4<${i}>(input[idx2]);
                // let in3: vec4<${i}> = vec4<${i}>(input[idx3]);

                let w0: vec4<${i}> = vec4<${i}>(weight[getWeightIndexByCoord(oc, 0, 0, ic4)]);
                let w1: vec4<${i}> = vec4<${i}>(weight[getWeightIndexByCoord(oc + 1, 0, 0, ic4)]);
                let w2: vec4<${i}> = vec4<${i}>(weight[getWeightIndexByCoord(oc + 2, 0, 0, ic4)]);
                let w3: vec4<${i}> = vec4<${i}>(weight[getWeightIndexByCoord(oc + 3, 0, 0, ic4)]);

                out0 += vec4<${i}>(dot(w0, in0), dot(w1, in0), dot(w2, in0), dot(w3, in0));
                // out1 += vec4<${i}>(dot(w0, in1), dot(w1, in1), dot(w2, in1), dot(w3, in1));
                // out2 += vec4<${i}>(dot(w0, in2), dot(w1, in2), dot(w2, in2), dot(w3, in2));
                // out3 += vec4<${i}>(dot(w0, in3), dot(w1, in3), dot(w2, in3), dot(w3, in3));
            }
            output[index] = ${r.activation == o.Activation.ReLU ? `max(out0, vec4<${i}>(0.0))` : "out0"};
            // if (ow + ow_step < ${h}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out1, vec4<${i}>(0.0))` : "out1"};
            // }
            // if (ow + ow_step * 2 < ${h}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step * 2, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out2, vec4<${i}>(0.0))` : "out2"};
            // }
            // if (ow + ow_step * 3 < ${h}) {
            //     output[getOutputIndexByCoord(on, oh, ow + ow_step * 3, oc4)] = ${r.activation == o.Activation.ReLU ? `max(out3, vec4<${i}>(0.0))` : "out3"};
            // }
        }
        `
                        }
                        resize(e, t) {
                            let r;
                            this.allocWeightAndBias(t[0].type),
                            r = this.is1x1() ? this.getScript1x1(e[0], t[0]) : this.getScriptCommon(e[0], t[0]),
                            this.createPipelineByUserCode(r, [t[0], e[0], this.weightTensor, this.biasTensor], ["output", "input", "weight", "bias"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([t[0], e[0], this.weightTensor, this.biasTensor], r)
                        }
                    }
                    u.WebGPUOps.register( (e, t) => new c(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), n.Conv2D)
                }
                ,
                6793: (e, t, r) => {
                    let i = r(3770)
                      , n = r(4064)
                      , o = r(9676);
                    class a extends n.WebGPUKernel {
                        execute(e, t) {}
                        setData(e, t) {
                            e !== t && (e.fraction = t.fraction,
                            e.shape = t.shape.copy(),
                            e.storage = t.storage,
                            e.type = t.type)
                        }
                    }
                    o.WebGPUOps.register( (e, t) => new a(e,t), i.Data)
                }
                ,
                4314: (e, t, r) => {
                    let i = r(8024)
                      , n = r(9120)
                      , o = r(5857)
                      , a = r(8960)
                      , s = r(4064)
                      , u = r(9676);
                    class l extends s.WebGPUKernel {
                        getOutWidth(e) {
                            return e.shape.dims[3],
                            Math.ceil(e.shape.dims[2] / 4)
                        }
                        getScript(e, t) {
                            let r = this.operator
                              , i = (this.context,
                            a.getGpuType(t.type))
                              , n = t.storage.layout
                              , s = e.storage.layout
                              , u = this.weightTensor.storage.layout
                              , [,l,c,p] = e.shape.dims
                              , d = r.kernel.h
                              , f = r.kernel.w
                              , m = r.dilation.y
                              , h = r.dilation.x
                              , [g,_,v] = this.getTotalDispatchSize(t)
                              , x = n.getReorderedVec4Size()
                              , b = `
        ${n.scriptIndexToCoords("getOutputCoordByIndex")}
        ${n.scriptCoordToIndex("getOutputIndexByCoord")}
        ${s.scriptCoordToIndex("getInputIndexByCoord")}
        ${u.scriptCoordToIndex("getWeightIndexByCoord")}
        fn start(
        ) {
            let index = getGlobalIndex();
            if (index >= ${x}) {
                return;
            }
            let coord = getOutputCoordByIndex(index);
            let on = coord[0];
            let oh = coord[1];
            let ow = coord[2];
            let oc4 = coord[3];
            let ow_step: i32 = ${this.getOutWidth(t)};

            let strideX = ${r.stride.x};
            let strideY = ${r.stride.y};
            let padding_left = ${r.padding.left};
            let padding_right = ${r.padding.right};
            let padding_top = ${r.padding.top};
            let padding_bottom = ${r.padding.bottom};
            let filter_height = ${r.kernel.h};
            let filter_width = ${r.kernel.w};
            let dilation_h = ${r.dilation.y};
            let dilation_w = ${r.dilation.x};

            var in0: vec4<${i}>;
            var in1: vec4<${i}>;
            var in2: vec4<${i}>;
            var in3: vec4<${i}>;

            var out0: vec4<${i}>;
            var out1: vec4<${i}>;
            var out2: vec4<${i}>;
            var out3: vec4<${i}>;

            var ih = oh * ${r.stride.y} - ${r.padding.top};
            var iw0 = ow * ${r.stride.x} - ${r.padding.left};

            var iw1 = iw0 + ow_step * ${r.stride.x};
            var iw2 = iw1 + ow_step * ${r.stride.x};
            var iw3 = iw2 + ow_step * ${r.stride.x};

            ${r.bias ? `
            out0 = vec4<${i}>(bias[oc4]);
            out1 = out0;
            out2 = out0;
            out3 = out0;
            ` : `out0 = vec4<${i}>(0.0);
            out1 = vec4<${i}>(0.0);
            out2 = vec4<${i}>(0.0);
            out3 = vec4<${i}>(0.0);
            `}

            for (var kh = 0; kh < ${d}; kh++) {
                if (ih + kh * ${m} < 0 || ih + kh * ${m} >= ${l}){
                    continue;
                }
                for (var kw = 0; kw < ${f}; kw++) {
                    let kval = weight[getWeightIndexByCoord(0, kh, kw, oc4)];
                    if (iw0 + kw * ${h} >= 0 && iw0 + kw * ${h} < ${c}) {
                        let in4 = input[getInputIndexByCoord(on, ih + kh * ${m}, iw0 + kw * ${h}, oc4)];
                        out0 += in4 * kval;
                    }
                    // if (iw1 + kw * ${h} >= 0 && iw1 + kw * ${h} < ${c}) {
                    //     let in4 = input[getInputIndexByCoord(on, ih + kh * ${m}, iw1 + kw * ${h}, oc4)];
                    //     out1 += in4 * kval;
                    // }
                    // if (iw2 + kw * ${h} >= 0 && iw2 + kw * ${h} < ${c}) {
                    //     let in4 = input[getInputIndexByCoord(on, ih + kh * ${m}, iw2 + kw * ${h}, oc4)];
                    //     out2 += in4 * kval;
                    // }
                    // if (iw3 + kw * ${h} >= 0 && iw3 + kw * ${h} < ${c}) {
                    //     let in4 = input[getInputIndexByCoord(on, ih + kh * ${m}, iw3 + kw * ${h}, oc4)];
                    //     out3 += in4 * kval;
                    // }
                }
            }

            output[index] = ${r.activation == o.Activation.ReLU ? `max(out0, vec4<${i}>(0.0))` : "out0"};
            // output[index] = vec4(0f);
            // output[getOutputIndexByCoord(on, oh, ow + ow_step, oc4)] = out1;
            // output[getOutputIndexByCoord(on, oh, ow + ow_step * 2, oc4)] = out2;
            // output[getOutputIndexByCoord(on, oh, ow + ow_step * 3, oc4)] = out3;

        }
        `;
                            return "Conv_149" == this.operator.name && console.log(b),
                            b
                        }
                        allocWeightAndBias(e) {
                            let t = this.operator
                              , r = this.context;
                            if (!this.weightTensor) {
                                let n = new i.Shape(i.DataFormat.NHWC,[1, t.kernel.h, t.kernel.w, t.channel.out])
                                  , o = r.allocWebGPUStorage(e, n, t.weight);
                                this.weightTensor = new i.Tensor(n,e,o)
                            }
                            if (!this.biasTensor && t.bias) {
                                let n = new i.Shape(i.DataFormat.NHWC,[t.channel.out])
                                  , o = r.allocWebGPUStorage(e, n, t.bias);
                                this.biasTensor = new i.Tensor(n,e,o)
                            }
                        }
                        resize(e, t) {
                            this.allocWeightAndBias(t[0].type);
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0], this.weightTensor, this.biasTensor], ["input", "output", "weight", "bias"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0], this.weightTensor, this.biasTensor], r)
                        }
                    }
                    u.WebGPUOps.register( (e, t) => new l(e,t,{
                        workgroupSize: [8, 4, 4],
                        dispathLayout: {
                            x: [0, 3],
                            y: [1],
                            z: [2]
                        }
                    }), n.DepthwiseConv2D)
                }
                ,
                3779: (e, t, r) => {
                    let i = r(9120)
                      , n = r(3507)
                      , o = r(8960)
                      , a = r(4064)
                      , s = r(9676);
                    class u extends a.WebGPUKernel {
                        getScript(e, t) {
                            let r = t.storage.layout
                              , i = o.getGpuType(t.type)
                              , a = this.operator;
                            return `
        ${r.scriptIndexToCoords("getOutputCoordFromIndex")}
        ${r.scriptCoordToIndex("getOutputIndexFromCoord")}
        fn start() {
            let index: i32 = getGlobalIndex();
            let in0: vec4<${i}> = input_0[index];
            let in1: vec4<${i}> = input_1[index];
            ${( (e, t) => {
                                switch (e) {
                                case n.EltwiseType.Add:
                                    return `let out: vec4<${t}> = in0 + in1;`;
                                case n.EltwiseType.Prod:
                                    return `let out: vec4<${t}> = in0 * in1;`;
                                default:
                                    throw TypeError(`Unsuported elementwise type ${e}`)
                                }
                            }
                            )(a.type, i)}
            output[index] = ${a.activation ? "max(out, vec4(0))" : "out"};
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScript(e, t[0]);
                            this.createPipelineByUserCode(r, [...e, t[0]], ["input_0", "input_1", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([...e, t[0]], r)
                        }
                    }
                    s.WebGPUOps.register( (e, t) => new u(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Eltwise)
                }
                ,
                4064: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUKernel = void 0;
                    let i = r(4401)
                      , n = r(8960);
                    class o extends i.Kernel {
                        constructor(e, t, r) {
                            super(e, t),
                            this.workgroupSize = r ? r.workgroupSize : [255, 1, 1],
                            this.dispatchLayout = r ? r.dispathLayout : {
                                x: [0, 1, 2, 3]
                            }
                        }
                        getTotalDispatchSize(e) {
                            let t = [...e.shape.dims];
                            if (t[t.length - 1] = Math.ceil(t[t.length - 1] / 4),
                            !this.dispatchLayout.y && !this.dispatchLayout.z)
                                return [t.reduce( (e, t) => e * t, 1), 1, 1];
                            let r = 1
                              , i = 1
                              , n = 1;
                            return this.dispatchLayout.x.forEach(e => {
                                r *= t[e]
                            }
                            ),
                            this.dispatchLayout.y && this.dispatchLayout.y.forEach(e => {
                                i *= t[e]
                            }
                            ),
                            this.dispatchLayout.z && this.dispatchLayout.z.forEach(e => {
                                n *= t[e]
                            }
                            ),
                            [r, i, n]
                        }
                        getDispathGridSize(e) {
                            let[t,r,i] = this.getTotalDispatchSize(e);
                            return t = Math.ceil(t / this.workgroupSize[0]),
                            r = Math.ceil(r / this.workgroupSize[1]),
                            [t, r, i = Math.ceil(i / this.workgroupSize[2])]
                        }
                        getDispathGridSizeByBatch(e, t=4, r=2) {
                            let[i,n,o] = this.getTotalDispatchSize(e)
                              , a = !1
                              , s = !1
                              , u = !1;
                            return a = -1 != this.dispatchLayout.x.indexOf(r),
                            this.dispatchLayout.y && (s = -1 != this.dispatchLayout.y.indexOf(r)),
                            this.dispatchLayout.z && (u = -1 != this.dispatchLayout.z.indexOf(r)),
                            s ? (i = Math.ceil(i / this.workgroupSize[0]),
                            n = Math.ceil(n / this.workgroupSize[1] / t),
                            o = Math.ceil(o / this.workgroupSize[2])) : u ? (i = Math.ceil(i / this.workgroupSize[0]),
                            n = Math.ceil(n / this.workgroupSize[1]),
                            o = Math.ceil(o / this.workgroupSize[2] / t)) : (i = Math.ceil(i / this.workgroupSize[0] / t),
                            n = Math.ceil(n / this.workgroupSize[1]),
                            o = Math.ceil(o / this.workgroupSize[2])),
                            [i, n, o]
                        }
                        dispose() {
                            this.context
                        }
                        unify(e) {
                            return e
                        }
                        isInitialized() {
                            return !!this.computePipeline
                        }
                        updateBindGroup(e, t=[]) {
                            let r = this.context;
                            this.bindGroup = r.createBindGroup(this.computePipeline, e, t)
                        }
                        createPipelineByUserCode(e, t, r, i=[]) {
                            let o = this.context
                              , a = n.getProgramCode(e, t, r, this.workgroupSize, i);
                            this.programCode = a;
                            let s = o.createBindGroupLayout(t, i)
                              , u = o.createComputePipeline(s, a);
                            this.bindGroup = void 0,
                            this.computePipeline = u
                        }
                        executePipeline(e, t, r=[]) {
                            let i = this.context;
                            this.bindGroup || (this.bindGroup = i.createBindGroup(this.computePipeline, e, r)),
                            i.executeGPUComputePipeline(this.computePipeline, this.bindGroup, t)
                        }
                        setData(e, t) {
                            e !== t && (e.fraction = t.fraction,
                            e.shape = t.shape.copy(),
                            e.storage = t.storage,
                            e.type = t.type)
                        }
                    }
                    t.WebGPUKernel = o,
                    o.passCount = 0
                }
                ,
                8270: (e, t, r) => {
                    var i;
                    t.MatmulKenelMap = t.MatMulAlgoType = void 0;
                    let n = r(8024)
                      , o = r(1498)
                      , a = r(8313)
                      , s = r(5559)
                      , u = r(4064)
                      , l = r(6951)
                      , c = r(9122)
                      , p = r(3886)
                      , d = r(9676)
                      , f = r(1618);
                    !function(e) {
                        e[e.NAIVE = 0] = "NAIVE",
                        e[e.PACKED_VEC4 = 1] = "PACKED_VEC4",
                        e[e.REDUCE_VEC4 = 2] = "REDUCE_VEC4"
                    }(i = t.MatMulAlgoType || (t.MatMulAlgoType = {})),
                    t.MatmulKenelMap = {
                        [i.NAIVE]: l.WebGPUMatMulNaive,
                        [i.PACKED_VEC4]: c.WebGPUMatMulPackedVec4,
                        [i.REDUCE_VEC4]: p.WebGPUMatMulReduceVec4
                    };
                    class m extends u.WebGPUKernel {
                        constructor(e, r, o=!0, s=!0, u=!0) {
                            super(e, r),
                            this.transpose0 = o,
                            this.transpose1 = s,
                            this.transposeOut = u,
                            this.algoType = i.NAIVE;
                            let l = new a.Transpose({
                                dims: new Int32Array([0, 3, 1, 2])
                            })
                              , c = new a.Transpose({
                                dims: new Int32Array([0, 2, 3, 1])
                            });
                            this.matmulKernel = new t.MatmulKenelMap[this.algoType](this.operator,this.context),
                            this.transpose0 && (this.input0Transpose = new n.Tensor,
                            this.transpose0Kernel = new f.WebGPUTranspose(l,this.context)),
                            this.transpose1 && (this.input1Transpose = new n.Tensor,
                            this.transpose1Kernel = new f.WebGPUTranspose(l,this.context)),
                            this.transposeOut && (this.outputTranspose = new n.Tensor,
                            this.transposeOutKernel = new f.WebGPUTranspose(c,this.context))
                        }
                        getAlgoType(e, t) {
                            let[r,n] = e
                              , [o,a,s,u] = r.shape.dims
                              , [l,c,p,d] = n.shape.dims
                              , f = this.transpose0 ? a : s
                              , m = this.transpose0 ? s : u
                              , h = this.transpose1 ? p : d
                              , g = this.transpose0 ? u : a
                              , _ = Math.max(o * g, l * (this.transpose1 ? d : c)) * Math.ceil(f / 32) * Math.ceil(h / 32);
                            return _ > 16 ? i.PACKED_VEC4 : m <= 1024 && m >= 4 ? i.REDUCE_VEC4 : i.NAIVE
                        }
                        needTranspose(e) {
                            if (e.shape.format == n.DataFormat.NCHW)
                                return !1;
                            let[t,r,i,o] = e.shape.dims;
                            return 1 != t * o
                        }
                        resize(e, r) {
                            let i = this.getAlgoType(e, r[0]);
                            console.log("algoType", i),
                            i != this.algoType && (this.matmulKernel = new t.MatmulKenelMap[i](this.operator,this.context));
                            let n = new a.Transpose({
                                dims: new Int32Array([0, 3, 1, 2])
                            });
                            this.transpose0 && (s.OpShaper.reshape(n, [e[0]], [this.input0Transpose]),
                            this.context.alloc(this.input0Transpose),
                            this.transpose0Kernel.resize([e[0]], [this.input0Transpose])),
                            this.transpose1 && (s.OpShaper.reshape(n, [e[1]], [this.input1Transpose]),
                            this.context.alloc(this.input1Transpose),
                            this.transpose1Kernel.resize([e[1]], [this.input1Transpose])),
                            this.transposeOut && (s.OpShaper.reshape(n, [r[0]], [this.outputTranspose]),
                            this.context.alloc(this.outputTranspose),
                            this.transposeOutKernel.resize([this.outputTranspose], [r[0]]));
                            let o = this.transpose0 ? this.input0Transpose : e[0]
                              , u = this.transpose1 ? this.input1Transpose : e[1]
                              , l = this.transposeOut ? this.outputTranspose : r[0];
                            this.matmulKernel.resize([o, u], [l])
                        }
                        execute(e, t) {
                            this.transpose0 && this.transpose0Kernel.execute([e[0]], [this.input0Transpose]),
                            this.transpose1 && this.transpose1Kernel.execute([e[1]], [this.input1Transpose]);
                            let r = this.transpose0 ? this.input0Transpose : e[0]
                              , i = this.transpose1 ? this.input1Transpose : e[1]
                              , n = this.transposeOut ? this.outputTranspose : t[0];
                            this.matmulKernel.execute([r, i], [n]),
                            this.transposeOut && this.transposeOutKernel.execute([this.outputTranspose], [t[0]])
                        }
                    }
                    d.WebGPUOps.register( (e, t) => new m(e,t), o.MatMul)
                }
                ,
                6951: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUMatMulNaive = void 0;
                    let i = r(8024)
                      , n = r(199)
                      , o = r(4064);
                    class a extends o.WebGPUKernel {
                        constructor() {
                            super(...arguments),
                            this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "size",
                                data: [1]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [0]
                            }]
                        }
                        getScriptVec4(e, t) {
                            return `
        ${new n.MatMulVec4NaiveFunction(t.type).getFunctionScript("matmul")}
        fn start() {
            matmul();
        }
        `
                        }
                        getNHWStrides(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1];
                            return r[1] = t[t.length - 1],
                            r[0] = r[1] * t[t.length - 2],
                            r
                        }
                        getNHWShape(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1, 1];
                            r[2] = t[t.length - 1],
                            r[1] = t[t.length - 2];
                            for (let e = 0; e < t.length - 2; e++)
                                r[0] *= t[e];
                            return r
                        }
                        resize(e, t) {
                            let r = this.getScriptVec4(e, t[0]);
                            this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: this.getNHWStrides(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: this.getNHWStrides(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: this.getNHWStrides(t[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: this.getNHWShape(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: this.getNHWShape(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "size",
                                data: [Math.ceil(t[0].shape.elements / 4)]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [this.getNHWShape(e[0])[2]]
                            }],
                            this.createPipelineByUserCode(r, [...e, t[0]], ["input0", "input1", "output"], this.uniforms)
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([...e, t[0]], r, this.uniforms)
                        }
                    }
                    t.WebGPUMatMulNaive = a
                }
                ,
                9122: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUMatMulPackedVec4 = t.MatMulAlgoType = void 0;
                    let i = r(8024)
                      , n = r(199)
                      , o = r(4064);
                    !function(e) {
                        e[e.NAIVE_REDUCE = 0] = "NAIVE_REDUCE",
                        e[e.PACKED_VEC4 = 1] = "PACKED_VEC4"
                    }(t.MatMulAlgoType || (t.MatMulAlgoType = {}));
                    class a extends o.WebGPUKernel {
                        constructor(e, t) {
                            super(e, t),
                            this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "outputSize",
                                data: [1]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [0]
                            }],
                            this.workgroupSize = [8, 8, 1]
                        }
                        getVec4WorkgroupDispatchSize(e) {
                            let t = e.shape.dims
                              , r = t[0] * t[1]
                              , i = t[2]
                              , n = t[3];
                            return [i / this.workgroupSize[0] / 4, n / this.workgroupSize[1] / 4, r]
                        }
                        getScriptVec4(e, t) {
                            return this.operator,
                            `
        ${new n.MatMulVec4Function(t.type,this.workgroupSize,4 * this.workgroupSize[0]).getFunctionScript("matmul")}
        fn start() {
            matmul();
        }
        `
                        }
                        getNHWStrides(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1];
                            return r[1] = t[t.length - 1],
                            r[0] = r[1] * t[t.length - 2],
                            r
                        }
                        getNHWShape(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1, 1];
                            r[2] = t[t.length - 1],
                            r[1] = t[t.length - 2];
                            for (let e = 0; e < t.length - 2; e++)
                                r[0] *= t[e];
                            return r
                        }
                        resize(e, t) {
                            if (this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: this.getNHWStrides(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: this.getNHWStrides(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: this.getNHWStrides(t[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: this.getNHWShape(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: this.getNHWShape(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "outputSize",
                                data: [1]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [this.getNHWShape(e[0])[2]]
                            }],
                            !this.computePipeline) {
                                let r = this.getScriptVec4(e, t[0])
                                  , i = ["input0", "input1", "output"];
                                this.createPipelineByUserCode(r, [...e, t[0]], i, this.uniforms)
                            }
                            this.bindGroup = void 0
                        }
                        getDispathGridSizeVec4(e) {
                            let[t,r,i] = this.getNHWShape(e);
                            return [Math.ceil(r / this.workgroupSize[0] / 4), Math.ceil(i / this.workgroupSize[1] / 4), Math.ceil(t / this.workgroupSize[2])]
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSizeVec4(t[0]);
                            this.executePipeline([...e, t[0]], r, this.uniforms)
                        }
                    }
                    t.WebGPUMatMulPackedVec4 = a
                }
                ,
                3886: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUMatMulReduceVec4 = void 0;
                    let i = r(8024)
                      , n = r(199)
                      , o = r(4064);
                    class a extends o.WebGPUKernel {
                        constructor(e, t) {
                            super(e, t),
                            this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: [1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: [1, 1, 1]
                            }, {
                                type: i.DataType.Int32,
                                name: "size",
                                data: [1]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [0]
                            }],
                            this.workgroupSize = [16, 1, 1],
                            this.dispatchLayout = {
                                x: [],
                                y: [1, 2],
                                z: [0]
                            }
                        }
                        getScriptVec4(e, t) {
                            return `
        ${new n.MatMulReduceVec4Function(t.type,this.workgroupSize).getFunctionScript("matmul")}
        fn start() {
            matmul();
        }
        `
                        }
                        getNHWStrides(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1];
                            return r[1] = t[t.length - 1],
                            r[0] = r[1] * t[t.length - 2],
                            r
                        }
                        getNHWShape(e) {
                            if (!e.shape)
                                throw TypeError("invalid tensor shape");
                            let t = e.shape.dims
                              , r = [1, 1, 1];
                            r[2] = t[t.length - 1],
                            r[1] = t[t.length - 2];
                            for (let e = 0; e < t.length - 2; e++)
                                r[0] *= t[e];
                            return r
                        }
                        getDispathGridSize(e) {
                            let t = this.getNHWShape(e);
                            return [1, Math.ceil(t[1] * t[2] / this.workgroupSize[1] / 4), t[0]]
                        }
                        resize(e, t) {
                            let r = this.getScriptVec4(e, t[0]);
                            this.uniforms = [{
                                type: i.DataType.Int32,
                                name: "input0Strides",
                                data: this.getNHWStrides(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Strides",
                                data: this.getNHWStrides(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "outputStrides",
                                data: this.getNHWStrides(t[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input0Shape",
                                data: this.getNHWShape(e[0])
                            }, {
                                type: i.DataType.Int32,
                                name: "input1Shape",
                                data: this.getNHWShape(e[1])
                            }, {
                                type: i.DataType.Int32,
                                name: "size",
                                data: [Math.ceil(t[0].shape.elements / 4)]
                            }, {
                                type: i.DataType.Int32,
                                name: "dimInner",
                                data: [this.getNHWShape(e[0])[2]]
                            }],
                            this.createPipelineByUserCode(r, [...e, t[0]], ["input0", "input1", "output"], this.uniforms)
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([...e, t[0]], r, this.uniforms)
                        }
                    }
                    t.WebGPUMatMulReduceVec4 = a
                }
                ,
                3810: (e, t, r) => {
                    let i = r(9120)
                      , n = r(1242)
                      , o = r(8960)
                      , a = r(4064)
                      , s = r(9676);
                    class u extends a.WebGPUKernel {
                        getScript(e, t) {
                            let r = t.storage.layout
                              , i = e.storage.layout
                              , a = o.getGpuType(t.type)
                              , [,s,u] = e.shape.dims
                              , l = this.operator
                              , c = l.kernel.h
                              , p = l.kernel.w
                              , d = l.stride.x
                              , f = l.stride.y
                              , m = l.padding.w
                              , h = l.padding.h;
                            return l.type == n.PoolingType.Max ? `
            ${i.scriptCoordToIndex("getInputIndexFromCoord")}
            ${r.scriptIndexToCoords("getOutputCoordFromIndex")}
            fn start() {
                let index: i32 = getGlobalIndex();
                let coord: vec4<i32> = getOutputCoordFromIndex(index);
                let on: i32 = coord.x;
                let oh: i32 = coord.y;
                let ow: i32 = coord.z;
                let oc4: i32 = coord.w;

                let ih: i32 = oh * ${f} - ${h};
                let iw: i32 = ow * ${d} - ${m};

                var out4: vec4<${a}> = vec4(-9999999999);
                for (var kh = 0; kh < ${c}; kh++) {
                    if (ih + kh < 0 || ih + kh >=${s}) {
                        continue;
                    }
                    for (var kw = 0; kw < ${p}; kw++) {
                        if (iw + kw < 0 || iw + kw >= ${u}){
                            continue;
                        }
                        let in4: vec4<${a}> = input[getInputIndexFromCoord(on, ih + kh, iw + kw, oc4)];
                        out4 = max(out4, in4);
                    }
                }
                output[index] = out4;
            }
            ` : `
            ${i.scriptCoordToIndex("getInputIndexFromCoord")}
            ${r.scriptIndexToCoords("getOutputCoordFromIndex")}
            fn start() {
                let index: i32 = getGlobalIndex();
                let coord: vec4<i32> = getOutputCoordFromIndex(index);
                let on: i32 = coord.x;
                let oh: i32 = coord.y;
                let ow: i32 = coord.z;
                let oc4: i32 = coord.w;

                let ih: i32 = oh * ${f} - ${h};
                let iw: i32 = ow * ${d} - ${m};

                let sh = select(0, ih, ih > 0);
                let sw = select(0, iw, iw > 0);
                let eh = select(${s}, ih + ${c}, ih + ${c} < ${s});
                let ew = select(${u}, iw + ${p}, iw + ${p} < ${u});

                var out4: vec4<${a}> = vec4(0.0);
                for (var kh = 0; kh < ${c}; kh++) {
                    if (ih + kh < 0 || ih + kh >=${s}) {
                        continue;
                    }
                    for (var kw = 0; kw < ${p}; kw++) {
                        if (iw + kw < 0 || iw + kw >= ${u}){
                            continue;
                        }
                        out4 += input[getInputIndexFromCoord(on, ih + kh, iw + kw, oc4)];
                    }
                }
                let div: vec4<${a}> = vec4<${a}>(f32(eh - sh) * f32(ew - sw));
                output[index] = out4 / div;
            }
            `
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    s.WebGPUOps.register( (e, t) => new u(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Pooling)
                }
                ,
                9676: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUOps = void 0;
                    let r = new Map;
                    t.WebGPUOps = class {
                        static register(e, t) {
                            r.set(t, e)
                        }
                        static builder(e) {
                            return r.get(e.constructor)
                        }
                    }
                }
                ,
                9960: (e, t, r) => {
                    let i = r(9120)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScript(e, t) {
                            let r = t.storage.layout
                              , i = n.getGpuType(t.type)
                              , o = this.operator;
                            return `
        fn start() {
            let index = getGlobalIndex();
            if (index >= ${r.getReorderedVec4Size()}) {
                return;
            }
            let in4 = input[index];
            let out4 =  ${0 == o.max ? `max(vec4<${i}>(0.0), in4)` : `max(vec4<${i}>(0.0), min(in4, vec4<${i}>(${o.max})))`};
            output[index] = out4;
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.ReLU)
                }
                ,
                5010: (e, t, r) => {
                    let i = r(9120)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScript(e, t) {
                            t.storage.layout;
                            let r = n.getGpuType(t.type)
                              , i = this.operator;
                            return `
        fn start() {
            let index = getGlobalIndex();
            let in4 = input[index];
            let out4 =  ${0 == i.max ? `max(vec4<${r}>(0.0), in4)` : `max(vec4<${r}>, min(in4, ${r}(${i.max})))`};
            output[index] = out4;
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Reshape)
                }
                ,
                8641: (e, t, r) => {
                    let i = r(8024)
                      , n = r(4284)
                      , o = r(8448)
                      , a = r(4064)
                      , s = r(9676);
                    class u extends a.WebGPUKernel {
                        constructor() {
                            super(...arguments),
                            this.uniforms = [{
                                name: "outputStrides",
                                type: i.DataType.Int32,
                                data: []
                            }, {
                                name: "scaleStrides",
                                type: i.DataType.Int32,
                                data: []
                            }, {
                                name: "size",
                                type: i.DataType.Int32,
                                data: []
                            }],
                            this.tensorNames = ["input", "scale", "output"]
                        }
                        getScript(e) {
                            let t = this.operator;
                            return new o.SeScaleFunction(e.type,t.relu_term).getFunctionScript("start")
                        }
                        resize(e, t) {
                            if (this.uniforms[0].data = t[0].storage.layout.getStrides(),
                            this.uniforms[1].data = e[1].storage.layout.getStrides(),
                            this.uniforms[2].data = [t[0].storage.layout.getReorderedVec4Size()],
                            !this.computePipeline) {
                                let r = this.getScript(t[0]);
                                this.createPipelineByUserCode(r, [e[0], e[1], t[0]], this.tensorNames, [...this.uniforms]),
                                console.log(this.programCode)
                            }
                            this.bindGroup = void 0
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], e[1], t[0]], r, this.uniforms)
                        }
                    }
                    s.WebGPUOps.register( (e, t) => new u(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), n.SEScale)
                }
                ,
                3670: (e, t, r) => {
                    let i = r(9120)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScriptChannel(e, t) {
                            t.storage.layout;
                            let r = e.storage.layout
                              , i = n.getGpuType(t.type)
                              , [,,,o] = (this.operator,
                            e.shape.dims)
                              , a = Math.ceil(o / 4)
                              , s = o - 4 * Math.floor(o / 4);
                            return `
        ${r.scriptCoordToIndex("getInputIndexFromCoord")}
        ${r.scriptIndexToCoords("getOutputCoordFromIndex")}
        fn start() {
            let index: i32 = getGlobalIndex();
            let coord = getOutputCoordFromIndex(index);
            let on = coord[0];
            let oh = coord[1];
            let ow = coord[2];
            let oc4 = coord[3];
            var max4: vec4<f32> = vec4(-99999999.0);
            var sum4: vec4<f32> = vec4(0.0);
            let rc: i32 = ${s};
            for (var ic4 = 0; ic4 < ${a - 1}; ic4++) {
                let inVal = vec4<f32>(input[getInputIndexFromCoord(on, oh, ow, ic4)]);
                max4 = max(max4, inVal);
                sum4 += exp(inVal);
            }
            var max1: f32 = max(max(max4.x, max4.y), max(max4.z, max4.w));
            var sum1: f32 = sum4.x + sum4.y + sum4.z + sum4.w;
            let last4: vec4<f32> = vec4<f32>(input[getInputIndexFromCoord(on, oh, ow, ${a - 1})]);
            let last4Exp = exp(last4);
            switch rc {
                case 0: {
                    max1 = max(max1, last4.x);
                    sum1 += last4Exp.x + last4Exp.y + last4Exp.z + last4Exp.w;
                    break;
                }
                case 3: {
                    max1 = max(max1, last4.z);
                    sum1 += last4Exp.x + last4Exp.y + last4Exp.z;
                    break;
                }
                case 2: {
                    max1 = max(max1, last4.y);
                    sum1 += last4Exp.x + last4Exp.y;
                    break;
                }
                case 1: {
                    max1 = max(max1, last4.x);
                    sum1 += last4Exp.x;
                    break;
                }
                default: {}
            }
            let in4: vec4<f32> = vec4<f32>(input[index]);
            output[index] = vec4<${i}>(exp(in4) / sum1);
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScriptChannel(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Softmax)
                }
                ,
                1618: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUTranspose = void 0;
                    let i = r(8024)
                      , n = r(8313)
                      , o = r(1649)
                      , a = r(4064)
                      , s = r(9676);
                    class u extends a.WebGPUKernel {
                        constructor() {
                            super(...arguments),
                            this.uniforms = [{
                                name: "inputStrides",
                                type: i.DataType.Int32,
                                data: []
                            }, {
                                name: "outputStrides",
                                type: i.DataType.Int32,
                                data: []
                            }, {
                                name: "outputSize",
                                type: i.DataType.Int32,
                                data: []
                            }]
                        }
                        getScript(e, t) {
                            let r = this.operator;
                            return `
        ${new o.TransposeFunction(t.type,r.dims).getFunctionScript("transpose")}
        fn start() {
            let index = getGlobalIndex();
            transpose(index);
        }
        `
                        }
                        resize(e, t) {
                            if (this.uniforms[0].data = e[0].storage.layout.getStrides(),
                            this.uniforms[1].data = t[0].storage.layout.getStrides(),
                            this.uniforms[2].data = [t[0].storage.layout.getReorderedVec4Size()],
                            !this.computePipeline) {
                                let r = this.getScript(e[0], t[0])
                                  , i = ["input", "output"];
                                this.createPipelineByUserCode(r, [e[0], t[0]], i, [...this.uniforms])
                            }
                            this.bindGroup = void 0
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r, this.uniforms)
                        }
                    }
                    t.WebGPUTranspose = u,
                    s.WebGPUOps.register( (e, t) => new u(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), n.Transpose)
                }
                ,
                2124: (e, t, r) => {
                    let i = r(6650)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getUnaryScript(e, t) {
                            switch (e) {
                            case i.UnaryType.Tanh:
                                return `(exp(${t}) - exp(-${t})) / (exp(${t}) + exp(-${t}))`;
                            case i.UnaryType.Exp:
                                return `exp(${t})`;
                            case i.UnaryType.Sigmoid:
                                return `1.0 / (1.0 + exp(-${t}))`;
                            case i.UnaryType.Erf:
                                return `erf(${t})`;
                            case i.UnaryType.HardSigmoid:
                                return `hard_sigmoid(${t})`;
                            case i.UnaryType.ReluHardSigmoid:
                                return `max(vec4<f32>(0.0), min(${t} + 4.0, vec4<f32>(8.0))) / vec4<f32>(8.0)`;
                            case i.UnaryType.HardSwish:
                                return `hard_swish(${t})`;
                            case i.UnaryType.ReluHardSwish:
                                return `${t} * max(vec4<f32>(0.0), min(${t} + 4.0, vec4<f32>(8.0))) / vec4<f32>(8.0)`;
                            case i.UnaryType.Abs:
                                return `abs(${t})`;
                            case i.UnaryType.Ceil:
                                return `ceil(${t})`;
                            case i.UnaryType.Floor:
                                return `floor(${t})`;
                            case i.UnaryType.Log:
                                return `log(${t})`;
                            case i.UnaryType.Neg:
                                return `vec4(-1.0) * ${t}`;
                            case i.UnaryType.Sqrt:
                                return `sqrt(${t})`;
                            case i.UnaryType.Softplus:
                                return `log(exp(${t}) + vec4<f32>(1.0))`;
                            case i.UnaryType.Softsign:
                                return `${t} / (vec4<f32>(1.0) + abs(${t}))`;
                            default:
                                throw Error("Unary op not supported: " + e)
                            }
                        }
                        genScriptByType(e, t) {
                            switch (e) {
                            case i.UnaryType.Erf:
                                return "const M_PI: f32 = 3.1415926535;\n    const a: f32 = 8.0 * (M_PI - 3.0) / (3.0 * M_PI * (4.0 - M_PI));\n    fn erf_guts(x: vec4<f32>) -> vec4<f32>  {\n        let x2: vec4<f32> = x * x;\n        return exp(-x2 * (vec4<f32>(4.0) / vec4<f32>(M_PI) + vec4<f32>(a) * x2) / (vec4<f32>(1.0) + vec4<f32>(a) * x2));\n    }\n    fn erf(x: vec4<f32>) -> vec4<f32> {\n        let cond: vec4<f32> = step(vec4(0.0), x);\n        let sign: vec4<f32> = vec4(2.0) * cond - vec4(1.0);\n        return sign * sqrt(vec4<f32>(1.0) - erf_guts(x));\n    }";
                            case i.UnaryType.HardSigmoid:
                                return "\n    fn hard_sigmoid(x: vec4<f32>) -> vec4<f32>  {\n        let cond1 = step(x, vec4(-3.0));\n        let cond2 = step(vec4(3.0), x);\n        let one = vec4(1.0);\n        let six = vec4(6.0);\n        let half_one = vec4(0.5);\n        return (one - cond1) * (one - cond2) * x / six + half_one + cond2;\n    }";
                            case i.UnaryType.HardSwish:
                                return "\n    fn hard_swish(x: vec4<f32>) -> vec4<f32>  {\n        let cond1 = step(x, vec4(-3.0));\n        let cond2 = step(vec4(3.0), x);\n        let one = vec4(1.0);\n        let three = vec4(3.0);\n        let six = vec4(6.0);\n        return (one - cond1) * (one - cond2) * x * (x + three) / six + cond2 * x;\n    }";
                            default:
                                return ""
                            }
                        }
                        getScript(e, t) {
                            let r = this.operator
                              , i = (this.context,
                            t.storage.layout)
                              , o = n.getGpuType(t.type);
                            return `
        ${i.scriptCoordToIndex("getOutputCoordByIndex")}
        ${i.scriptIndexToCoords("getOutputIndexByCoord")}
        ${this.genScriptByType(r.type, o)}
        fn start() {
            let index = getGlobalIndex();
            let in: vec4<${o}> = vec4<${o}>(input[index]);
            let d = ${this.getUnaryScript(r.type, "in")};
            output[index] = d;
        }
        `
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.Unary)
                }
                ,
                9744: (e, t, r) => {
                    let i = r(642)
                      , n = r(8960)
                      , o = r(4064)
                      , a = r(9676);
                    class s extends o.WebGPUKernel {
                        getScript(e, t) {
                            let r = this.operator
                              , o = (this.context,
                            e.storage.layout)
                              , a = t.storage.layout
                              , [,s,u] = e.shape.dims
                              , l = 1 / r.scale
                              , c = 1 / r.scale
                              , p = (r.scale,
                            r.scale,
                            n.getGpuType(t.type))
                              , d = a.getReorderedVec4Size();
                            if (r.mode == i.UpSamplingMode.Bilinear)
                                return `
            ${a.scriptIndexToCoords("getOutputCoordByIndex")}
            ${a.scriptCoordToIndex("getOutputIndexByCoord")}
            ${o.scriptCoordToIndex("getInputIndexByCoord")}

            fn start() {
                let index: i32 = getGlobalIndex();
                if (index > ${d}) {
                    return;
                }
                let coord: vec4<i32> = getOutputCoordByIndex(index);
                let on: i32 = coord.x;
                let oh: i32 = coord.y;
                let ow: i32 = coord.z;
                let oc4: i32 = coord.w;

                var fh: f32 = min(max(0.0, (f32(oh) + 0.5) * ${l} - 0.5), ${s}f - 1);
                let sh: i32 = i32(floor(fh));
                fh -= f32(sh);

                var fw: f32 = min(max(0.0, (f32(ow) + 0.5) * ${c} - 0.5), ${u}f - 1);
                let sw: i32 = i32(floor(fw));
                fw -= f32(sw);

                let p1: f32 = (1.0 - fw) * (1.0 - fh);
                let p2: f32 = (1.0 - fw) * fh;
                let p3: f32 = fw * (1.0 - fh);
                let p4: f32 = fw * fh;

                let b1: vec4<f32> = input[getInputIndexByCoord(on, sh, sw, oc4)];
                let b2: vec4<f32> = input[getInputIndexByCoord(on, sh + 1, sw, oc4)];
                let b3: vec4<f32> = input[getInputIndexByCoord(on, sh, sw + 1, oc4)];
                let b4: vec4<f32> = input[getInputIndexByCoord(on, sh + 1, sw + 1, oc4)];
                let out4: vec4<f32> = b1 * p1 + b2 * p2 + b3 * p3 + b4 * p4;
                output[index] = vec4<${p}>(out4);
            }
            `;
                            if (r.mode === i.UpSamplingMode.Linear)
                                return `
            ${a.scriptIndexToCoords("getOutputCoordByIndex")}
            ${a.scriptCoordToIndex("getOutputIndexByCoord")}
            ${o.scriptCoordToIndex("getInputIndexByCoord")}

            fn start() {
                let index: i32 = getGlobalIndex();
                let coord: vec4<i32> = getOutputCoordByIndex(index);
                let on: i32 = coord.x;
                let oh: i32 = coord.y;
                let ow: i32 = coord.z;
                let oc4: i32 = coord.w;

                var fh: f32 = (f32(oh) + 0.5) * ${l} - 0.5;
                let sh: i32 = i32(floor(fh));
                fh -= f32(sh);

                var fw: f32 = (f32(ow) + 0.5) * ${c} - 0.5;
                let sw: i32 = i32(floor(fw));
                fw -= f32(sw);

                let p1: f32 = (1.0 - fw) * (1.0 - fh);
                let p2: f32 = (1.0 - fw) * fh;
                let p3: f32 = fw * (1.0 - fh);
                let p4: f32 = fw * fh;

                let id1 = getInputIndexByCoord(on, sh, sw, oc4);
                let id2 = getInputIndexByCoord(on, sh + 1, sw, oc4);
                let id3 = getInputIndexByCoord(on, sh, sw + 1, oc4);
                let id4 = getInputIndexByCoord(on, sh + 1, sw + 1, oc4);

                let b1: vec4<f32> = select(input[getInputIndexByCoord(on, sh, sw, oc4)], vec4(0f), sh < 0 || sw < 0);
                let b2: vec4<f32> = select(input[getInputIndexByCoord(on, sh + 1, sw, oc4)], vec4(0f), sh > ${s - 2} || sw < 0);
                let b3: vec4<f32> = select(input[getInputIndexByCoord(on, sh, sw + 1, oc4)], vec4(0f), sh < 0 || sw > ${u - 2});
                let b4: vec4<f32> = select(input[getInputIndexByCoord(on, sh + 1, sw + 1, oc4)], vec4(0f), sh > ${s - 2} || sw > ${u - 2});

                let out4: vec4<f32> = b1 * p1 + b2 * p2 + b3 * p3 + b4 * p4;
                output[index] = vec4<${p}>(out4);
            }
            `;
                            if (r.mode == i.UpSamplingMode.Nearest)
                                return `
            ${a.scriptIndexToCoords("getOutputCoordByIndex")}
            ${a.scriptCoordToIndex("getOutputIndexByCoord")}
            ${o.scriptCoordToIndex("getInputIndexByCoord")}

            fn start() {
                let index: i32 = getGlobalIndex();
                let coord: vec4<i32> = getOutputCoordByIndex(index);
                let on: i32 = coord.x;
                let oh: i32 = coord.y;
                let ow: i32 = coord.z;
                let oc4: i32 = coord.w;

                var fh: f32 = select(f32(oh) * f32(${l}), (f32(oh) + 0.5) * ${l} - 0.5, ${r.halfPixel});

                var fw: f32 = select(f32(ow) * f32(${c}), (f32(ow) + 0.5) * ${c} - 0.5, ${r.halfPixel});

                output[index] = vec4<${p}>(input[getInputIndexByCoord(on, i32(floor(fh)), i32(floor(fw)), oc4)]);
            }
            `;
                            throw Error("Not Supported Interpolation Method " + r.mode)
                        }
                        resize(e, t) {
                            let r = this.getScript(e[0], t[0]);
                            this.createPipelineByUserCode(r, [e[0], t[0]], ["input", "output"])
                        }
                        execute(e, t) {
                            let r = this.getDispathGridSize(t[0]);
                            this.executePipeline([e[0], t[0]], r)
                        }
                    }
                    a.WebGPUOps.register( (e, t) => new s(e,t,{
                        workgroupSize: [256, 1, 1],
                        dispathLayout: {
                            x: [0, 1, 2, 3]
                        }
                    }), i.UpSampling)
                }
                ,
                6484: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPULayout = void 0;
                    class r {
                        constructor(e, t=!0) {
                            this.shape = e,
                            this.isVec4 = t,
                            this.strides = this.getStrides(),
                            this.component = t ? 4 : 1
                        }
                        getStrides() {
                            let e = this.shape.dims.length;
                            if (e < 2)
                                return [];
                            let t = Array(e - 1)
                              , r = [...this.shape.dims];
                            this.isVec4 && (r[r.length - 1] = 4 * Math.ceil(r[r.length - 1] / 4)),
                            t[e - 2] = r[e - 1];
                            for (let i = e - 3; i >= 0; --i)
                                t[i] = t[i + 1] * r[i + 1];
                            return t
                        }
                        getStridesByBatch(e, t) {
                            let r = this.shape.dims.length;
                            if (r < 2)
                                return [];
                            let i = Array(r - 1)
                              , n = [...this.shape.dims];
                            n[t] = Math.floor(n[t] / e),
                            this.isVec4 && (n[n.length - 1] = 4 * Math.ceil(n[n.length - 1] / 4)),
                            i[r - 2] = n[r - 1];
                            for (let e = r - 3; e >= 0; --e)
                                i[e] = i[e + 1] * n[e + 1];
                            return i
                        }
                        scriptCoordToIndex(e, t) {
                            switch (this.shape.dims.length) {
                            case 0:
                            case 1:
                                return `
            fn ${e}(x: i32) -> i32 {
                ${this.isVec4 ? "return i32(floor(f32(x) / 4.0));" : "return x;"}
            }
            `;
                            case 2:
                                return `
            fn ${e}(x: i32, y: i32) -> i32 {
                let index = dot(vec2<i32>(x, y), vec2<i32>(${this.strides[0]}, 1));
                ${this.isVec4 ? "return i32(floor(f32(index) / 4.0));" : "return index;"}
            }
            `;
                            case 3:
                                return `
            fn ${e}(x: i32, y: i32, z: i32) -> i32 {
                let index = dot(vec3<i32>(x, y, z), vec3<i32>(${this.strides[0]}, ${this.strides[1]} , 1));
                ${this.isVec4 ? "return i32(floor(f32(index) / 4.0));" : "return index;"}
            }
            `;
                            case 4:
                                return `
            fn ${e}(x: i32, y: i32, z: i32, w: i32) -> i32 {
                let index = dot(vec4<i32>(x, y, z, w * ${this.component}), vec4<i32>(${this.strides[0]}, ${this.strides[1]}, ${this.strides[2]}, 1));
                ${this.isVec4 ? "return i32(floor(f32(index) / 4.0));" : "return index;"}
            }
            `;
                            default:
                                throw TypeError(`Unsupported shape dimension ${this.shape.dims.length}`)
                            }
                        }
                        static getCoordsDesc(e) {
                            if (e <= 1)
                                return "i32";
                            if (2 === e)
                                return "vec2<i32>";
                            if (3 === e)
                                return "vec3<i32>";
                            if (4 === e)
                                return "vec4<i32>";
                            if (5 === e)
                                return "vec5";
                            if (6 === e)
                                return "vec6";
                            throw Error(`GPU for rank ${e} is not yet supported`)
                        }
                        scriptIndexToCoords(e) {
                            let t = this.shape.dims.length
                              , i = [...this.shape.dims].map( (e, t) => `d${t}`);
                            if (t <= 1)
                                return `fn ${e}(index : i32) -> i32 { return index; }`;
                            if (2 == t)
                                return `
            fn ${e}(index : i32) -> vec2<i32> {
                let n0 = index / ${this.strides[0]};
                let n1 = index - n0 * ${this.strides[0]};
                return vec2<i32>(n0, n1);
            }
            `;
                            let n = this.strides.map( (e, t) => `
            let ${i[t]} = index_temp / ${this.strides[t]};
            index_temp = index_temp - ${i[t]} * ${this.strides[t]};
            `)
                              , o = r.getCoordsDesc(t);
                            return `
        fn ${e}(index: i32) -> ${o} {
            var index_temp = ${this.isVec4 ? "index * 4;" : "index;"};
            ${n.join("")}
            let ${i[t - 1]} = ${this.isVec4 ? "index_temp / 4;" : "index;"}
            return ${o}(${i.join(",")});
        }
        `
                        }
                        scriptIndexToCoordsByBatch(e, t=4, i=2) {
                            let n = this.shape.dims.length
                              , o = [...this.shape.dims].map( (e, t) => `d${t}`)
                              , a = this.getStridesByBatch(t, i);
                            if (n <= 1)
                                return `fn ${e}(index : i32) -> i32 { return index; }`;
                            if (2 == n)
                                return `
            fn ${e}(index : i32) -> vec2<i32> {
                let n0 = index / ${a[0]};
                let n1 = index - n0 * ${a[0]};
                return vec2<i32>(n0, n1);
            }
            `;
                            let s = a.map( (e, t) => `
            let ${o[t]} = index_temp / ${a[t]};
            index_temp = index_temp - ${o[t]} * ${a[t]};
            `)
                              , u = r.getCoordsDesc(n);
                            return `
        fn ${e}(index: i32) -> ${u} {
            var index_temp = ${this.isVec4 ? "index * 4;" : "index;"};
            ${s.join("")}
            let ${o[n - 1]} = ${this.isVec4 ? "index_temp / 4;" : "index;"}
            return ${u}(${o.join(",")});
        }
        `
                        }
                        reorderVec4ArrayAsData(e) {
                            let t = [...this.shape.dims]
                              , r = t.slice(0, -1).reduce( (e, t) => e * t, 1)
                              , i = t[t.length - 1]
                              , n = 4 * Math.ceil(i / 4);
                            if (i == n)
                                return e;
                            let o = new e.constructor(r * i);
                            for (let t = 0; t < r; t++)
                                o.set(e.subarray(t * n, t * n + i), t * i);
                            return o
                        }
                        reorderDataToVec4Arr(e) {
                            let t = [...this.shape.dims]
                              , r = t.slice(0, -1).reduce( (e, t) => e * t, 1)
                              , i = t[t.length - 1]
                              , n = 4 * Math.ceil(i / 4);
                            if (i == n)
                                return e;
                            let o = new e.constructor(r * n).fill(0);
                            for (let t = 0; t < r; t++)
                                o.set(e.subarray(t * i, t * i + i), t * n);
                            return o
                        }
                        getReorderedVec4Size() {
                            let e = [...this.shape.dims]
                              , t = e.slice(0, -1).reduce( (e, t) => e * t, 1);
                            return t * Math.ceil(e[e.length - 1] / 4)
                        }
                        getReorderedVec4ElementSize() {
                            let e = [...this.shape.dims]
                              , t = e.slice(0, -1).reduce( (e, t) => e * t, 1);
                            return 4 * Math.ceil(e[e.length - 1] / 4) * t
                        }
                    }
                    t.WebGPULayout = r
                }
                ,
                8960: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.getProgramCode = t.getIndexSnippet = t.getIndexFromCoordScript = t.getCoordFromIndexScript = t.getBindingSnippets = t.dataTypeSnippet = t.dataCompSnippet = t.computeDispathSize = t.getGpuType = void 0;
                    let i = r(7693);
                    t.getGpuType = e => {
                        if (e === i.DataType.Int32)
                            return "i32";
                        if (e === i.DataType.Float32)
                            return "f32";
                        if (e)
                            throw TypeError(`data type ${e} is not supported`);
                        return "f32"
                    }
                    ,
                    t.computeDispathSize = (e, t, r) => [Math.ceil(t[0] / r[0]), Math.ceil(t[1] / r[1]), Math.ceil(t[2] / r[2])],
                    t.dataCompSnippet = (e, t="f32") => {
                        switch (e) {
                        case 1:
                            return `${t}`;
                        case 2:
                            return `vec2<${t}>`;
                        case 3:
                            return `vec3<${t}>`;
                        case 4:
                            return `vec4<${t}>`;
                        default:
                            throw Error(`${e}-component ${t} is not supported.`)
                        }
                    }
                    ,
                    t.dataTypeSnippet = (e, r) => {
                        let i = t.getGpuType(e);
                        return t.dataCompSnippet(r, i)
                    }
                    ,
                    t.getBindingSnippets = (e, r, i=[]) => {
                        let n = [];
                        for (let i = 0; i < e.length; i++) {
                            let o = e[i].type;
                            n.push(`@group(0) @binding(${i}) var<storage, read_write> ${r[i]}: array<${t.dataTypeSnippet(o, 4)}>;`)
                        }
                        return i?.length && (n.push(`
        struct Uniform {
            ${i.map( (e, r) => `
            ${e.name}: ${t.dataTypeSnippet(e.type, e.data.length)}`).join(",")}
        };
        `),
                        n.push(`@group(0) @binding(${e.length}) var<uniform> uniforms: Uniform;`)),
                        n.join("\n")
                    }
                    ,
                    t.getCoordFromIndexScript = (e, r=4) => {
                        if (1 == e)
                            return "\n        fn getCoordFromIndexDim1(index: i32) -> i32 {\n            return index;\n        }\n        ";
                        if (2 == e)
                            return "\n        fn getCoordFromIndexDim2(index : i32, stride: i32) -> vec2<i32> {\n            let n0 = index / stride;\n            let n1 = index - n0 * stride;\n            return vec2<i32>(n0, n1);\n        }\n        ";
                        let n = Array(e).fill(0).map( (e, t) => `d${t}`)
                          , o = Array(e - 1).fill(0).map( (e, t) => `
        var ${n[t]} = index_temp / strides[${t}];
        index_temp = index_temp - ${n[t]} * strides[${t}];
        `);
                        return `
    fn getCoordFromIndexDim${e}(index : i32, strides: ${t.dataTypeSnippet(i.DataType.Int32, e - 1)}) -> vec${e}<i32> {
        var index_temp = ${r > 1 ? `index * ${r};` : "index;"}
        ${o.join("")}
        let ${n[e - 1]} = ${r > 1 ? `index_temp / ${r};` : "index;"}
        return ${t.dataTypeSnippet(i.DataType.Int32, e)}(${n.join(",")});
    }
    `
                    }
                    ,
                    t.getIndexFromCoordScript = (e=4) => `
    fn getIndexFromCoordDim1(x: i32) -> i32 {
        ${e > 1 ? `return i32(floor(f32(x) / ${e}));` : "return x;"}
    }
    fn getIndexFromCoordDim2(x: i32, y: i32, strides: i32) -> i32 {
        let index = dot(vec2<i32>(x, y), vec2<i32>(strides, 1));
        ${e > 1 ? `return i32(floor(f32(index) / ${e}));` : "return index;"}
    }
    fn getIndexFromCoordDim3(x: i32, y: i32, z: i32, strides: vec2<i32>) -> i32 {
        let index = dot(vec3<i32>(x, y, z * ${e}), vec3<i32>(strides.x, strides.y, 1));
        ${e > 1 ? `return i32(floor(f32(index) / ${e}));` : "return index;"}
    }
    fn getIndexFromCoordDim4(x: i32, y: i32, z: i32, w: i32, strides: vec3<i32>) -> i32 {
        let index = dot(vec4<i32>(x, y, z, w * ${e}), vec4<i32>(strides.x, strides.y, strides.z, 1));
        ${e > 1 ? `return i32(floor(f32(index) / ${e}));` : "return index;"}
    }
    `,
                    t.getIndexSnippet = e => `
    fn getGlobalIndex() -> i32 {
        return i32((workgroupId.x + workgroupId.y * numWorkgroups.x + workgroupId.z * numWorkgroups.x * numWorkgroups.y) * ${e[0] * e[1] * e[2]} + localIndex);
    }
    `,
                    t.getProgramCode = (e, r, i, n, o=[]) => `

    ${t.getBindingSnippets(r, i, o)}
    ${t.getIndexSnippet(n)}

    ${t.getIndexFromCoordScript()}
    ${t.getCoordFromIndexScript(1)}
    ${t.getCoordFromIndexScript(2)}
    ${t.getCoordFromIndexScript(3)}
    ${t.getCoordFromIndexScript(4)}

    var<private> localId: vec3<u32>;
    var<private> localIndex: u32;
    var<private> globalId: vec3<u32>;
    var<private> numWorkgroups: vec3<u32>;
    var<private> workgroupId: vec3<u32>;

    ${e}
    @compute @workgroup_size(${n[0]}, ${n[1]}, ${n[2]})
    fn main(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(local_invocation_index) LocalIndex: u32,
              @builtin(workgroup_id) WorkgroupId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {

        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        start();
    }
    `
                }
                ,
                2332: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.WebGPUStorage = void 0;
                    let i = r(7693);
                    t.WebGPUStorage = class {
                        constructor(e, t, r, n, o, a, s=!0) {
                            this.context = e,
                            this.bufferId = t,
                            this.buffer = r,
                            this.layout = n,
                            this.type = o,
                            this.size = a,
                            this.owned = s,
                            this.byteLength = this.size * i.bytesForDataType(o)
                        }
                        download() {
                            return this.context.readStorageSync(this)
                        }
                        async asyncDownload() {
                            return await this.context.readStorage(this)
                        }
                    }
                }
                ,
                7693: (e, t) => {
                    var r;
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.bytesForDataType = t.typedArrayGetType = t.typedArrayWithData = t.DataType = t.DataFormat = void 0,
                    function(e) {
                        e[e.NCHW = 0] = "NCHW",
                        e[e.NHWC = 1] = "NHWC"
                    }(t.DataFormat || (t.DataFormat = {})),
                    function(e) {
                        e[e.Uint8 = 0] = "Uint8",
                        e[e.Int8 = 1] = "Int8",
                        e[e.Int16 = 2] = "Int16",
                        e[e.Uint16 = 3] = "Uint16",
                        e[e.Float32 = 4] = "Float32",
                        e[e.Float16 = 5] = "Float16",
                        e[e.Float64 = 6] = "Float64",
                        e[e.Int32 = 7] = "Int32",
                        e[e.Uint32 = 8] = "Uint32",
                        e[e.U8 = 0] = "U8",
                        e[e.Float = 4] = "Float",
                        e[e.Fp16 = 5] = "Fp16",
                        e[e.Double = 6] = "Double"
                    }(r = t.DataType || (t.DataType = {})),
                    t.typedArrayWithData = function(e, t, i, n) {
                        switch (e) {
                        case r.Uint8:
                            return i ? new Uint8Array(t,i,n) : new Uint8Array(t);
                        case r.Uint16:
                            return i ? new Uint16Array(t,i,n) : new Uint16Array(t);
                        case r.Int8:
                            return i ? new Int8Array(t,i,n) : new Int8Array(t);
                        case r.Int16:
                            return i ? new Int16Array(t,i,n) : new Int16Array(t);
                        case r.Float32:
                            return i ? new Float32Array(t,i,n) : new Float32Array(t);
                        case r.Float64:
                            return i ? new Float64Array(t,i,n) : new Float64Array(t);
                        case r.Int32:
                            return i ? new Int32Array(t,i,n) : new Int32Array(t);
                        default:
                            throw Error(`invalid data type ${e}.`)
                        }
                    }
                    ,
                    t.typedArrayGetType = function(e) {
                        switch (e.constructor) {
                        case Uint8Array:
                            return r.Uint8;
                        case Uint16Array:
                            return r.Uint16;
                        case Int8Array:
                            return r.Int8;
                        case Int16Array:
                            return r.Int16;
                        case Float32Array:
                            return r.Float32;
                        case Float64Array:
                            return r.Float64;
                        default:
                            throw Error(`invalid typed array ${e.constructor}}`)
                        }
                    }
                    ,
                    t.bytesForDataType = function(e) {
                        switch (e) {
                        case r.Uint8:
                            return Uint8Array.BYTES_PER_ELEMENT;
                        case r.Int8:
                            return Int8Array.BYTES_PER_ELEMENT;
                        case r.Uint16:
                            return Uint16Array.BYTES_PER_ELEMENT;
                        case r.Int16:
                            return Int16Array.BYTES_PER_ELEMENT;
                        case r.Float32:
                            return Float32Array.BYTES_PER_ELEMENT;
                        case r.Float64:
                            return Float64Array.BYTES_PER_ELEMENT;
                        default:
                            throw Error(`invalid data type ${e}}`)
                        }
                    }
                }
                ,
                7033: (e, t, r) => {
                    t.Engine = void 0;
                    let i = r(5559)
                      , n = r(2810)
                      , o = r(2758)
                      , a = r(5249);
                    class s {
                        constructor() {
                            this.inputTensors = [],
                            this.outputTensors = [],
                            this.inplaceKernels = {},
                            this.inputKernelMap = {},
                            this.outputKernelMap = {},
                            this.tensorMap = {},
                            this.sourceTensorMap = {},
                            this.sequentialExcludeDatas = [],
                            this.enabledStorageReusing = !0,
                            this.refCountTemplate = {},
                            this.ops = []
                        }
                        init(e, t=!0) {
                            if (this.config = e,
                            this.inputTensors = e.inputNames,
                            this.outputTensors = e.outputNames,
                            !t)
                                return o.ErrCode.NO_ERROR;
                            let r = e.parser.parse(e.model);
                            return this.ops = r,
                            this.build(r, e.devices)
                        }
                        addOp(e) {
                            return this.ops.push(e),
                            o.ErrCode.NO_ERROR
                        }
                        buildGraph() {
                            return this.config ? this.build(this.ops, this.config.devices) : o.ErrCode.NULL_POINTER
                        }
                        dispose() {
                            for (let e of Object.values(this.tensorMap)) {
                                let t = e.storage;
                                t && t.context.release(e)
                            }
                            for (let e of new Set([...Object.values(this.inputKernelMap), ...Object.values(this.outputKernelMap)]))
                                e.dispose()
                        }
                        reInferShape(e, t, r=0) {
                            let n = this.inputTensors[r]
                              , o = this.outputKernelMap[n];
                            o.operator.reshape(e, t),
                            n || console.error(`invalid index ${r}`);
                            let a = this.mapTensors(o.operator.outputs);
                            for (let e of (i.OpShaper.reshape(o.operator, [], a) && (o.context.alloc(a[0]),
                            this.resizeKernel(o, [], a)),
                            this.sequentialExcludeDatas)) {
                                let t = e.operator
                                  , r = e.unify(this.mapTensors(t.inputs))
                                  , n = this.mapTensors(t.outputs);
                                i.OpShaper.reshape(t, r, n),
                                t.inplace || n.forEach(t => e.context.alloc(t)),
                                e.resize(r, n)
                            }
                        }
                        schedule(e) {
                            return e
                        }
                        build(e, t) {
                            let r = this.schedule(e)
                              , s = []
                              , u = {}
                              , l = {}
                              , c = {}
                              , p = {}
                              , d = (e, t) => [...new Set(e.map(e => t[e]))];
                            for (let e of (console.log(this),
                            "undefined" != typeof window && (window.engine = this),
                            r)) {
                                let r;
                                for (let i of t)
                                    if (r = i.build(e))
                                        break;
                                if (!r)
                                    return n.trace.error( () => `unsupported op is: ${e.name} type: ${e.constructor.name}`),
                                    o.ErrCode.NOT_IMPLEMENTED;
                                if (s.push(r),
                                r.operator.inplace) {
                                    let t = r;
                                    n.trace.assert( () => 1 == t.operator.inputs.length && 1 == t.operator.outputs.length && t.operator.inputs[0] == t.operator.outputs[0]);
                                    let i = d(e.inputs, p)[0].operator.name
                                      , o = l[i];
                                    o || (o = [],
                                    l[i] = o),
                                    o.push(r)
                                }
                                for (let t of e.inputs)
                                    c[t] = r;
                                for (let t of e.outputs)
                                    p[t] = r,
                                    r.operator.inplace ? this.tensorMap && this.tensorMap[t] && (u[t] = this.tensorMap[t]) : u[t] = new a.Tensor
                            }
                            for (let e of s) {
                                let t = d(e.operator.inputs, p)
                                  , r = d(e.operator.outputs, p).filter(t => t != e);
                                e.connect(t, r)
                            }
                            this.tensorMap = u,
                            this.inplaceKernels = l,
                            this.inputKernelMap = c,
                            this.outputKernelMap = p;
                            let f = new Set(this.inputTensors.map(e => p[e]));
                            for (let e of (this.sequentialExcludeDatas = s.filter(e => !f.has(e)),
                            f)) {
                                n.trace.assert( () => 0 == e.operator.inputs.length && 1 == e.operator.outputs.length);
                                let t = this.mapTensors(e.operator.outputs);
                                i.OpShaper.reshape(e.operator, [], t) && (e.context.alloc(t[0]),
                                this.resizeKernel(e, [], t))
                            }
                            for (let e of this.sequentialExcludeDatas) {
                                let t = e.operator
                                  , r = e.unify(this.mapTensors(t.inputs))
                                  , n = this.mapTensors(t.outputs);
                                i.OpShaper.reshape(t, r, n),
                                t.inplace || n.forEach(t => e.context.alloc(t))
                            }
                            if (this.enabledStorageReusing) {
                                let e = {};
                                for (let t of this.sequentialExcludeDatas)
                                    for (let r of t.operator.inputs)
                                        e[r] = (e[r] || 0) + 1;
                                for (let t of [...this.inputTensors, ...this.outputTensors])
                                    delete e[t];
                                this.refCountTemplate = e
                            }
                            return o.ErrCode.NO_ERROR
                        }
                        mapTensors(e) {
                            return e.map(e => this.tensorMap[e])
                        }
                        getTensors(e) {
                            let t = {};
                            for (let r of e) {
                                let e = this.tensorMap[r];
                                e && (t[r] = e)
                            }
                            return t
                        }
                        getSourceData(e) {
                            let t = {};
                            for (let r of e) {
                                let e = this.sourceTensorMap[r];
                                e && (t[r] = e)
                            }
                            return t
                        }
                        getInputs() {
                            return this.getTensors(this.inputTensors)
                        }
                        getSourceOutputs() {
                            return this.getSourceData(this.outputTensors)
                        }
                        getSourceInputs() {
                            return this.getSourceData(this.inputTensors)
                        }
                        getOutputs() {
                            return this.getTensors(this.outputTensors)
                        }
                        setInputs(e) {
                            for (let t in e) {
                                if (!this.inputTensors.includes(t)) {
                                    console.error(`invalid tensor name: ${t}. availables: ${this.inputTensors.join(",")}`);
                                    continue
                                }
                                let r = this.outputKernelMap[t];
                                r && r.setData(this.tensorMap[t], e[t]);
                                let i = this.inputKernelMap[t];
                                i && this.enabledStorageReusing && this.mapTensors(i.operator.outputs)
                            }
                            return o.ErrCode.NO_ERROR
                        }
                        setOutputs(e) {
                            for (let t in e) {
                                if (!this.outputTensors.includes(t)) {
                                    console.error(`invalid tensor name: ${t}. availables: ${this.outputTensors.join(",")}`);
                                    continue
                                }
                                let r = e[t];
                                this.tensorMap[t] = r,
                                this.outputKernelMap[t].operator.inplace = !0;
                                let i = this.outputKernelMap[t];
                                i.resize(i.operator.inputs.map(e => this.tensorMap[e]), i.operator.outputs.map(e => this.tensorMap[e]))
                            }
                            return o.ErrCode.NO_ERROR
                        }
                        setSourceInputs(e) {
                            for (let t in e)
                                this.inputTensors.includes(t) ? this.sourceTensorMap[t] = e[t] : console.error(`invalid tensor name: ${t}. availables: ${this.inputTensors.join(",")}`);
                            return o.ErrCode.NO_ERROR
                        }
                        setSourceOutputs(e) {
                            for (let t in e)
                                this.outputTensors.includes(t) ? this.sourceTensorMap[t] = e[t] : console.error(`invalid tensor name: ${t}. availables: ${this.outputTensors.join(",")}`);
                            return o.ErrCode.NO_ERROR
                        }
                        resizeKernel(e, t, r) {
                            e.resize(t, r);
                            let i = this.inplaceKernels[e.operator.name];
                            i && i.forEach(e => e.resize(t, r))
                        }
                        inference() {
                            if (this.enabledStorageReusing)
                                for (let e of (Object.assign({}, this.refCountTemplate),
                                this.sequentialExcludeDatas)) {
                                    let t = e.operator
                                      , r = e.unify(this.mapTensors(t.inputs))
                                      , n = this.mapTensors(t.outputs)
                                      , o = i.OpShaper.reshape(t, r, n);
                                    !t.inplace && o && n.forEach(t => {
                                        e.context.release(t),
                                        e.context.alloc(t)
                                    }
                                    ),
                                    !o && e.isInitialized() || this.resizeKernel(e, r, n),
                                    e.execute(r, n)
                                }
                            else
                                for (let e of this.sequentialExcludeDatas) {
                                    let t = e.operator
                                      , r = e.unify(this.mapTensors(t.inputs))
                                      , n = this.mapTensors(t.outputs);
                                    !i.OpShaper.reshape(t, r, n) && e.isInitialized() || (t.inplace || n.forEach(t => e.context.alloc(t)),
                                    this.resizeKernel(e, r, n)),
                                    e.execute(r, n)
                                }
                        }
                    }
                    t.Engine = s,
                    s.version = "0.0.1"
                }
                ,
                2758: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ErrCode = void 0,
                    function(e) {
                        e[e.NO_ERROR = 0] = "NO_ERROR",
                        e[e.ERR_MEMORY_ALLOC = 1] = "ERR_MEMORY_ALLOC",
                        e[e.NOT_IMPLEMENTED = 2] = "NOT_IMPLEMENTED",
                        e[e.ERR_UNEXPECTED = 3] = "ERR_UNEXPECTED",
                        e[e.ERR_DATANOMATCH = 4] = "ERR_DATANOMATCH",
                        e[e.INPUT_DATA_ERROR = 5] = "INPUT_DATA_ERROR",
                        e[e.CALL_BACK_STOP = 6] = "CALL_BACK_STOP",
                        e[e.BACKEND_FALLBACK = 7] = "BACKEND_FALLBACK",
                        e[e.NULL_POINTER = 8] = "NULL_POINTER",
                        e[e.INVALID_POINTER = 9] = "INVALID_POINTER",
                        e[e.INVALID_MODEL = 10] = "INVALID_MODEL",
                        e[e.INFER_SIZE_ERROR = 11] = "INFER_SIZE_ERROR",
                        e[e.NOT_SUPPORT = 12] = "NOT_SUPPORT"
                    }(t.ErrCode || (t.ErrCode = {}))
                }
                ,
                4401: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Kernel = t.Tensor = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    let n = r(5249);
                    Object.defineProperty(t, "Tensor", {
                        enumerable: !0,
                        get: function() {
                            return n.Tensor
                        }
                    }),
                    t.Kernel = class {
                        constructor(e, t) {
                            this.operator = e,
                            this.context = t,
                            this._sources = [],
                            this._targets = []
                        }
                        connect(e, t) {
                            this._sources = e,
                            this._targets = t
                        }
                        resize(e, t) {}
                        init(e, t) {}
                        preInit(e, t) {}
                        isPreInit() {
                            return !1
                        }
                        setData(e, t) {
                            throw Error(`trying to set data to kernel ${this.operator.name} which is NOT a data kernel.`)
                        }
                    }
                }
                ,
                9770: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Shape = void 0;
                    class r {
                        constructor(e, t) {
                            this.format = e,
                            this.dims = t
                        }
                        copy() {
                            return new r(this.format,this._dims)
                        }
                        equals(e) {
                            return !!e && this.format == e.format && this._dims.length == e._dims.length && !this._dims.some( (t, r) => t != e._dims[r])
                        }
                        get dims() {
                            return this._dims
                        }
                        set dims(e) {
                            e instanceof Int32Array ? this._dims = e.slice() : this._dims = e.map(e => ~~e)
                        }
                        stride(e, t) {
                            return [...this._dims.slice(e, t)].reduce( (e, t) => e * t, 1)
                        }
                        get elements() {
                            return this.stride()
                        }
                    }
                    t.Shape = r
                }
                ,
                5249: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Tensor = t.Shape = t.DataType = t.DataFormat = void 0;
                    let i = r(7693);
                    Object.defineProperty(t, "DataFormat", {
                        enumerable: !0,
                        get: function() {
                            return i.DataFormat
                        }
                    }),
                    Object.defineProperty(t, "DataType", {
                        enumerable: !0,
                        get: function() {
                            return i.DataType
                        }
                    });
                    let n = r(9770);
                    Object.defineProperty(t, "Shape", {
                        enumerable: !0,
                        get: function() {
                            return n.Shape
                        }
                    }),
                    t.Tensor = class {
                        constructor(e, t, r) {
                            this.shape = e,
                            this.type = t,
                            this.storage = r,
                            this.fraction = 0
                        }
                        get data() {
                            return this.storage ? this.storage.download() : void 0
                        }
                        download(e) {
                            return this.storage ? this.storage.download(e) : void 0
                        }
                    }
                }
                ,
                7393: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ChannelShuffle = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e?.group && (this.group = e.group),
                            e.shuffle && (this.shuffle = e.shuffle),
                            e.inputNum && (this.inputNum = e.inputNum),
                            e.outputNum && (this.outputNum = e.outputNum)
                        }
                    }
                    t.ChannelShuffle = n
                }
                ,
                5634: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Clip = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.maxValue && (this.maxValue = e.maxValue),
                            e.minValue && (this.minValue = e.minValue)
                        }
                    }
                    t.Clip = n
                }
                ,
                5574: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Concat = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.axis && (this.axis = e.axis),
                            e.input_size && (this.input_size = e.input_size)
                        }
                    }
                    t.Concat = n
                }
                ,
                8407: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Constant = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.constShape && (this.constShape = e.constShape),
                            e.constValue && (this.constValue = e.constValue)
                        }
                    }
                    t.Constant = n
                }
                ,
                7115: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Conv2D = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.channel && (this.channel = e.channel),
                            e.kernel && (this.kernel = e.kernel),
                            e.stride && (this.stride = e.stride),
                            e.padding && (this.padding = e.padding),
                            e.dilation && (this.dilation = e.dilation),
                            e.group && (this.group = e.group),
                            e.weight && (this.weight = e.weight),
                            e.bias && (this.bias = e.bias),
                            e.activation && (this.activation = e.activation)
                        }
                    }
                    t.Conv2D = n
                }
                ,
                1858: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ConvTranspose2D = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.channel && (this.channel = e.channel),
                            e.kernel && (this.kernel = e.kernel),
                            e.stride && (this.stride = e.stride),
                            e.padding && (this.padding = e.padding),
                            e.output_padding && (this.output_padding = e.output_padding),
                            e.dilation && (this.dilation = e.dilation),
                            e.weight && (this.weight = e.weight),
                            e.bias && (this.bias = e.bias),
                            e.activation && (this.activation = e.activation)
                        }
                    }
                    t.ConvTranspose2D = n
                }
                ,
                9226: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Crop = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.hoffset && (this.hoffset = e.hoffset),
                            e.woffset && (this.woffset = e.woffset),
                            e.coffset && (this.coffset = e.coffset),
                            e.hsize && (this.hsize = e.hsize),
                            e.wsize && (this.wsize = e.wsize),
                            e.csize && (this.csize = e.csize)
                        }
                    }
                    t.Crop = n
                }
                ,
                3770: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Data = t.Operator = void 0;
                    let i = r(5249)
                      , n = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return n.Operator
                        }
                    });
                    class o extends n.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type),
                            e.shape && (this.shape = e.shape),
                            e.fl && (this.fl = e.fl),
                            e.div && (this.div = e.div)
                        }
                        reshape(e, t) {
                            this.shape.format !== i.DataFormat.NCHW ? this.shape.format !== i.DataFormat.NHWC || (this.shape.dims = [this.shape.dims[0], e, t, this.shape.dims[3]]) : this.shape.dims = [this.shape.dims[0], this.shape.dims[1], e, t]
                        }
                    }
                    t.Data = o
                }
                ,
                8159: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.DepthToSpace = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e?.blockSize && (this.blockSize = e.blockSize)
                        }
                    }
                    t.DepthToSpace = n
                }
                ,
                5857: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.DepthwiseConv2D = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.channel && (this.channel = e.channel),
                            e.kernel && (this.kernel = e.kernel),
                            e.stride && (this.stride = e.stride),
                            e.padding && (this.padding = e.padding),
                            e.dilation && (this.dilation = e.dilation),
                            e.weight && (this.weight = e.weight),
                            e.bias && (this.bias = e.bias),
                            e.activation && (this.activation = e.activation)
                        }
                    }
                    t.DepthwiseConv2D = n
                }
                ,
                3507: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Eltwise = t.EltwiseType = t.Activation = void 0;
                    let i = r(345);
                    !function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {})),
                    function(e) {
                        e[e.Add = 0] = "Add",
                        e[e.Prod = 1] = "Prod"
                    }(t.EltwiseType || (t.EltwiseType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            void 0 !== e.type && (this.type = e.type),
                            void 0 !== e.activation && (this.activation = e.activation)
                        }
                    }
                    t.Eltwise = n
                }
                ,
                2520: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Gather = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.dim && (this.dim = e?.dim),
                            e.index && (this.index = e?.index),
                            e.outputShape && (this.outputShape = e?.outputShape)
                        }
                    }
                    t.Gather = n
                }
                ,
                5113: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.GridSample = t.PaddingType = t.SampleType = void 0;
                    let i = r(345);
                    !function(e) {
                        e[e.Bilinear = 0] = "Bilinear",
                        e[e.Nearest = 1] = "Nearest"
                    }(t.SampleType || (t.SampleType = {})),
                    function(e) {
                        e[e.Zeros = 0] = "Zeros",
                        e[e.Border = 1] = "Border",
                        e[e.Reflection = 2] = "Reflection"
                    }(t.PaddingType || (t.PaddingType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e?.mode && (this.mode = e.mode),
                            e?.paddingMode && (this.paddingMode = e.paddingMode),
                            e?.grid && (this.grid = e.grid),
                            e?.alignCorners && (this.alignCorners = e.alignCorners)
                        }
                    }
                    t.GridSample = n
                }
                ,
                9120: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Softmax = t.Reshape = t.ReLU = t.Pooling = t.Eltwise = t.DepthwiseConv2D = t.Data = t.Crop = t.ConvTranspose2D = t.Conv2D = t.Constant = t.Concat = t.Clip = t.ChannelShuffle = void 0;
                    var i = r(7393);
                    Object.defineProperty(t, "ChannelShuffle", {
                        enumerable: !0,
                        get: function() {
                            return i.ChannelShuffle
                        }
                    });
                    var n = r(5634);
                    Object.defineProperty(t, "Clip", {
                        enumerable: !0,
                        get: function() {
                            return n.Clip
                        }
                    });
                    var o = r(5574);
                    Object.defineProperty(t, "Concat", {
                        enumerable: !0,
                        get: function() {
                            return o.Concat
                        }
                    });
                    var a = r(8407);
                    Object.defineProperty(t, "Constant", {
                        enumerable: !0,
                        get: function() {
                            return a.Constant
                        }
                    });
                    var s = r(7115);
                    Object.defineProperty(t, "Conv2D", {
                        enumerable: !0,
                        get: function() {
                            return s.Conv2D
                        }
                    });
                    var u = r(1858);
                    Object.defineProperty(t, "ConvTranspose2D", {
                        enumerable: !0,
                        get: function() {
                            return u.ConvTranspose2D
                        }
                    });
                    var l = r(9226);
                    Object.defineProperty(t, "Crop", {
                        enumerable: !0,
                        get: function() {
                            return l.Crop
                        }
                    });
                    var c = r(3770);
                    Object.defineProperty(t, "Data", {
                        enumerable: !0,
                        get: function() {
                            return c.Data
                        }
                    });
                    var p = r(5857);
                    Object.defineProperty(t, "DepthwiseConv2D", {
                        enumerable: !0,
                        get: function() {
                            return p.DepthwiseConv2D
                        }
                    });
                    var d = r(3507);
                    Object.defineProperty(t, "Eltwise", {
                        enumerable: !0,
                        get: function() {
                            return d.Eltwise
                        }
                    });
                    var f = r(1242);
                    Object.defineProperty(t, "Pooling", {
                        enumerable: !0,
                        get: function() {
                            return f.Pooling
                        }
                    });
                    var m = r(3642);
                    Object.defineProperty(t, "ReLU", {
                        enumerable: !0,
                        get: function() {
                            return m.ReLU
                        }
                    });
                    var h = r(2382);
                    Object.defineProperty(t, "Reshape", {
                        enumerable: !0,
                        get: function() {
                            return h.Reshape
                        }
                    });
                    var g = r(8655);
                    Object.defineProperty(t, "Softmax", {
                        enumerable: !0,
                        get: function() {
                            return g.Softmax
                        }
                    })
                }
                ,
                4965: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.InnerProduct = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e?.inChannel && (this.inChannel = e.inChannel),
                            e?.outChannel && (this.outChannel = e.outChannel),
                            e?.weight && (this.weight = e.weight),
                            e?.bias && (this.bias = e.bias),
                            e?.activation && (this.activation = e.activation)
                        }
                    }
                    t.InnerProduct = n
                }
                ,
                1022: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.InstanceNorm = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e?.episilon && (this.epsilon = e.episilon),
                            e?.gamma && (this.gamma = e.gamma),
                            e?.inplace && (this.inplace = e.inplace),
                            e?.beta && (this.beta = e.beta),
                            e?.affine && (this.affine = e.affine),
                            e?.activation && (this.activation = e.activation)
                        }
                    }
                    t.InstanceNorm = n
                }
                ,
                714: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.LeakyReLU = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.alpha && (this.alpha = e.alpha)
                        }
                    }
                    t.LeakyReLU = n
                }
                ,
                1498: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.MatMul = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e)
                        }
                    }
                    t.MatMul = n
                }
                ,
                3679: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Normalization = t.NormalizeType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.H = 4] = "H",
                        e[e.W = 2] = "W",
                        e[e.C = 1] = "C",
                        e[e.WC = 3] = "WC",
                        e[e.HW = 6] = "HW",
                        e[e.HWC = 7] = "HWC"
                    }(t.NormalizeType || (t.NormalizeType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.nomalizedType && (this.nomalizedType = e.nomalizedType),
                            e.epsilon && (this.epsilon = e.epsilon),
                            e.elementwiseAffine && (this.elementwiseAffine = e.elementwiseAffine),
                            e.gamma && (this.gamma = e.gamma),
                            e.beta && (this.beta = e.beta)
                        }
                    }
                    t.Normalization = n
                }
                ,
                8528: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.OneHot = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.depth && (this.depth = e.depth),
                            e.axis && (this.axis = e.axis),
                            e.onValue && (this.onValue = e.onValue),
                            e.offValue && (this.offValue = e.offValue)
                        }
                    }
                    t.OneHot = n
                }
                ,
                8391: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.OnnxOp1 = t.OpType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.Reshape = 0] = "Reshape"
                    }(t.OpType || (t.OpType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type),
                            e.outputShape && (this.outputShape = e.outputShape)
                        }
                    }
                    t.OnnxOp1 = n
                }
                ,
                3011: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.OnnxOp2 = t.OpType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.Sum = 0] = "Sum",
                        e[e.Pow = 1] = "Pow",
                        e[e.Sub = 2] = "Sub",
                        e[e.Mul = 3] = "Mul",
                        e[e.Div = 4] = "Div",
                        e[e.Equal = 5] = "Equal",
                        e[e.Greater = 6] = "Greater",
                        e[e.Less = 7] = "Less",
                        e[e.Max = 8] = "Max",
                        e[e.Min = 9] = "Min",
                        e[e.Mean = 10] = "Mean"
                    }(t.OpType || (t.OpType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type)
                        }
                    }
                    t.OnnxOp2 = n
                }
                ,
                345: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Operator = void 0,
                    t.Operator = class {
                        constructor(e={}) {
                            this.inplace = !1,
                            e.name && (this.name = e.name),
                            e.opType && (this.opType = e.opType),
                            e.inputs && (this.inputs = e.inputs),
                            e.outputs && (this.outputs = e.outputs),
                            e.inplace && (this.inplace = e.inplace)
                        }
                    }
                }
                ,
                4463: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Pad2d = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.padTop && (this.padTop = e.padTop),
                            e.padBottom && (this.padBottom = e.padBottom),
                            e.padLeft && (this.padLeft = e.padLeft),
                            e.padRight && (this.padRight = e.padRight)
                        }
                    }
                    t.Pad2d = n
                }
                ,
                1242: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Pooling = t.PoolingType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.Max = 0] = "Max",
                        e[e.Average = 1] = "Average"
                    }(t.PoolingType || (t.PoolingType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type),
                            e.kernel && (this.kernel = e.kernel),
                            e.stride && (this.stride = e.stride),
                            e.padding && (this.padding = e.padding),
                            e.isPoolingDown && (this.isPoolingDown = e.isPoolingDown)
                        }
                    }
                    t.Pooling = n
                }
                ,
                6682: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Reduce = t.ReduceType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.Sum = 0] = "Sum",
                        e[e.Mean = 1] = "Mean"
                    }(t.ReduceType || (t.ReduceType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type),
                            e.keepDims && (this.keepDims = e.keepDims),
                            e.reductionIndices && (this.reductionIndices = e.reductionIndices)
                        }
                    }
                    t.Reduce = n
                }
                ,
                3642: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ReLU = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.max && (this.max = e.max)
                        }
                    }
                    t.ReLU = n
                }
                ,
                2382: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Reshape = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.outputShape && (this.outputShape = e.outputShape)
                        }
                    }
                    t.Reshape = n
                }
                ,
                8200: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Scale = t.Activation = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.None = 0] = "None",
                        e[e.ReLU = 1] = "ReLU"
                    }(t.Activation || (t.Activation = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.activation && (this.activation = e.activation)
                        }
                    }
                    t.Scale = n
                }
                ,
                3193: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.SeLU = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.alpha && (this.alpha = e.alpha),
                            e.gamma && (this.gamma = e.gamma)
                        }
                    }
                    t.SeLU = n
                }
                ,
                4284: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.SEScale = void 0;
                    let i = r(345);
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.relu_term && (this.relu_term = e.relu_term)
                        }
                    }
                    t.SEScale = n
                }
                ,
                5456: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Slice = void 0;
                    let i = r(4401);
                    class n extends i.Operator {
                    }
                    t.Slice = n
                }
                ,
                8655: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Softmax = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.axis && (this.axis = e.axis)
                        }
                    }
                    t.Softmax = n
                }
                ,
                410: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.SpaceToDepth = t.Operator = void 0;
                    let i = r(4401);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                    }
                    t.SpaceToDepth = n
                }
                ,
                9538: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Test = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                    }
                    t.Test = n
                }
                ,
                2419: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Tile = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                    }
                    t.Tile = n
                }
                ,
                8313: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Transpose = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    });
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.dims && (this.dims = e.dims)
                        }
                    }
                    t.Transpose = n
                }
                ,
                6650: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.Unary = t.UnaryType = t.Operator = void 0;
                    let i = r(345);
                    Object.defineProperty(t, "Operator", {
                        enumerable: !0,
                        get: function() {
                            return i.Operator
                        }
                    }),
                    function(e) {
                        e[e.Tanh = 0] = "Tanh",
                        e[e.Exp = 1] = "Exp",
                        e[e.Sigmoid = 2] = "Sigmoid",
                        e[e.Erf = 3] = "Erf",
                        e[e.HardSigmoid = 4] = "HardSigmoid",
                        e[e.ReluHardSigmoid = 5] = "ReluHardSigmoid",
                        e[e.HardSwish = 6] = "HardSwish",
                        e[e.ReluHardSwish = 7] = "ReluHardSwish",
                        e[e.Abs = 8] = "Abs",
                        e[e.Ceil = 9] = "Ceil",
                        e[e.Floor = 10] = "Floor",
                        e[e.Log = 11] = "Log",
                        e[e.Neg = 12] = "Neg",
                        e[e.Sqrt = 13] = "Sqrt",
                        e[e.Softplus = 14] = "Softplus",
                        e[e.Softsign = 15] = "Softsign"
                    }(t.UnaryType || (t.UnaryType = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.type && (this.type = e.type)
                        }
                    }
                    t.Unary = n
                }
                ,
                642: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.UpSampling = t.UpSamplingMode = void 0;
                    let i = r(345);
                    !function(e) {
                        e[e.Nearest = 0] = "Nearest",
                        e[e.Linear = 1] = "Linear",
                        e[e.Bilinear = 2] = "Bilinear"
                    }(t.UpSamplingMode || (t.UpSamplingMode = {}));
                    class n extends i.Operator {
                        constructor(e={}) {
                            super(e),
                            e.mode && (this.mode = e.mode),
                            e.scale && (this.scale = e.scale),
                            e.alignCorner && (this.alignCorner = e.alignCorner),
                            e.halfPixel && (this.halfPixel = e.halfPixel)
                        }
                    }
                    t.UpSampling = n
                }
                ,
                1806: (e, t, r) => {
                    let i = r(7393)
                      , n = r(6409);
                    n.ByteNNParser.register("Shuffle", (e, t) => {
                        let r = new i.ChannelShuffle;
                        return r.shuffle = e.parseUint32(),
                        r.group = e.parseUint32(),
                        r.inputNum = 1,
                        r.outputNum = 1,
                        r
                    }
                    ),
                    n.ByteNNParser.register("ShuffleNet", (e, t) => {
                        let r = new i.ChannelShuffle;
                        return r.inputNum = e.parseUint32(),
                        r.shuffle = e.parseUint32(),
                        r.outputNum = e.parseUint32(),
                        r.group = 0,
                        r
                    }
                    )
                }
                ,
                7746: (e, t, r) => {
                    let i = r(5574);
                    r(6409).ByteNNParser.register("Concat", (e, t) => {
                        let r = new i.Concat
                          , n = e.parseInt32();
                        return r.axis = n - 1 == 0 ? 3 : n - 1,
                        r.input_size = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                4781: (e, t, r) => {
                    let i = r(7115);
                    r(6409).ByteNNParser.register("Conv2D", (e, t) => {
                        let r = new i.Conv2D;
                        r.group = e.parseInt32(),
                        r.channel = {
                            in: e.parseInt32(),
                            out: e.parseInt32()
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            top: e.parseInt32(),
                            bottom: e.parseInt32(),
                            left: e.parseInt32(),
                            right: e.parseInt32()
                        },
                        r.activation = "relu" == e.parseString() ? i.Activation.ReLU : i.Activation.None;
                        let n = e.parseUint32()
                          , o = e.parseUint32();
                        r.weight = new Float32Array(t.sliceArrayBuffer(n, n + o));
                        let a = e.parseUint32()
                          , s = e.parseUint32();
                        return s > 0 && (r.bias = new Float32Array(t.sliceArrayBuffer(a, a + s))),
                        r
                    }
                    )
                }
                ,
                3772: (e, t, r) => {
                    let i = r(1858);
                    r(6409).ByteNNParser.register("ConvTranspose2D", (e, t) => {
                        let r = new i.ConvTranspose2D;
                        r.channel = {
                            in: e.parseInt32(),
                            out: e.parseInt32()
                        },
                        e.parseInt32(),
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            top: e.parseInt32(),
                            bottom: e.parseInt32(),
                            left: e.parseInt32(),
                            right: e.parseInt32()
                        };
                        let n = e.parseInt32()
                          , o = e.parseInt32();
                        r.output_padding = {
                            right: o,
                            bottom: n
                        },
                        r.dilation = {
                            x: 1,
                            y: 1
                        },
                        r.activation = "relu" == e.parseString() ? i.Activation.ReLU : i.Activation.None;
                        let a = e.parseUint32()
                          , s = e.parseUint32();
                        r.weight = new Float32Array(t.sliceArrayBuffer(a, a + s));
                        let u = e.parseUint32()
                          , l = e.parseUint32();
                        return l > 0 && (r.bias = new Float32Array(t.sliceArrayBuffer(u, u + l))),
                        r
                    }
                    )
                }
                ,
                4712: (e, t, r) => {
                    let i = r(9226);
                    r(6409).ByteNNParser.register("Crop", (e, t) => {
                        let r = new i.Crop;
                        return r.hoffset = e.parseInt32(),
                        r.woffset = e.parseInt32(),
                        r.coffset = e.parseInt32(),
                        r.hsize = e.parseInt32(),
                        r.wsize = e.parseInt32(),
                        r.csize = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                3316: (e, t, r) => {
                    let i = r(5249)
                      , n = r(3770);
                    r(6409).ByteNNParser.register("Data", (e, t) => {
                        let r = new n.Data
                          , o = Array(e.parseUint32()).fill(0).map(t => e.parseInt32());
                        return r.shape = new i.Shape(i.DataFormat.NHWC,o),
                        r.fl = e.parseInt32(),
                        r.div = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                9320: (e, t, r) => {
                    let i = r(5857);
                    r(6409).ByteNNParser.register("DepthwiseConv2D", (e, t) => {
                        let r = new i.DepthwiseConv2D;
                        e.parseInt32(),
                        r.channel = {
                            in: e.parseInt32(),
                            out: e.parseInt32()
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            top: e.parseInt32(),
                            bottom: e.parseInt32(),
                            left: e.parseInt32(),
                            right: e.parseInt32()
                        },
                        r.activation = "relu" == e.parseString() ? i.Activation.ReLU : i.Activation.None;
                        let n = e.parseUint32()
                          , o = e.parseUint32();
                        r.weight = new Float32Array(t.sliceArrayBuffer(n, n + o));
                        let a = e.parseUint32()
                          , s = e.parseUint32();
                        return s > 0 && (r.bias = new Float32Array(t.sliceArrayBuffer(a, a + s))),
                        r
                    }
                    )
                }
                ,
                163: (e, t, r) => {
                    let i = r(3507)
                      , n = r(6409);
                    n.ByteNNParser.register("Eltwise", (e, t) => {
                        let r = new i.Eltwise;
                        return r.type = i.EltwiseType.Add,
                        r.activation = 1 == e.parseUint32() ? i.Activation.ReLU : i.Activation.None,
                        r
                    }
                    ),
                    n.ByteNNParser.register("EltwiseProd", (e, t) => {
                        let r = new i.Eltwise;
                        return r.type = i.EltwiseType.Prod,
                        r.activation = 1 == e.parseUint32() ? i.Activation.ReLU : i.Activation.None,
                        r
                    }
                    )
                }
                ,
                8771: (e, t, r) => {
                    let i = r(4965);
                    r(6409).ByteNNParser.register("InnerProduct", (e, t) => {
                        let r = new i.InnerProduct;
                        r.outChannel = e.parseInt32(),
                        r.activation = "relu" == e.parseString() ? i.Activation.ReLU : i.Activation.None;
                        let n = e.parseUint32()
                          , o = e.parseUint32();
                        r.weight = new Float32Array(t.sliceArrayBuffer(n, n + o));
                        let a = e.parseUint32()
                          , s = e.parseUint32();
                        return s > 0 && (r.bias = new Float32Array(t.sliceArrayBuffer(a, a + s))),
                        r
                    }
                    )
                }
                ,
                9611: (e, t, r) => {
                    let i = r(9770)
                      , n = r(5249)
                      , o = r(8391);
                    r(6409).ByteNNParser.register("OnnxOp1", (e, t) => {
                        let r = new o.OnnxOp1;
                        if ("Reshape" == e.parseString()) {
                            r.type = o.OpType.Reshape;
                            let t = Array(e.parseUint32()).fill(0).map(t => e.parseInt32());
                            r.outputShape = new i.Shape(n.DataFormat.NHWC,t)
                        }
                        return r
                    }
                    )
                }
                ,
                6501: (e, t, r) => {
                    let i = r(4463);
                    r(6409).ByteNNParser.register("Pad2d", (e, t) => {
                        let r = new i.Pad2d;
                        return r.padTop = e.parseInt32(),
                        r.padBottom = e.parseInt32(),
                        r.padLeft = e.parseInt32(),
                        r.padRight = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                6409: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ByteNNParser = t.ByteNNParserIterator = void 0;
                    let i = r(345)
                      , n = r(2810);
                    class o {
                        constructor(e) {
                            this.buffer = e,
                            this.cursor = 0
                        }
                        parseUint8() {
                            let e = this.buffer.slice(this.cursor, this.cursor + 1);
                            return this.cursor += 1,
                            new Uint8Array(e)[0]
                        }
                        parseInt32() {
                            let e = this.buffer.slice(this.cursor, this.cursor + 4);
                            return this.cursor += 4,
                            new Int32Array(e)[0]
                        }
                        parseUint32() {
                            let e = this.buffer.slice(this.cursor, this.cursor + 4);
                            return this.cursor += 4,
                            new Uint32Array(e)[0]
                        }
                        parseString() {
                            let e = this.parseUint32()
                              , t = String.fromCharCode.apply(null, [...new Uint8Array(this.buffer.slice(this.cursor, this.cursor + e))]);
                            return this.cursor += e,
                            t
                        }
                        parseStringVector() {
                            return Array(this.parseUint32()).fill("").map(e => this.parseString())
                        }
                        parseArrayBuffer(e) {
                            let t = this.buffer.slice(this.cursor, this.cursor + e);
                            return this.cursor += e,
                            t
                        }
                        sliceArrayBuffer(e, t) {
                            return this.buffer.slice(e, t)
                        }
                    }
                    t.ByteNNParserIterator = o;
                    let a = {};
                    t.ByteNNParser = class {
                        static register(e, t) {
                            a[e] = t
                        }
                        parse(e) {
                            if (!e)
                                return [];
                            let t = new o(e)
                              , r = t.parseUint32();
                            n.trace.assert( () => 0x1f2e3d4c == r);
                            let s = t.parseString()
                              , u = t.parseUint32();
                            n.trace.assert( () => 3 == u);
                            let l = new o(e.slice(t.parseUint32(), t.parseUint32()))
                              , c = new o(e.slice(t.parseUint32(), t.parseUint32()))
                              , p = new o(e.slice(t.parseUint32(), t.parseUint32()))
                              , d = l.parseUint32()
                              , f = l.parseStringVector()
                              , m = l.parseStringVector();
                            n.trace.log( () => `version: ${s}, inputs: ${f}, outputs: ${m}`);
                            let h = Date.now()
                              , g = [];
                            for (let e = 0; e < d; e++) {
                                let e = c.parseUint32()
                                  , t = new o(c.parseArrayBuffer(e))
                                  , r = t.parseString()
                                  , n = t.parseString()
                                  , s = t.parseStringVector()
                                  , u = t.parseStringVector()
                                  , l = a[r]
                                  , d = l ? l(t, p) : new i.Operator;
                                d.name = n,
                                d.inputs = s,
                                d.outputs = u,
                                g.push(d)
                            }
                            return n.trace.log( () => `parse ${g.length}, cost ${Date.now() - h}ms.`),
                            g
                        }
                    }
                }
                ,
                7644: (e, t, r) => {
                    let i = r(1242);
                    r(6409).ByteNNParser.register("Pooling", (e, t) => {
                        let r = new i.Pooling;
                        return r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.type = "MAX" == e.parseString() ? i.PoolingType.Max : i.PoolingType.Average,
                        r
                    }
                    )
                }
                ,
                3747: (e, t, r) => {
                    let i = r(3642);
                    r(6409).ByteNNParser.register("ReLU", (e, t) => {
                        let r = new i.ReLU;
                        return r.max = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                5313: (e, t, r) => {
                    let i = r(9770)
                      , n = r(5249)
                      , o = r(2382);
                    r(6409).ByteNNParser.register("Reshape", (e, t) => {
                        let r = new o.Reshape
                          , a = Array(e.parseUint32()).fill(0).map(t => e.parseInt32());
                        return r.outputShape = new i.Shape(n.DataFormat.NHWC,a),
                        r
                    }
                    )
                }
                ,
                1791: (e, t, r) => {
                    let i = r(4284);
                    r(6409).ByteNNParser.register("SEScale", (e, t) => {
                        let r = new i.SEScale;
                        return r.relu_term = 1 == e.parseUint32(),
                        r
                    }
                    )
                }
                ,
                7916: (e, t, r) => {
                    let i = r(5456);
                    r(6409).ByteNNParser.register("Slice", (e, t) => {
                        let r = new i.Slice
                          , n = e.parseInt32();
                        r.axis = n - 1 == 0 ? 3 : n - 1,
                        r.sliceNum = e.parseInt32(),
                        r.slicePoint = [];
                        for (let t = 0; t < r.sliceNum; t++)
                            r.slicePoint.push(e.parseInt32());
                        r.outputNum = e.parseInt32(),
                        r.outputTypes = [],
                        r.outputFLs = [];
                        for (let t = 0; t < r.outputNum; t++)
                            r.outputTypes.push(e.parseInt32()),
                            r.outputFLs.push(e.parseInt32());
                        return r
                    }
                    )
                }
                ,
                3381: (e, t, r) => {
                    let i = r(8655);
                    r(6409).ByteNNParser.register("Softmax", (e, t) => {
                        let r = new i.Softmax;
                        return r.axis = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                179: (e, t, r) => {
                    let i = r(8313);
                    r(6409).ByteNNParser.register("Transpose", (e, t) => {
                        let r = new i.Transpose
                          , n = e.parseUint32();
                        return r.dims = new Int32Array(n).fill(0).map(t => e.parseInt32()),
                        r
                    }
                    )
                }
                ,
                2762: (e, t, r) => {
                    let i = r(6650);
                    r(6409).ByteNNParser.register("Unary", (e, t) => {
                        let r = new i.Unary
                          , n = e.parseString();
                        if ("Tanh" != n)
                            throw Error("Unsupported Unary Operator: " + n);
                        return r.type = i.UnaryType.Tanh,
                        r
                    }
                    )
                }
                ,
                6905: (e, t, r) => {
                    let i = r(642)
                      , n = r(6409);
                    n.ByteNNParser.register("UpSampling", (e, t) => {
                        let r = new i.UpSampling
                          , n = e.parseString();
                        if ("NEAREST" == n)
                            r.mode = i.UpSamplingMode.Nearest;
                        else if ("LINEAR" == n)
                            r.mode = i.UpSamplingMode.Linear;
                        else {
                            if ("BILINEAR" != n)
                                throw Error("Not Supported mode: " + n);
                            r.mode = i.UpSamplingMode.Bilinear
                        }
                        return r.scale = 2,
                        r.alignCorner = 0,
                        r.halfPixel = !0,
                        r
                    }
                    ),
                    n.ByteNNParser.register("Upsample", (e, t) => {
                        let r = new i.UpSampling;
                        r.scale = e.parseInt32();
                        let n = e.parseString();
                        if ("nearest" == n)
                            r.mode = i.UpSamplingMode.Nearest;
                        else {
                            if ("linear" != n)
                                throw Error("Upsample: Not Supported mode " + n);
                            r.mode = i.UpSamplingMode.Bilinear
                        }
                        return r.alignCorner = e.parseInt32(),
                        r.halfPixel = !!e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                2447: (e, t, r) => {
                    let i = r(7393)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("Shuffle", (e, t) => {
                        let r = new i.ChannelShuffle;
                        return r.shuffle = e.parseInt32(),
                        r.group = e.parseInt32(),
                        r.inputNum = 1,
                        r.outputNum = 1,
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.register("ShuffleNet", (e, t) => {
                        let r = new i.ChannelShuffle;
                        r.inputNum = e.parseInt32(),
                        r.inputs = [];
                        for (let t = 0; t < r.inputNum; t++)
                            r.inputs.push(e.parseString());
                        r.shuffle = e.parseInt32(),
                        r.outputNum = e.parseInt32(),
                        r.outputs = [];
                        for (let t = 0; t < r.outputNum; t++)
                            r.outputs.push(e.parseString()),
                            e.parseInt32();
                        return r.group = 0,
                        r
                    }
                    )
                }
                ,
                7193: (e, t, r) => {
                    let i = r(5574)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("Concat", (e, t) => {
                        let r = new i.Concat;
                        r.axis = 3,
                        r.input_size = e.parseInt32(),
                        r.inputs = [];
                        for (let t = 0; t < r.input_size; t++)
                            r.inputs.push(e.parseString());
                        return r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.register("Concat2", (e, t) => {
                        let r = new i.Concat;
                        r.axis = e.parseInt32(),
                        r.input_size = e.parseInt32(),
                        r.inputs = [];
                        for (let t = 0; t < r.input_size; t++)
                            r.inputs.push(e.parseString());
                        return r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                9622: (e, t, r) => {
                    let i = r(8407)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("Constant", (e, t) => {
                        let r = new i.Constant;
                        return e.parseInt32(),
                        r.constShape = new Int32Array([e.parseInt32(), e.parseInt32(), e.parseInt32(), e.parseInt32()]),
                        r.outputs = [e.parseString()],
                        r.inputs = [],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("Constant", (e, t) => {
                        let r = e
                          , i = r.constShape[0] * r.constShape[1] * r.constShape[2] * r.constShape[3] * 4;
                        return r.constValue = new Float32Array(t.parseArrayBuffer(i)),
                        !0
                    }
                    )
                }
                ,
                8211: (e, t, r) => {
                    let i = r(7115)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("Convolution", (e, t) => {
                        let r = new i.Conv2D;
                        r.group = 1,
                        r.channel = {
                            in: 0,
                            out: e.parseInt32()
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: 1,
                            x: 1
                        };
                        let n = e.parseInt32()
                          , o = e.parseInt32();
                        return r.padding = {
                            top: n,
                            bottom: n,
                            left: o,
                            right: o
                        },
                        r.bias = new Float32Array(1 == e.parseInt32() ? [1] : [0]),
                        r.activation = 1 == e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("Convolution", (e, t) => {
                        let r = e
                          , i = r.channel.in * r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return r.bias[0] && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    ),
                    n.ByteNNUnifyParser.register("Conv2D", (e, t) => {
                        let r = new i.Conv2D;
                        return r.group = e.parseInt32(),
                        r.channel = {
                            in: e.parseInt32(),
                            out: e.parseInt32()
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            top: e.parseInt32(),
                            bottom: e.parseInt32(),
                            left: e.parseInt32(),
                            right: e.parseInt32()
                        },
                        r.bias = new Float32Array(1 == e.parseInt32() ? [1] : [0]),
                        r.activation = 1 == e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("Conv2D", (e, t) => {
                        let r = e
                          , i = r.channel.in * r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return r.bias[0] && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                1087: (e, t, r) => {
                    let i = r(7115)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("ConvolutionV2", (e, t) => {
                        let r = new i.Conv2D;
                        r.group = 1,
                        e.parseString();
                        let n = e.parseInt32()
                          , o = e.parseInt32()
                          , a = e.parseInt32()
                          , s = e.parseInt32()
                          , u = e.parseInt32()
                          , l = e.parseInt32()
                          , c = e.parseInt32()
                          , p = e.parseInt32()
                          , d = e.parseInt32()
                          , f = e.parseInt32()
                          , m = e.parseInt32();
                        return r.channel = {
                            in: 0,
                            out: n
                        },
                        r.kernel = {
                            h: o,
                            w: a
                        },
                        r.stride = {
                            y: s,
                            x: u
                        },
                        r.dilation = {
                            y: 1,
                            x: 1
                        },
                        r.padding = {
                            top: l,
                            bottom: c,
                            left: p,
                            right: d
                        },
                        r.bias = new Float32Array(1 == f ? [1] : [0]),
                        r.activation = 1 == m ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("ConvolutionV2", (e, t) => {
                        let r = e
                          , i = r.channel.in * r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return r.bias[0] && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                9338: (e, t, r) => {
                    let i = r(9226);
                    r(3392).ByteNNUnifyParser.register("Crop", (e, t) => {
                        let r = new i.Crop;
                        return r.hoffset = e.parseInt32(),
                        r.woffset = e.parseInt32(),
                        r.coffset = e.parseInt32(),
                        r.hsize = e.parseInt32(),
                        r.wsize = e.parseInt32(),
                        r.csize = e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                6035: (e, t, r) => {
                    let i = r(5249)
                      , n = r(3770);
                    r(3392).ByteNNUnifyParser.register("DataV2", (e, t) => {
                        let r = new n.Data
                          , o = [, , , , ].fill(0).map(t => e.parseInt32());
                        return r.shape = new i.Shape(i.DataFormat.NHWC,o),
                        r.fl = e.parseInt32(),
                        r.div = e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                6109: (e, t, r) => {
                    let i = r(5857)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("DepthwiseSeparableConvolution", (e, t) => {
                        let r = new i.DepthwiseConv2D
                          , n = e.parseInt32();
                        r.channel = {
                            in: n,
                            out: n
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: 1,
                            x: 1
                        };
                        let o = e.parseInt32()
                          , a = e.parseInt32();
                        return r.padding = {
                            top: o,
                            bottom: o,
                            left: a,
                            right: a
                        },
                        r.bias = new Float32Array(1 === e.parseInt32() ? [1] : [0]),
                        r.activation = 1 === e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("DepthwiseSeparableConvolution", (e, t) => {
                        let r = e
                          , i = r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return n > 0 && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                8300: (e, t, r) => {
                    let i = r(5857)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("DepthwiseSeparableConvolutionV2", (e, t) => {
                        let r = new i.DepthwiseConv2D
                          , n = e.parseInt32();
                        return r.channel = {
                            in: n,
                            out: n
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.dilation = {
                            y: 1,
                            x: 1
                        },
                        r.padding = {
                            top: e.parseInt32(),
                            bottom: e.parseInt32(),
                            left: e.parseInt32(),
                            right: e.parseInt32()
                        },
                        r.bias = new Float32Array(1 === e.parseInt32() ? [1] : [0]),
                        r.activation = 1 === e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("DepthwiseSeparableConvolutionV2", (e, t) => {
                        let r = e
                          , i = r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return n > 0 && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                1465: (e, t, r) => {
                    let i = r(5857)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("DilationSeparableConvolution", (e, t) => {
                        let r = new i.DepthwiseConv2D
                          , n = e.parseInt32();
                        r.channel = {
                            in: n,
                            out: n
                        },
                        r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.dilation = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        };
                        let o = e.parseInt32()
                          , a = e.parseInt32();
                        return r.padding = {
                            top: o,
                            bottom: o,
                            left: a,
                            right: a
                        },
                        r.bias = new Float32Array(1 === e.parseInt32() ? [1] : [0]),
                        r.activation = 1 === e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("DilationSeparableConvolution", (e, t) => {
                        let r = e
                          , i = r.channel.out * r.kernel.h * r.kernel.w * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.channel.out;
                        return n > 0 && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                6510: (e, t, r) => {
                    let i = r(3507);
                    r(3392).ByteNNUnifyParser.register("Eltwise", (e, t) => {
                        let r = new i.Eltwise;
                        return r.inputs = [e.parseString(), e.parseString()],
                        r.outputs = [e.parseString()],
                        e.parseInt32(),
                        e.parseInt32(),
                        r.type = i.EltwiseType.Add,
                        r.activation = 1 == e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        r
                    }
                    )
                }
                ,
                1479: (e, t, r) => {
                    let i = r(4965)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("InnerProduct", (e, t) => {
                        let r = new i.InnerProduct;
                        return r.inChannel = 0,
                        r.outChannel = e.parseInt32(),
                        r.bias = new Float32Array(1 === e.parseInt32() ? [1] : [0]),
                        r.activation = 1 === e.parseInt32() ? i.Activation.ReLU : i.Activation.None,
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("InnerProduct", (e, t) => {
                        let r = e
                          , i = r.inChannel * r.outChannel * 4;
                        r.weight = new Float32Array(t.parseArrayBuffer(i));
                        let n = 4 * r.outChannel;
                        return 1 === r.bias[0] && (r.bias = new Float32Array(t.parseArrayBuffer(n))),
                        !0
                    }
                    )
                }
                ,
                259: (e, t, r) => {
                    let i = r(1022)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("InstanceNorm", (e, t) => {
                        let r = new i.InstanceNorm
                          , n = e.parseInt32();
                        return r.epsilon = Math.pow(10, n),
                        r.affine = e.parseInt32(),
                        r.activation = e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.loading("InstanceNorm", (e, t, r) => {
                        let i = e;
                        if (r) {
                            let e = r[i.inputs[0]]
                              , n = e.shape.dims[0] * e.shape.dims[3] * 4;
                            i.gamma = new Float32Array(t.parseArrayBuffer(n)),
                            i.beta = new Float32Array(t.parseArrayBuffer(n))
                        }
                        return !0
                    }
                    )
                }
                ,
                3725: (e, t, r) => {
                    let i = r(1498);
                    r(3392).ByteNNUnifyParser.register("OnnxMatmul", (e, t) => {
                        let r = new i.MatMul;
                        return r.inputs = [e.parseString(), e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                8790: (e, t, r) => {
                    let i = r(9770)
                      , n = r(5249)
                      , o = r(9120)
                      , a = r(6650);
                    r(3392).ByteNNUnifyParser.register("OnnxOp1", (e, t) => {
                        let r;
                        let s = e.parseString();
                        if ("Reshape" == s) {
                            (r = new o.Reshape).inputs = [e.parseString()],
                            r.outputs = [e.parseString()],
                            e.parseInt32(),
                            e.parseInt32();
                            let t = [, , , , ].fill(0).map(t => e.parseInt32());
                            e.parseInt32(),
                            r.outputShape = new i.Shape(n.DataFormat.NHWC,t)
                        } else if ("Softmax" == s) {
                            (r = new o.Softmax).inputs = [e.parseString()],
                            r.outputs = [e.parseString()],
                            e.parseInt32(),
                            e.parseInt32();
                            let t = e.parseInt32();
                            r.axis = t
                        } else
                            "Clip" == s ? ((r = new o.Clip).inputs = [e.parseString()],
                            r.outputs = [e.parseString()],
                            r.maxValue = 1e4,
                            r.minValue = 0) : "Exp" == s && ((r = new a.Unary).type = a.UnaryType.Exp,
                            r.inputs = [e.parseString()],
                            r.outputs = [e.parseString()]);
                        if (r)
                            return r;
                        throw TypeError(`Unsupported onnx1 op type ${s}`)
                    }
                    )
                }
                ,
                7580: (e, t, r) => {
                    let i = r(9120)
                      , n = r(3507);
                    r(3392).ByteNNUnifyParser.register("OnnxOp2", (e, t) => {
                        let r = e.parseString();
                        if ("Sum" == r) {
                            let t = new i.Eltwise;
                            return t.type = n.EltwiseType.Add,
                            t.inputs = [e.parseString(), e.parseString()],
                            t.outputs = [e.parseString()],
                            e.parseInt32(),
                            e.parseInt32(),
                            t
                        }
                        if ("Mul" == r) {
                            let t = new i.Eltwise;
                            return t.type = n.EltwiseType.Prod,
                            t.inputs = [e.parseString(), e.parseString()],
                            t.outputs = [e.parseString()],
                            e.parseInt32(),
                            e.parseInt32(),
                            t
                        }
                        throw TypeError(`Unsupported onnxOp2 type ${r}`)
                    }
                    )
                }
                ,
                3392: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.ByteNNUnifyParser = t.ByteNNProtoParserIterator = void 0;
                    let i = r(5249)
                      , n = r(345)
                      , o = r(5559)
                      , a = r(2810)
                      , s = r(6409);
                    class u {
                        constructor(e) {
                            this.lines = (new TextDecoder).decode(new Uint8Array(e)).split(/\r\n|\r|\n/),
                            this.line = (this.lines.shift() || "").trim().replace("\\n", "").split(" ")
                        }
                        parseNextLayer() {
                            this.line = (this.lines.shift() || "").trim().replace("\\n", "").split(" ")
                        }
                        parseString() {
                            return this.line.shift() || ""
                        }
                        parseInt32() {
                            return parseInt(this.line.shift() || "0")
                        }
                    }
                    t.ByteNNProtoParserIterator = u;
                    let l = {}
                      , c = {};
                    class p {
                        static register(e, t) {
                            l[e] = t
                        }
                        static loading(e, t) {
                            c[e] = t
                        }
                        static decode(e, t) {
                            let r = e.length
                              , i = new Uint8Array(r);
                            for (let n = 0; n < r; n++)
                                i[n] = e[n] ^ t[n % 8];
                            let n = new Uint8Array([82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]);
                            for (let e = 0; e < r; e++)
                                i[e] = n[i[e]];
                            return i.buffer
                        }
                        parse(e) {
                            if (!e)
                                return [];
                            let t = Date.now()
                              , r = new s.ByteNNParserIterator(e)
                              , d = r.parseUint8();
                            a.trace.assert( () => "B" == String.fromCharCode(d));
                            let f = r.parseUint8();
                            a.trace.assert( () => "M" == String.fromCharCode(f)),
                            r.parseUint8();
                            let m = r.parseUint8();
                            a.trace.assert( () => m >= 2),
                            r.parseUint32(),
                            r.parseUint32();
                            let h = r.parseUint32()
                              , g = r.parseUint32()
                              , _ = e.slice(g, g + h)
                              , v = r.parseUint32()
                              , x = r.parseUint32()
                              , b = e.slice(x, x + v)
                              , y = r.parseUint32()
                              , w = r.parseUint32()
                              , T = e.slice(w, 2 === m ? w + 8 : w + y)
                              , S = new u(p.decode(new Uint8Array(_), new Uint8Array(T)))
                              , C = new s.ByteNNParserIterator(b)
                              , E = S.parseInt32()
                              , I = S.parseInt32();
                            S.parseInt32(),
                            a.trace.log( () => `version: ${m}, layers: ${E + I}`),
                            S.parseNextLayer();
                            let F = {}
                              , L = [];
                            for (let e = 0; e < E; e++) {
                                let e = S.parseString()
                                  , t = S.parseString()
                                  , r = l[e]
                                  , a = r ? r(S, C, F) : new n.Operator;
                                a.name = t,
                                a.opType = e,
                                a.inputs = [],
                                a.outputs = [t],
                                L.push(a),
                                F[t] = new i.Tensor,
                                o.OpShaper.reshape(a, [], [F[t]]),
                                S.parseNextLayer()
                            }
                            for (let e = 0; e < I; e++) {
                                let e = S.parseString()
                                  , t = S.parseString()
                                  , r = l[e];
                                if (!r) {
                                    a.trace.error( () => `parser unsupported op: ${t} type: ${e}`),
                                    S.parseNextLayer();
                                    continue
                                }
                                let s = r ? r(S, C, F) : new n.Operator;
                                for (let r of (s.name = t,
                                s.opType = e,
                                L.push(s),
                                s.outputs))
                                    s.inplace || (F[r] = new i.Tensor);
                                let u = s.inputs.map(e => F[e])
                                  , p = s.outputs.map(e => F[e]);
                                o.OpShaper.reshape(s, u, p);
                                let d = c[e];
                                d && d(s, C, F),
                                S.parseNextLayer()
                            }
                            return a.trace.log( () => `parse ${L.length}, cost ${Date.now() - t}ms.`),
                            L
                        }
                    }
                    t.ByteNNUnifyParser = p
                }
                ,
                1964: (e, t, r) => {
                    let i = r(1242)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("PoolingDown", (e, t) => {
                        let r = new i.Pooling;
                        return r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        e.parseInt32(),
                        e.parseInt32(),
                        r.type = "MAX" == e.parseString() ? i.PoolingType.Max : i.PoolingType.Average,
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r.isPoolingDown = !0,
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.register("Pooling", (e, t) => {
                        let r = new i.Pooling;
                        return r.kernel = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        r.stride = {
                            y: e.parseInt32(),
                            x: e.parseInt32()
                        },
                        r.padding = {
                            h: e.parseInt32(),
                            w: e.parseInt32()
                        },
                        e.parseInt32(),
                        e.parseInt32(),
                        r.type = "MAX" == e.parseString() ? i.PoolingType.Max : i.PoolingType.Average,
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r.isPoolingDown = !0,
                        r
                    }
                    )
                }
                ,
                9895: (e, t, r) => {
                    let i = r(3642);
                    r(3392).ByteNNUnifyParser.register("Relu", (e, t) => {
                        let r = new i.ReLU;
                        return r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r.max = e.parseInt32(),
                        0 == r.max && (r.max = Number.MAX_SAFE_INTEGER),
                        r
                    }
                    )
                }
                ,
                1892: (e, t, r) => {
                    let i = r(8024)
                      , n = r(2382);
                    r(3392).ByteNNUnifyParser.register("Reshape", (e, t) => {
                        let r = new n.Reshape
                          , o = [e.parseInt32(), e.parseInt32(), e.parseInt32(), e.parseInt32()];
                        return r.outputShape = new i.Shape(i.DataFormat.NHWC,o),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                1663: (e, t, r) => {
                    let i = r(4284);
                    r(3392).ByteNNUnifyParser.register("SEScale", (e, t) => {
                        let r = new i.SEScale;
                        return r.inputs = [e.parseString(), e.parseString()],
                        r.outputs = [e.parseString()],
                        e.parseInt32(),
                        e.parseInt32(),
                        r.relu_term = 1 == e.parseInt32(),
                        r
                    }
                    )
                }
                ,
                1173: (e, t, r) => {
                    let i = r(5456);
                    r(3392).ByteNNUnifyParser.register("Slice", (e, t) => {
                        let r = new i.Slice;
                        r.inputs = [e.parseString()];
                        let n = e.parseInt32();
                        r.axis = [0, 3, 1, 2][n],
                        r.sliceNum = e.parseInt32(),
                        r.slicePoint = [];
                        for (let t = 0; t < r.sliceNum; t++)
                            r.slicePoint.push(e.parseInt32());
                        r.outputNum = e.parseInt32(),
                        r.outputs = [],
                        r.outputTypes = [],
                        r.outputFLs = [];
                        for (let t = 0; t < r.outputNum; t++)
                            r.outputs.push(e.parseString()),
                            r.outputFLs.push(e.parseInt32()),
                            r.outputTypes.push(4);
                        return r
                    }
                    )
                }
                ,
                7757: (e, t, r) => {
                    let i = r(8655);
                    r(3392).ByteNNUnifyParser.register("Softmax", (e, t) => {
                        let r = new i.Softmax;
                        return r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r.axis = 3,
                        r
                    }
                    )
                }
                ,
                1428: (e, t, r) => {
                    let i = r(9538);
                    r(3392).ByteNNUnifyParser.register("Test", (e, t) => {
                        let r = new i.Test;
                        return r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r.type = e.parseInt32(),
                        console.log("test layer, test type= %d", r.type),
                        r
                    }
                    )
                }
                ,
                830: (e, t, r) => {
                    let i = r(8313);
                    r(3392).ByteNNUnifyParser.register("Transpose", (e, t) => {
                        let r = new i.Transpose
                          , n = [e.parseInt32(), e.parseInt32(), e.parseInt32(), e.parseInt32()];
                        return r.dims = new Int32Array(n),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                3176: (e, t, r) => {
                    let i = r(6650)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("Tanh", (e, t) => {
                        let r = new i.Unary;
                        return r.type = i.UnaryType.Tanh,
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.register("Sigmoid", (e, t) => {
                        let r = new i.Unary;
                        return r.type = i.UnaryType.Sigmoid,
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        r
                    }
                    )
                }
                ,
                1940: (e, t, r) => {
                    let i = r(642)
                      , n = r(3392);
                    n.ByteNNUnifyParser.register("UpSampling", (e, t) => {
                        let r = new i.UpSampling;
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()];
                        let n = e.parseString();
                        if ("NEAREST" === n)
                            r.mode = i.UpSamplingMode.Nearest;
                        else if ("LINEAR" === n)
                            r.mode = i.UpSamplingMode.Linear;
                        else {
                            if ("BILINEAR" !== n)
                                throw Error("Not Supported mode: " + n);
                            r.mode = i.UpSamplingMode.Bilinear
                        }
                        return r.scale = 2,
                        r.alignCorner = 0,
                        r.halfPixel = !0,
                        r
                    }
                    ),
                    n.ByteNNUnifyParser.register("Upsample", (e, t) => {
                        let r = new i.UpSampling;
                        e.parseInt32();
                        let n = e.parseString();
                        if (e.parseInt32(),
                        e.parseInt32(),
                        r.inputs = [e.parseString()],
                        r.outputs = [e.parseString()],
                        "nearest" === n)
                            r.mode = i.UpSamplingMode.Nearest;
                        else if ("linear" === n)
                            r.mode = i.UpSamplingMode.Linear;
                        else {
                            if ("bilinear" !== n)
                                throw Error("Not Supported mode: " + n);
                            r.mode = i.UpSamplingMode.Bilinear
                        }
                        return r.scale = 2,
                        r.alignCorner = 0,
                        r.halfPixel = !0,
                        r
                    }
                    )
                }
                ,
                3907: (e, t, r) => {
                    let i = r(7393);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e;
                        for (let e = 0; e < i.inputNum; e++)
                            r[e].type = t[e].type,
                            r[e].shape = t[e].shape,
                            r[e].fraction = t[e].fraction
                    }
                    , i.ChannelShuffle)
                }
                ,
                9023: (e, t, r) => {
                    let i = r(5249)
                      , n = r(5634);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = t[0].shape.copy().dims;
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(i.DataFormat.NHWC,n),
                        r[0].fraction = t[0].fraction
                    }
                    , n.Clip)
                }
                ,
                3230: (e, t, r) => {
                    let i = r(5574);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e
                          , n = i.input_size
                          , o = i.axis
                          , a = 0;
                        for (let e = 0; e < n; e++)
                            a += t[e].shape.dims[o];
                        let s = t[0].shape.copy();
                        s.dims[o] = a,
                        r[0].type = t[0].type,
                        r[0].shape = s,
                        r[0].fraction = t[0].fraction
                    }
                    , i.Concat)
                }
                ,
                7582: (e, t, r) => {
                    let i = r(7693)
                      , n = r(8407)
                      , o = r(5559);
                    o.OpShaper.register( (e, t, r) => {
                        let n = e;
                        r[0].type = t.length ? t[0].type : i.DataType.Float32,
                        r[0].shape = new o.Shape(i.DataFormat.NHWC,n.constShape),
                        r[0].fraction = t.length ? t[0].fraction : 1
                    }
                    , n.Constant)
                }
                ,
                8900: (e, t, r) => {
                    let i = r(7115)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u] = o.dims
                          , l = (s + i.padding.top + i.padding.bottom - i.dilation.y * (i.kernel.h - 1) - 1) / i.stride.y + 1
                          , c = (u + i.padding.left + i.padding.right - i.dilation.x * (i.kernel.w - 1) - 1) / i.stride.x + 1;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, l, c, i.channel.out]),
                        r[0].fraction = t[0].fraction,
                        0 === i.channel.in && (i.channel.in = o.dims.slice(-1)[0])
                    }
                    , i.Conv2D)
                }
                ,
                3524: (e, t, r) => {
                    let i = r(5249)
                      , n = r(1858);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = e
                          , o = t[0].shape
                          , [a,s,u] = o.dims
                          , l = (s - 1) * n.stride.y - n.padding.top - n.padding.bottom + n.dilation.y * (n.kernel.h - 1) + n.output_padding.bottom + 1
                          , c = (u - 1) * n.stride.x - n.padding.left - n.padding.right + n.dilation.x * (n.kernel.w - 1) + n.output_padding.right + 1;
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(o.format,[a, l, c, n.channel.out]),
                        r[0].fraction = t[0].fraction
                    }
                    , n.ConvTranspose2D)
                }
                ,
                2940: (e, t, r) => {
                    let i = r(5249)
                      , n = r(9226);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = e
                          , [o] = t[0].shape.dims;
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(t[0].shape.format,[o, n.hsize, n.wsize, n.csize]),
                        r[0].fraction = t[0].fraction
                    }
                    , n.Crop)
                }
                ,
                1440: (e, t, r) => {
                    let i = r(3770);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e;
                        r[0].type = i.type || r[0].type,
                        r[0].shape = i.shape || r[0].shape,
                        r[0].fraction = i.fl || r[0].fraction
                    }
                    , i.Data)
                }
                ,
                2590: (e, t, r) => {
                    let i = r(8159)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u,l] = o.dims
                          , c = l / (i.blockSize * i.blockSize)
                          , p = s * i.blockSize
                          , d = u * i.blockSize;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, p, d, c]),
                        r[0].fraction = t[0].fraction
                    }
                    , i.DepthToSpace)
                }
                ,
                1385: (e, t, r) => {
                    let i = r(5857)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u] = o.dims
                          , l = (s + i.padding.top + i.padding.bottom - i.dilation.y * (i.kernel.h - 1) - 1) / i.stride.y + 1
                          , c = (u + i.padding.left + i.padding.right - i.dilation.x * (i.kernel.w - 1) - 1) / i.stride.x + 1;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, l, c, i.channel.out]),
                        r[0].fraction = t[0].fraction,
                        0 === i.channel.in && (i.channel.in = o.dims.slice(-1)[0])
                    }
                    , i.DepthwiseConv2D)
                }
                ,
                4476: (e, t, r) => {
                    let i = r(3507);
                    r(5559).OpShaper.register( (e, t, r) => {
                        r[0].type = t[0].type,
                        r[0].shape = t[0].shape.copy(),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Eltwise)
                }
                ,
                1050: (e, t, r) => {
                    let i = r(2520)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(t[0].shape.format,i.outputShape),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Gather)
                }
                ,
                2642: (e, t, r) => {
                    let i = r(5113)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , [o,,,a] = t[0].shape.dims
                          , [,s,,u] = i.gridShape;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(t[0].shape.format,[o, u, s, a]),
                        r[0].fraction = t[0].fraction
                    }
                    , i.GridSample)
                }
                ,
                2924: (e, t, r) => {
                    let i = r(4965)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape.copy()
                          , a = o.dims;
                        a[a.length - 1] = i.outChannel,
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,a),
                        r[0].fraction = t[0].fraction,
                        0 === i.inChannel && (i.inChannel = t[0].shape.dims.slice(-1)[0])
                    }
                    , i.InnerProduct)
                }
                ,
                8096: (e, t, r) => {
                    let i = r(714)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(t[0].shape.format,t[0].shape.dims),
                        r[0].fraction = t[0].fraction
                    }
                    , i.LeakyReLU)
                }
                ,
                7765: (e, t, r) => {
                    let i = r(1498)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        r[0].type = t[0].type;
                        let[i,o,a,s] = t[0].shape.dims
                          , [u,l,c,p] = t[1].shape.dims
                          , d = [i, o, c, Math.max(s, p)];
                        r[0].shape = new n.Shape(t[0].shape.format,d),
                        r[0].fraction = t[0].fraction
                    }
                    , i.MatMul)
                }
                ,
                2647: (e, t, r) => {
                    let i = r(3679)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = t[0].shape;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(i.format,i.dims),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Normalization)
                }
                ,
                4273: (e, t, r) => {
                    let i = r(5249)
                      , n = r(8528);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = e
                          , o = t[0].shape.copy().dims;
                        o.splice(n.axis, 0, n.depth),
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(i.DataFormat.NHWC,o),
                        r[0].fraction = t[0].fraction
                    }
                    , n.OneHot)
                }
                ,
                7352: (e, t, r) => {
                    let i = r(8391);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = e;
                        n.type == i.OpType.Reshape && (r[0].type = t[0].type,
                        r[0].shape = n.outputShape.copy(),
                        r[0].fraction = t[0].fraction)
                    }
                    , i.OnnxOp1)
                }
                ,
                5644: (e, t, r) => {
                    let i = r(5249)
                      , n = r(3011);
                    r(5559).OpShaper.register( (e, t, r) => {
                        switch (e.type) {
                        case n.OpType.Sum:
                        case n.OpType.Pow:
                        case n.OpType.Sub:
                        case n.OpType.Mul:
                        case n.OpType.Div:
                        case n.OpType.Equal:
                        case n.OpType.Greater:
                        case n.OpType.Less:
                        case n.OpType.Max:
                        case n.OpType.Min:
                        case n.OpType.Mean:
                            r[0].type = t[0].type,
                            r[0].shape = new i.Shape(t[0].shape.format,t[0].shape.dims),
                            r[0].fraction = t[0].fraction;
                            break;
                        default:
                            throw Error("OnnxOp2: not implemented.")
                        }
                    }
                    , n.OnnxOp2)
                }
                ,
                982: (e, t, r) => {
                    let i = r(4463)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u,l] = o.dims
                          , c = s + i.padTop + i.padBottom
                          , p = u + i.padLeft + i.padRight;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, c, p, l]),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Pad2d)
                }
                ,
                5464: (e, t, r) => {
                    let i = r(1242)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u,l] = o.dims
                          , c = 1
                          , p = 1;
                        i.isPoolingDown ? (c = Math.trunc((s + 2 * i.padding.h - i.kernel.h) / i.stride.y) + 1,
                        p = Math.trunc((u + 2 * i.padding.w - i.kernel.w) / i.stride.x) + 1) : (c = Math.ceil((s + 2 * i.padding.h - i.kernel.h) / i.stride.y) + 1,
                        p = Math.ceil((u + 2 * i.padding.w - i.kernel.w) / i.stride.x) + 1),
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, c, p, l]),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Pooling)
                }
                ,
                6103: (e, t, r) => {
                    let i = r(6682)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , a = i.keepDims
                          , s = t[0].shape.copy().dims
                          , u = [];
                        i.reductionIndices.map( (e, t) => s[e] = -1),
                        s.map( (e, t) => {
                            -1 != e ? u.push(e) : a && u.push(1)
                        }
                        ),
                        0 == u.length && u.push(1),
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,u),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Reduce)
                }
                ,
                5559: (e, t, r) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.OpShaper = t.Tensor = t.Shape = void 0;
                    let i = r(5249);
                    Object.defineProperty(t, "Shape", {
                        enumerable: !0,
                        get: function() {
                            return i.Shape
                        }
                    }),
                    Object.defineProperty(t, "Tensor", {
                        enumerable: !0,
                        get: function() {
                            return i.Tensor
                        }
                    });
                    let n = new Map
                      , o = (e, t, r) => {
                        r[0].type = t[0].type,
                        r[0].shape = t[0].shape.copy(),
                        r[0].fraction = t[0].fraction
                    }
                    ;
                    t.OpShaper = class {
                        static register(e, t) {
                            n.set(t, e)
                        }
                        static get reshape() {
                            return (e, t, r) => {
                                let i = r.map(e => e.shape);
                                return (n.get(e.constructor) || o)(e, t, r),
                                r.some( (e, t) => !e.shape.equals(i[t]))
                            }
                        }
                    }
                }
                ,
                6698: (e, t, r) => {
                    let i = r(2382);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e;
                        r[0].type = t[0].type,
                        r[0].shape = i.outputShape.copy(),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Reshape)
                }
                ,
                3529: (e, t, r) => {
                    let i = r(8200)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = t[0].shape;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(i.format,i.dims),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Scale)
                }
                ,
                4085: (e, t, r) => {
                    let i = r(3193)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(t[0].shape.format,t[0].shape.dims),
                        r[0].fraction = t[0].fraction
                    }
                    , i.SeLU)
                }
                ,
                5965: (e, t, r) => {
                    let i = r(5456);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e
                          , n = i.outputNum
                          , o = i.axis
                          , a = i.slicePoint;
                        for (let e = 0; e < n; e++) {
                            let i = r[e];
                            i.type = t[0].type,
                            i.fraction = t[0].fraction;
                            let n = 0;
                            e > 0 && (n = a[e - 1]);
                            let s = t[0].shape.copy()
                              , u = s.dims[o];
                            e < a.length && (u = a[e]),
                            s.dims[o] = u - n,
                            i.shape = s
                        }
                    }
                    , i.Slice)
                }
                ,
                875: (e, t, r) => {
                    let i = r(410)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e
                          , o = t[0].shape
                          , [a,s,u,l] = o.dims
                          , c = i.blockSize * i.blockSize * l
                          , p = s / i.blockSize
                          , d = u / i.blockSize;
                        r[0].type = t[0].type,
                        r[0].shape = new n.Shape(o.format,[a, p, d, c]),
                        r[0].fraction = t[0].fraction
                    }
                    , i.SpaceToDepth)
                }
                ,
                9990: (e, t, r) => {
                    let i = r(5249)
                      , n = r(9538);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = t[0].shape.copy().dims;
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(i.DataFormat.NHWC,n),
                        r[0].fraction = t[0].fraction
                    }
                    , n.Test)
                }
                ,
                3229: (e, t, r) => {
                    let i = r(2419)
                      , n = r(5559);
                    n.OpShaper.register( (e, t, r) => {
                        let i = e;
                        r[0].type = t[0].type;
                        let o = [...i.reps]
                          , a = o.length;
                        for (; a != t[0].shape.dims.length; )
                            a = o.unshift(1);
                        let s = [...t[0].shape.dims].map( (e, t) => e * o[t]);
                        r[0].shape = new n.Shape(t[0].shape.format,s),
                        r[0].fraction = t[0].fraction
                    }
                    , i.Tile)
                }
                ,
                6455: (e, t, r) => {
                    let i = r(8313);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let i = e;
                        r[0].type = t[0].type;
                        let n = t[0].shape.dims;
                        r[0].shape = t[0].shape.copy();
                        let o = i.dims;
                        for (let e = 0; e < i.dims.length; ++e)
                            r[0].shape.dims[e] = n[o[e]];
                        r[0].fraction = t[0].fraction
                    }
                    , i.Transpose)
                }
                ,
                3785: (e, t, r) => {
                    let i = r(5249)
                      , n = r(642);
                    r(5559).OpShaper.register( (e, t, r) => {
                        let n = e
                          , o = t[0].shape
                          , [a,s,u,l] = o.dims
                          , c = s * n.scale
                          , p = u * n.scale;
                        r[0].type = t[0].type,
                        r[0].shape = new i.Shape(o.format,[a, c, p, l]),
                        r[0].fraction = t[0].fraction
                    }
                    , n.UpSampling)
                }
                ,
                2810: (e, t) => {
                    Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    t.trace = void 0;
                    let r = "undefined" == typeof performance ? Date : performance;
                    function i() {
                        return r.now()
                    }
                    let n = (e, ...t) => {
                        console.log(e(), ...t)
                    }
                      , o = (e, ...t) => {
                        console.error("\u274C " + e(), ...t)
                    }
                      , a = (e, ...t) => {
                        console.assert(e(), ...t)
                    }
                      , s = (e, t) => {
                        let r = i();
                        e();
                        let n = i();
                        console.log(`\u{23F1} ${t || ""}: ${n - r}ms`)
                    }
                    ;
                    t.trace = {
                        now: i,
                        log: n,
                        error: o,
                        assert: a,
                        profile: s
                    }
                }
                ,
                8024: (e, t, r) => {
                    r.r(t),
                    r.d(t, {
                        WebGLDevice: () => i.WebGLDevice,
                        WebGPUDevice: () => n.WebGPUDevice,
                        DataFormat: () => o.DataFormat,
                        DataType: () => o.DataType,
                        Engine: () => a.Engine,
                        ErrCode: () => s.ErrCode,
                        Shape: () => u.Shape,
                        Tensor: () => u.Tensor,
                        Model: () => l,
                        ByteNNParser: () => c.ByteNNParser,
                        ByteNNUnifyParser: () => p.ByteNNUnifyParser
                    }),
                    r(4701),
                    r(6040),
                    r(2393),
                    r(8395),
                    r(876),
                    r(9016),
                    r(7150),
                    r(8807),
                    r(5886),
                    r(7470),
                    r(3490),
                    r(8522),
                    r(3315),
                    r(4974),
                    r(6340),
                    r(5778),
                    r(1642),
                    r(4740),
                    r(5260),
                    r(1535),
                    r(4656),
                    r(5729),
                    r(8273),
                    r(3356),
                    r(696),
                    r(9699),
                    r(8019),
                    r(5879),
                    r(6556),
                    r(6239),
                    r(9757),
                    r(3743),
                    r(9438),
                    r(5579),
                    r(3571),
                    r(1806),
                    r(7746),
                    r(4781),
                    r(3772),
                    r(4712),
                    r(3316),
                    r(9320),
                    r(163),
                    r(8771),
                    r(9611),
                    r(6501),
                    r(7644),
                    r(3747),
                    r(5313),
                    r(1791),
                    r(7916),
                    r(3381),
                    r(179),
                    r(2762),
                    r(6905),
                    r(2447),
                    r(7193),
                    r(9622),
                    r(8211),
                    r(1087),
                    r(9338),
                    r(6035),
                    r(6109),
                    r(8300),
                    r(1465),
                    r(6510),
                    r(1479),
                    r(259),
                    r(3725),
                    r(8790),
                    r(7580),
                    r(1964),
                    r(9895),
                    r(1892),
                    r(1663),
                    r(1173),
                    r(7757),
                    r(1428),
                    r(830),
                    r(3176),
                    r(1940),
                    r(5421),
                    r(2877),
                    r(7189),
                    r(1690),
                    r(6793),
                    r(4314),
                    r(3779),
                    r(4064),
                    r(8270),
                    r(3810),
                    r(9676),
                    r(9960),
                    r(5010),
                    r(8641),
                    r(3670),
                    r(1618),
                    r(2124),
                    r(9744),
                    r(3907),
                    r(9023),
                    r(3230),
                    r(7582),
                    r(8900),
                    r(3524),
                    r(2940),
                    r(1440),
                    r(2590),
                    r(1385),
                    r(4476),
                    r(1050),
                    r(2642),
                    r(2924),
                    r(8096),
                    r(7765),
                    r(2647),
                    r(4273),
                    r(7352),
                    r(5644),
                    r(982),
                    r(5464),
                    r(6103),
                    r(6698),
                    r(3529),
                    r(4085),
                    r(5965),
                    r(875),
                    r(9990),
                    r(3229),
                    r(6455),
                    r(3785);
                    var i = r(5462)
                      , n = r(9121)
                      , o = r(7693)
                      , a = r(7033)
                      , s = r(2758)
                      , u = r(5249)
                      , l = r(9120)
                      , c = r(6409)
                      , p = r(3392)
                }
            }
              , t = {};
            function r(i) {
                if (t[i])
                    return t[i].exports;
                var n = t[i] = {
                    exports: {}
                };
                return e[i].call(n.exports, n, n.exports, r),
                n.exports
            }
            return r.d = (e, t) => {
                for (var i in t)
                    r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, {
                        enumerable: !0,
                        get: t[i]
                    })
            }
            ,
            r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
            r.r = e => {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            }
            ,
            r(8024)
        }
        )(),
        Module.callbacks = {
            seqCallbacks: [],
            crashCallback: void 0
        },
        "object" == typeof window && (Module.canvas = Module.canvas ? Module.canvas : {
            id: "video-editor-canvas"
        }),
        Module.blobMapper = {},
        Module.addCallback = function(e, t=!0) {
            if (t)
                return Module.callbacks.seqCallbacks.push(e),
                Module.callbacks.seqCallbacks.length - 1;
            Module.callbacks.crashCallback = e
        }
        ,
        Module.getSeqCallback = function(e) {
            let t = Module.callbacks.seqCallbacks[e];
            return Module.callbacks.seqCallbacks[e] = null,
            t
        }
        ,
        Module.getCrashCallback = function() {
            return Module.callbacks.crashCallback
        }
        ,
        Module.out = function(e, ...t) {
            let r = `${e} ${t.join(" ")}`;
            if (Module.___logInVELOG) {
                let e = Module.allocate(Module.intArrayFromString(r), Module.ALLOC_NORMAL);
                Module.___logInVELOG(e),
                Module._free(e)
            }
        }
        ,
        Module.err = function(e, ...t) {
            let r = `${e} ${t.join(" ")}`;
            if (Module.___logExceptionStackInVELOG) {
                let e = Module.allocate(Module.intArrayFromString(r), Module.ALLOC_NORMAL);
                Module.___logExceptionStackInVELOG(0, e),
                Module._free(e)
            }
        }
        ,
        Module.onAbort = function() {
            console.error("progress abort:", arguments)
        }
        ;
        var _Worker = Worker;
        function decideDynamicLibloadAsync() {
            let e;
            let t = navigator.userAgent.toLowerCase()
              , r = !0;
            if (t.indexOf("chrome") > -1 || t.indexOf("chromium") > -1) {
                let i = t.match(/chrome\/([\d.]+)/);
                i && (e = i[1]).split(".").map(Number)[0] > 115 && (r = !1)
            }
            return !ENVIRONMENT_IS_WORKER && console.log("version:", e, "loadAsync:", r),
            r
        }
        Worker = function(e) {
            let t = "pthread worker #" + (PThread.unusedWorkers.length + PThread.runningWorkers.length)
              , r = new _Worker(e,{
                name: t
            });
            return r.__VESDK_name = t,
            r
        }
        ,
        Module.lvveFunctionTable = [function() {}
        ],
        Module.lvveFunctionTableRestIds = [],
        Module.lvveFunctionTable.getId = function() {
            return Module.lvveFunctionTableRestIds.length > 0 ? Module.lvveFunctionTableRestIds.shift() : Module.lvveFunctionTable.length
        }
        ,
        Module.lvveFunctionTable.add = function(e) {
            let t = this.getId();
            return Module.lvveFunctionTable[t] = e,
            t
        }
        ,
        Module.lvveFunctionTable.remove = function(e) {
            Module.lvveFunctionTable[e] && (Module.lvveFunctionTableRestIds.push(e),
            Module.lvveFunctionTable[e] = null)
        }
        ,
        Module.lvveFunctionTable.call = function(e, ...t) {
            let r = Module.lvveFunctionTable[e];
            if (!!r)
                return r(...t)
        }
        ,
        1 === Module.SIMD_MODE ? Module.dynamicLibraries = ["libffmpeg_simd.wasm"] : Module.dynamicLibraries = ["libffmpeg.wasm"],
        Module.MALLOC_TRACE_THRESHOLD = 4096,
        Module.decideDynamicLibloadAsync = decideDynamicLibloadAsync;
        let audioVolume = 1
          , audioGainNode = null
          , audioWorkletJs = `
class RingBuffer {

    static getStorageForCapacity(capacity, type) {
        if (!type.BYTES_PER_ELEMENT) {
            throw TypeError("Pass in a ArrayBuffer subclass");
        }
        const bytes = 8 + (capacity + 1) * type.BYTES_PER_ELEMENT;
        return new SharedArrayBuffer(bytes);
    }

    constructor(sab, type) {
        if (type.BYTES_PER_ELEMENT === undefined) {
            throw TypeError("Pass a concrete typed array class as second argument");
        }

        // Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring
        // buffer for this version, easily changeable.
        // -4 for the writer ptr (uint32_t offsets)
        // -4 for the read ptr (uint32_t offsets)
        // capacity counts the empty slot to distinguish between full and empty.
        this._type = type;
        this._capacity = (sab.byteLength - 8) / type.BYTES_PER_ELEMENT;
        this.buf = sab;
        this.write_ptr = new Uint32Array(this.buf, 0, 1);
        this.read_ptr = new Uint32Array(this.buf, 4, 1);
        this.storage = new type(this.buf, 8, this._capacity);
    }

    type() {
        return this._type.name;
    }

    push(elements, length, offset = 0) {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        if ((wr + 1) % this._storage_capacity() === rd) {
            // full
            return 0;
        }

        const len = length !== undefined ? length : elements.length;

        const to_write = Math.min(this._available_write(rd, wr), len);
        const first_part = Math.min(this._storage_capacity() - wr, to_write);
        const second_part = to_write - first_part;

        this._copy(elements, offset, this.storage, wr, first_part);
        this._copy(elements, offset + first_part, this.storage, 0, second_part);

        // publish the enqueued data to the other side
        Atomics.store(
            this.write_ptr,
            0,
            (wr + to_write) % this._storage_capacity()
        );

        return to_write;
    }

    writeCallback(amount, cb) {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        if ((wr + 1) % this._storage_capacity() === rd) {
            // full
            return 0;
        }

        const to_write = Math.min(this._available_write(rd, wr), amount);
        const first_part = Math.min(this._storage_capacity() - wr, to_write);
        const second_part = to_write - first_part;

        // This part will cause GC: don't use in the real time thread.
        const first_part_buf = new this._type(
            this.storage.buffer,
            8 + wr * this.storage.BYTES_PER_ELEMENT,
            first_part
        );
        const second_part_buf = new this._type(
            this.storage.buffer,
            8 + 0,
            second_part
        );

        const written = cb(first_part_buf, second_part_buf) || to_write;

        // publish the enqueued data to the other side
        Atomics.store(this.write_ptr, 0, (wr + written) % this._storage_capacity());

        return written;
    }

    writeCallbackWithOffset(amount, cb) {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        if ((wr + 1) % this._storage_capacity() === rd) {
            // full
            return 0;
        }

        const to_write = Math.min(this._available_write(rd, wr), amount);
        const first_part = Math.min(this._storage_capacity() - wr, to_write);
        const second_part = to_write - first_part;

        const written =
            cb(this.storage, wr, first_part, 0, second_part) || to_write;

        // publish the enqueued data to the other side
        Atomics.store(this.write_ptr, 0, (wr + written) % this._storage_capacity());

        return written;
    }

    pop(elements, length, offset = 0) {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        if (wr === rd) {
            return 0;
        }

        const len = length !== undefined ? length : elements.length;
        const to_read = Math.min(this._available_read(rd, wr), len);

        const first_part = Math.min(this._storage_capacity() - rd, to_read);
        const second_part = to_read - first_part;

        this._copy(this.storage, rd, elements, offset, first_part);
        this._copy(this.storage, 0, elements, offset + first_part, second_part);

        Atomics.store(this.read_ptr, 0, (rd + to_read) % this._storage_capacity());

        return to_read;
    }

    clear() {
        // reset read and write buffer
        Atomics.store(this.read_ptr, 0, 0);
        Atomics.store(this.write_ptr, 0, 0);
    }

    empty() {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        return wr === rd;
    }

    full() {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);

        return (wr + 1) % this._storage_capacity() === rd;
    }

    capacity() {
        return this._capacity - 1;
    }

    availableRead() {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);
        return this._available_read(rd, wr);
    }

    available_read() {
        return this.availableRead();
    }

    availableWrite() {
        const rd = Atomics.load(this.read_ptr, 0);
        const wr = Atomics.load(this.write_ptr, 0);
        return this._available_write(rd, wr);
    }

    _available_read(rd, wr) {
        return (wr + this._storage_capacity() - rd) % this._storage_capacity();
    }

    _available_write(rd, wr) {
        return this.capacity() - this._available_read(rd, wr);
    }

    _storage_capacity() {
        return this._capacity;
    }

    _copy(input, offset_input, output, offset_output, size) {
        for (let i = 0; i < size; i++) {
            output[offset_output + i] = input[offset_input + i];
        }
    }
}

class Processor extends AudioWorkletProcessor {
    static get parameterDescriptors() {
        return [];
    }

    constructor(options) {
        super(options);
        const { userData, sab, sampleRate, channelCount } = options.processorOptions;
        this.interleaved = new Float32Array(128 * channelCount);
        this.audio_reader = new RingBuffer(sab, Float32Array);
        this.channelCount = channelCount;
        console.log("worklet init success");
    }

    process(inputs, outputs, parameters) {
        let readSample = 0;

        if (this.audio_reader.availableRead() < this.interleaved.length) {
            this.interleaved.fill(0);
        } else {
            this.audio_reader.pop(this.interleaved, this.interleaved.length, 0);
        }
        const output = outputs[0];
        output.forEach((channel, index) => {
            for (let i = 0; i < channel.length; i++) {
                channel[i] = this.interleaved[i * 2 + index];
            }
        });

        return true;
    }
}

registerProcessor("processor", Processor);
`
          , CreateAudioWorkletInMain = function(e, t, r, i) {
            try {
                let n = Module.worklet;
                if (!n) {
                    let e = new Blob([audioWorkletJs],{
                        type: "application/javascript"
                    });
                    n = URL.createObjectURL(e)
                }
                void 0 === r && (r = 44100);
                let o = new AudioContext({
                    sampleRate: r
                })
                  , a = o.audioWorklet;
                return globalThis.vesdk_audioContext = o,
                a.addModule(n).then( () => {
                    a.processor = new AudioWorkletNode(o,"processor",{
                        numberOfInputs: 1,
                        numberOfOutputs: 1,
                        outputChannelCount: [i],
                        processorOptions: {
                            userData: e,
                            sab: t,
                            sampleRate: r,
                            channelCount: i
                        }
                    });
                    let n = o.createGain();
                    a.processor.connect(n),
                    n.connect(o.destination),
                    n.gain.value = audioVolume,
                    audioGainNode = n,
                    0 !== e && Module.ccall("TEAudioWorkletInitCallback", "number", ["number", "number"], [e, 0])
                }
                ),
                0
            } catch (t) {
                return 0 !== e && Module.ccall("TEAudioWorkletInitCallback", "number", ["number", "number"], [e, -1]),
                console.error(t),
                -1
            }
        };
        function TEPauseAudioWorklet(e) {
            void 0 === globalThis.vesdk_audioContext && (console.error("worklet, Audio context is not initialized"),
            Module.ccall("TEAudioWorkletPauseCallback", "number", ["number", "number"], [e, -1])),
            globalThis.vesdk_audioContext.suspend().then( () => {
                console.log("Audio context worklet suspended"),
                Module.ccall("TEAudioWorkletPauseCallback", "number", ["number", "number"], [e, 0])
            }
            , t => {
                console.error("Audio context worklet suspend failed", t),
                Module.ccall("TEAudioWorkletPauseCallback", "number", ["number", "number"], [e, -1])
            }
            )
        }
        function TEResumeAudioWorklet(e) {
            void 0 === globalThis.vesdk_audioContext && (console.error("Audio context worklet is not initialized"),
            Module.ccall("TEAudioWorkletResumeCallback", "number", ["number", "number"], [e, -1])),
            globalThis.vesdk_audioContext.resume().then( () => {
                Module.ccall("TEAudioWorkletResumeCallback", "number", ["number", "number"], [e, 0])
            }
            , t => {
                console.error("Audio context worklet resume failed", t),
                Module.ccall("TEAudioWorkletResumeCallback", "number", ["number", "number"], [e, -1])
            }
            )
        }
        function TEGetAudioWorkletVolume() {
            return null === audioGainNode ? audioVolume : audioGainNode.gain.value
        }
        function TESetAudioWorkletVolume(e) {
            return (audioVolume = e,
            null === audioGainNode) ? 0 : (audioGainNode.gain.value = e,
            0)
        }
        class RingBuffer {
            static getStorageForCapacity(e, t) {
                if (!t.BYTES_PER_ELEMENT)
                    throw TypeError("Pass in a ArrayBuffer subclass");
                return new SharedArrayBuffer(8 + (e + 1) * t.BYTES_PER_ELEMENT)
            }
            constructor(e, t) {
                if (void 0 === t.BYTES_PER_ELEMENT)
                    throw TypeError("Pass a concrete typed array class as second argument");
                this._type = t,
                this._capacity = (e.byteLength - 8) / t.BYTES_PER_ELEMENT,
                this.buf = e,
                this.write_ptr = new Uint32Array(this.buf,0,1),
                this.read_ptr = new Uint32Array(this.buf,4,1),
                this.storage = new t(this.buf,8,this._capacity)
            }
            type() {
                return this._type.name
            }
            push(e, t, r=0) {
                let i = Atomics.load(this.read_ptr, 0)
                  , n = Atomics.load(this.write_ptr, 0);
                if ((n + 1) % this._storage_capacity() === i)
                    return 0;
                let o = void 0 !== t ? t : e.length
                  , a = Math.min(this._available_write(i, n), o)
                  , s = Math.min(this._storage_capacity() - n, a)
                  , u = a - s;
                return this._copy(e, r, this.storage, n, s),
                this._copy(e, r + s, this.storage, 0, u),
                Atomics.store(this.write_ptr, 0, (n + a) % this._storage_capacity()),
                a
            }
            writeCallback(e, t) {
                let r = Atomics.load(this.read_ptr, 0)
                  , i = Atomics.load(this.write_ptr, 0);
                if ((i + 1) % this._storage_capacity() === r)
                    return 0;
                let n = Math.min(this._available_write(r, i), e)
                  , o = Math.min(this._storage_capacity() - i, n)
                  , a = n - o
                  , s = new this._type(this.storage.buffer,8 + i * this.storage.BYTES_PER_ELEMENT,o)
                  , u = t(s, new this._type(this.storage.buffer,8,a)) || n;
                return Atomics.store(this.write_ptr, 0, (i + u) % this._storage_capacity()),
                u
            }
            writeCallbackWithOffset(e, t) {
                let r = Atomics.load(this.read_ptr, 0)
                  , i = Atomics.load(this.write_ptr, 0);
                if ((i + 1) % this._storage_capacity() === r)
                    return 0;
                let n = Math.min(this._available_write(r, i), e)
                  , o = Math.min(this._storage_capacity() - i, n)
                  , a = n - o
                  , s = t(this.storage, i, o, 0, a) || n;
                return Atomics.store(this.write_ptr, 0, (i + s) % this._storage_capacity()),
                s
            }
            pop(e, t, r=0) {
                let i = Atomics.load(this.read_ptr, 0)
                  , n = Atomics.load(this.write_ptr, 0);
                if (n === i)
                    return 0;
                let o = void 0 !== t ? t : e.length
                  , a = Math.min(this._available_read(i, n), o)
                  , s = Math.min(this._storage_capacity() - i, a)
                  , u = a - s;
                return this._copy(this.storage, i, e, r, s),
                this._copy(this.storage, 0, e, r + s, u),
                Atomics.store(this.read_ptr, 0, (i + a) % this._storage_capacity()),
                a
            }
            clear() {
                Atomics.store(this.read_ptr, 0, 0),
                Atomics.store(this.write_ptr, 0, 0)
            }
            empty() {
                let e = Atomics.load(this.read_ptr, 0);
                return Atomics.load(this.write_ptr, 0) === e
            }
            full() {
                let e = Atomics.load(this.read_ptr, 0);
                return (Atomics.load(this.write_ptr, 0) + 1) % this._storage_capacity() === e
            }
            capacity() {
                return this._capacity - 1
            }
            availableRead() {
                let e = Atomics.load(this.read_ptr, 0)
                  , t = Atomics.load(this.write_ptr, 0);
                return this._available_read(e, t)
            }
            available_read() {
                return this.availableRead()
            }
            availableWrite() {
                let e = Atomics.load(this.read_ptr, 0)
                  , t = Atomics.load(this.write_ptr, 0);
                return this._available_write(e, t)
            }
            _available_read(e, t) {
                return (t + this._storage_capacity() - e) % this._storage_capacity()
            }
            _available_write(e, t) {
                return this.capacity() - this._available_read(e, t)
            }
            _storage_capacity() {
                return this._capacity
            }
            _copy(e, t, r, i, n) {
                for (let o = 0; o < n; o++)
                    r[i + o] = e[t + o]
            }
        }
        var moduleOverrides = Object.assign({}, Module)
          , arguments_ = []
          , thisProgram = "./this.program"
          , quit_ = (e, t) => {
            throw t
        }
          , ENVIRONMENT_IS_WEB = "object" == typeof window
          , ENVIRONMENT_IS_WORKER = "function" == typeof importScripts
          , ENVIRONMENT_IS_NODE = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node
          , ENVIRONMENT_IS_PTHREAD = Module.ENVIRONMENT_IS_PTHREAD || !1
          , scriptDirectory = "";
        function locateFile(e) {
            return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e
        }
        (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : "undefined" != typeof document && document.currentScript && (scriptDirectory = document.currentScript.src),
        _scriptDir && (scriptDirectory = _scriptDir),
        scriptDirectory = scriptDirectory.startsWith("blob:") ? "" : scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1),
        read_ = e => {
            var t = new XMLHttpRequest;
            return t.open("GET", e, !1),
            t.send(null),
            t.responseText
        }
        ,
        ENVIRONMENT_IS_WORKER && (readBinary = e => {
            var t = new XMLHttpRequest;
            return t.open("GET", e, !1),
            t.responseType = "arraybuffer",
            t.send(null),
            new Uint8Array(t.response)
        }
        ),
        readAsync = (e, t, r) => {
            var i = new XMLHttpRequest;
            i.open("GET", e, !0),
            i.responseType = "arraybuffer",
            i.onload = () => {
                if (200 == i.status || 0 == i.status && i.response) {
                    t(i.response);
                    return
                }
                r()
            }
            ,
            i.onerror = r,
            i.send(null)
        }
        );
        var out = Module.print || console.log.bind(console)
          , err = Module.printErr || console.error.bind(console);
        Object.assign(Module, moduleOverrides),
        moduleOverrides = null,
        Module.arguments && (arguments_ = Module.arguments),
        Module.thisProgram && (thisProgram = Module.thisProgram),
        Module.quit && (quit_ = Module.quit);
        var dynamicLibraries = Module.dynamicLibraries || [];
        Module.wasmBinary && (wasmBinary = Module.wasmBinary),
        "object" != typeof WebAssembly && abort("no native wasm support detected");
        var ABORT = !1;
        function assert(e, t) {
            !e && abort(t)
        }
        function updateMemoryViews() {
            var e = wasmMemory.buffer;
            Module.HEAP8 = HEAP8 = new Int8Array(e),
            Module.HEAP16 = HEAP16 = new Int16Array(e),
            Module.HEAPU8 = HEAPU8 = new Uint8Array(e),
            Module.HEAPU16 = HEAPU16 = new Uint16Array(e),
            Module.HEAP32 = HEAP32 = new Int32Array(e),
            Module.HEAPU32 = HEAPU32 = new Uint32Array(e),
            Module.HEAPF32 = HEAPF32 = new Float32Array(e),
            Module.HEAPF64 = HEAPF64 = new Float64Array(e),
            Module.HEAP64 = HEAP64 = new BigInt64Array(e),
            Module.HEAPU64 = HEAPU64 = new BigUint64Array(e)
        }
        var INITIAL_MEMORY = Module.INITIAL_MEMORY || 0x4000000;
        if (ENVIRONMENT_IS_PTHREAD)
            wasmMemory = Module.wasmMemory;
        else if (Module.wasmMemory)
            wasmMemory = Module.wasmMemory;
        else if (!((wasmMemory = new WebAssembly.Memory({
            initial: INITIAL_MEMORY / 65536,
            maximum: 16384,
            shared: !0
        })).buffer instanceof SharedArrayBuffer))
            throw err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),
            ENVIRONMENT_IS_NODE && err("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),
            Error("bad memory");
        if (updateMemoryViews(),
        INITIAL_MEMORY = wasmMemory.buffer.byteLength,
        !ENVIRONMENT_IS_WORKER) {
            Module.veFS = {
                dataFiles: new WebAssembly.Memory({
                    initial: 512,
                    maximum: 65536,
                    shared: !0
                }),
                control: new SharedArrayBuffer(64),
                index: new SharedArrayBuffer(0x1000000)
            };
            let __veFS$dataFile = new Uint32Array(Module.veFS.dataFiles.buffer);
            __veFS$dataFile[0] = 0,
            __veFS$dataFile[1] = 0;
            let __veFS$control = new Uint32Array(Module.veFS.control);
            __veFS$control[3] = 0,
            __veFS$control[4] = 8
        }
        var __ATPRERUN__ = []
          , __ATINIT__ = []
          , __ATMAIN__ = []
          , __ATPOSTRUN__ = []
          , __RELOC_FUNCS__ = []
          , runtimeInitialized = !1;
        function preRun() {
            if (Module.preRun)
                for ("function" == typeof Module.preRun && (Module.preRun = [Module.preRun]); Module.preRun.length; )
                    addOnPreRun(Module.preRun.shift());
            callRuntimeCallbacks(__ATPRERUN__)
        }
        function initRuntime() {
            runtimeInitialized = !0,
            !ENVIRONMENT_IS_PTHREAD && (callRuntimeCallbacks(__RELOC_FUNCS__),
            callRuntimeCallbacks(__ATINIT__))
        }
        function preMain() {
            !ENVIRONMENT_IS_PTHREAD && callRuntimeCallbacks(__ATMAIN__)
        }
        function postRun() {
            if (!ENVIRONMENT_IS_PTHREAD) {
                if (Module.postRun)
                    for ("function" == typeof Module.postRun && (Module.postRun = [Module.postRun]); Module.postRun.length; )
                        addOnPostRun(Module.postRun.shift());
                callRuntimeCallbacks(__ATPOSTRUN__)
            }
        }
        function addOnPreRun(e) {
            __ATPRERUN__.unshift(e)
        }
        function addOnInit(e) {
            __ATINIT__.unshift(e)
        }
        function addOnPostRun(e) {
            __ATPOSTRUN__.unshift(e)
        }
        var runDependencies = 0
          , runDependencyWatcher = null
          , dependenciesFulfilled = null;
        function getUniqueRunDependency(e) {
            return e
        }
        function addRunDependency(e) {
            runDependencies++,
            Module.monitorRunDependencies?.(runDependencies)
        }
        function removeRunDependency(e) {
            if (runDependencies--,
            Module.monitorRunDependencies?.(runDependencies),
            0 == runDependencies && (null !== runDependencyWatcher && (clearInterval(runDependencyWatcher),
            runDependencyWatcher = null),
            dependenciesFulfilled)) {
                var t = dependenciesFulfilled;
                dependenciesFulfilled = null,
                t()
            }
        }
        function abort(e) {
            Module.onAbort?.(e),
            err(e = "Aborted(" + e + ")"),
            ABORT = !0,
            EXITSTATUS = 1,
            e += ". Build with -sASSERTIONS for more info.",
            runtimeInitialized && ___trap();
            var t = new WebAssembly.RuntimeError(e);
            throw readyPromiseReject(t),
            t
        }
        var dataURIPrefix = "data:application/octet-stream;base64,"
          , isDataURI = e => e.startsWith(dataURIPrefix);
        function getBinarySync(e) {
            if (e == wasmBinaryFile && wasmBinary)
                return new Uint8Array(wasmBinary);
            if (readBinary)
                return readBinary(e);
            throw "both async and sync fetching of the wasm failed"
        }
        function getBinaryPromise(e) {
            return !wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && "function" == typeof fetch ? fetch(e, {
                credentials: "same-origin"
            }).then(t => {
                if (!t.ok)
                    throw `failed to load wasm binary file at '${e}'`;
                return t.arrayBuffer()
            }
            ).catch( () => getBinarySync(e)) : Promise.resolve().then( () => getBinarySync(e))
        }
        function instantiateArrayBuffer(e, t, r) {
            return getBinaryPromise(e).then(e => WebAssembly.instantiate(e, t)).then(r, e => {
                err(`failed to asynchronously prepare wasm: ${e}`),
                abort(e)
            }
            )
        }
        function instantiateAsync(e, t, r, i) {
            return e || "function" != typeof WebAssembly.instantiateStreaming || isDataURI(t) || "function" != typeof fetch ? instantiateArrayBuffer(t, r, i) : fetch(t, {
                credentials: "same-origin"
            }).then(e => WebAssembly.instantiateStreaming(e, r).then(i, function(e) {
                return err(`wasm streaming compile failed: ${e}`),
                err("falling back to ArrayBuffer instantiation"),
                instantiateArrayBuffer(t, r, i)
            }))
        }
        function createWasm() {
            var e = {
                env: wasmImports,
                wasi_snapshot_preview1: wasmImports,
                "GOT.mem": new Proxy(wasmImports,GOTHandler),
                "GOT.func": new Proxy(wasmImports,GOTHandler)
            };
            function t(e, t) {
                wasmExports = relocateExports(wasmExports = e.exports, 1024);
                var r = getDylinkMetadata(t);
                return r.neededDynlibs && (dynamicLibraries = r.neededDynlibs.concat(dynamicLibraries)),
                mergeLibSymbols(wasmExports, "main"),
                LDSO.init(),
                loadDylibs(),
                registerTLSInit(wasmExports._emscripten_tls_init, e.exports, r),
                addOnInit(wasmExports.__wasm_call_ctors),
                __RELOC_FUNCS__.push(wasmExports.__wasm_apply_data_relocs),
                wasmModule = t,
                removeRunDependency("wasm-instantiate"),
                wasmExports
            }
            function r(e) {
                t(e.instance, e.module)
            }
            if (addRunDependency("wasm-instantiate"),
            Module.instantiateWasm)
                try {
                    return Module.instantiateWasm(e, t)
                } catch (e) {
                    err(`Module.instantiateWasm callback failed with error: ${e}`),
                    readyPromiseReject(e)
                }
            return instantiateAsync(wasmBinary, wasmBinaryFile, e, r).catch(readyPromiseReject),
            {}
        }
        Module.locateFile ? !isDataURI(wasmBinaryFile = "vesdk-lvapi-opt.wasm") && (wasmBinaryFile = locateFile(wasmBinaryFile)) : wasmBinaryFile = "vesdk-lvapi-opt.wasm";
        var ASM_CONSTS = {
            5111036: () => {
                var e = new Date
                  , t = "## " + e.getFullYear() + "-" + ("0" + (e.getMonth() + 1)).slice(-2) + "-" + ("0" + e.getDate()).slice(-2) + " " + ("0" + e.getHours()).slice(-2) + ":" + ("0" + e.getMinutes()).slice(-2) + ":" + ("0" + e.getSeconds()).slice(-2) + "." + ("000" + e.getMilliseconds()).slice(-3);
                return Module.allocate(Module.intArrayFromString(t), Module.ALLOC_NORMAL)
            }
            ,
            5111534: e => {
                !Module.vesdk_call_list && (Module.vesdk_call_list = []);
                var t = UTF8ToString(e);
                Module.vesdk_call_list.push(t)
            }
            ,
            5111685: e => {
                vesdk_task_map[e] = {};
                let t = new Promise( (t, r) => {
                    vesdk_task_map[e].resolve = t,
                    vesdk_task_map[e].reject = r
                }
                );
                vesdk_task_map[e].promise = t
            }
            ,
            5111896: () => {
                console.profile("lvapi")
            }
            ,
            5111926: () => {
                console.profileEnd("lvapi")
            }
            ,
            5111959: function(e, t) {
                let r = e
                  , i = t
                  , n = Module.UTF8ToString(i)
                  , o = [];
                try {
                    o = JSON.parse(n) || []
                } catch (e) {
                    console.error("parse arguments string fail")
                }
                let a = Module.lvveFunctionTable.call(r, ...o);
                if ("string" != typeof a)
                    return a;
                {
                    let e = Module.lengthBytesUTF8(a) + 1
                      , t = Module._malloc(e);
                    return Module.stringToUTF8(a, t, e),
                    t
                }
            },
            5112441: () => ENVIRONMENT_IS_PTHREAD ? -1 : (new AudioContext).sampleRate,
            5112536: () => {
                postMessage({
                    cmd: "first_frame_workers_detail"
                })
            }
            ,
            5112594: () => !!GLctx && GLctx.isContextLost(),
            5112656: e => {
                clearTimeout(e)
            }
            ,
            5112675: (e, t) => setTimeout( () => _ve_trigger_thread_main_loop(t), e)
        };
        function ExitStatus(e) {
            this.name = "ExitStatus",
            this.message = `Program terminated with exit(${e})`,
            this.status = e
        }
        var GOT = {}
          , currentModuleWeakSymbols = new Set([])
          , GOTHandler = {
            get(e, t) {
                var r = GOT[t];
                return !r && (r = GOT[t] = new WebAssembly.Global({
                    value: "i32",
                    mutable: !0
                })),
                !currentModuleWeakSymbols.has(t) && (r.required = !0),
                r
            }
        }
          , terminateWorker = e => {
            e.terminate(),
            e.onmessage = e => {}
        }
          , killThread = e => {
            var t = PThread.pthreads[e];
            delete PThread.pthreads[e],
            terminateWorker(t),
            __emscripten_thread_free_data(e),
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(t), 1),
            t.pthread_ptr = 0
        }
          , cancelThread = e => {
            PThread.pthreads[e].postMessage({
                cmd: "cancel"
            })
        }
          , cleanupThread = e => {
            var t = PThread.pthreads[e];
            PThread.finishedThreads.delete(e),
            e in PThread.outstandingPromises && PThread.outstandingPromises[e].resolve(),
            PThread.returnWorkerToPool(t)
        }
          , zeroMemory = (e, t) => (GROWABLE_HEAP_U8().fill(0, e, e + t),
        e)
          , markAsFinshed = e => {
            PThread.finishedThreads.add(e),
            e in PThread.outstandingPromises && PThread.outstandingPromises[e].resolve()
        }
          , spawnThread = e => {
            var t = PThread.getNewWorker();
            if (!t)
                return 6;
            PThread.runningWorkers.push(t),
            PThread.pthreads[e.pthread_ptr] = t,
            t.pthread_ptr = e.pthread_ptr;
            var r = {
                cmd: "run",
                start_routine: e.startRoutine,
                arg: e.arg,
                pthread_ptr: e.pthread_ptr,
                createStack: e.createStack
            };
            return r.moduleCanvasId = e.moduleCanvasId,
            r.offscreenCanvases = e.offscreenCanvases,
            t.postMessage(r, e.transferList),
            0
        }
          , runtimeKeepaliveCounter = 0
          , keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0
          , withStackSave = e => {
            var t = stackSave()
              , r = e();
            return stackRestore(t),
            r
        }
          , MAX_INT53 = 0x20000000000000
          , MIN_INT53 = -0x20000000000000
          , bigintToI53Checked = e => e < MIN_INT53 || e > MAX_INT53 ? NaN : Number(e)
          , proxyToMainThread = (e, t, r, ...i) => withStackSave( () => {
            for (var n = 2 * i.length, o = stackAlloc(8 * n), a = o >> 3, s = 0; s < i.length; s++) {
                var u = i[s];
                "bigint" == typeof u ? (HEAP64[a + 2 * s] = 1n,
                HEAP64[a + 2 * s + 1] = u) : (HEAP64[a + 2 * s] = 0n,
                GROWABLE_HEAP_F64()[a + 2 * s + 1] = u)
            }
            return __emscripten_run_on_main_thread_js(e, t, n, o, r)
        }
        );
        function _proc_exit(e) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(0, 0, 1, e);
            EXITSTATUS = e,
            !keepRuntimeAlive() && (PThread.terminateAllThreads(),
            Module.onExit?.(e),
            ABORT = !0),
            quit_(e, new ExitStatus(e))
        }
        _proc_exit.sig = "vi";
        var exitJS = (e, t) => {
            if (EXITSTATUS = e,
            ENVIRONMENT_IS_PTHREAD)
                throw exitOnMainThread(e),
                "unwind";
            _proc_exit(e)
        }
          , _exit = exitJS;
        _exit.sig = "vi";
        var handleException = e => {
            if (e instanceof ExitStatus || "unwind" == e)
                return EXITSTATUS;
            quit_(1, e)
        }
          , PThread = {
            unusedWorkers: [],
            runningWorkers: [],
            tlsInitFunctions: [],
            pthreads: {},
            init() {
                ENVIRONMENT_IS_PTHREAD ? PThread.initWorker() : PThread.initMainThread()
            },
            initMainThread() {
                Module.pthreadPoolSize;
                for (var e = 0; e < 12; e++)
                    PThread.allocateUnusedWorker();
                addOnPreRun( () => {
                    addRunDependency("loading-workers"),
                    PThread.loadWasmModuleToAllWorkers( () => removeRunDependency("loading-workers"))
                }
                ),
                PThread.outstandingPromises = {},
                PThread.finishedThreads = new Set
            },
            initWorker() {
                noExitRuntime = !1
            },
            setExitStatus: e => EXITSTATUS = e,
            terminateAllThreads__deps: ["$terminateWorker"],
            terminateAllThreads: () => {
                for (var e of PThread.runningWorkers)
                    terminateWorker(e);
                for (var e of PThread.unusedWorkers)
                    terminateWorker(e);
                PThread.unusedWorkers = [],
                PThread.runningWorkers = [],
                PThread.pthreads = []
            }
            ,
            returnWorkerToPool: e => {
                var t = e.pthread_ptr;
                delete PThread.pthreads[t],
                PThread.unusedWorkers.push(e),
                PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(e), 1),
                e.pthread_ptr = 0,
                __emscripten_thread_free_data(t)
            }
            ,
            receiveObjectTransfer(e) {
                void 0 !== GL && (Object.assign(GL.offscreenCanvases, e.offscreenCanvases),
                !Module.canvas && e.moduleCanvasId && GL.offscreenCanvases[e.moduleCanvasId] && (Module.canvas = GL.offscreenCanvases[e.moduleCanvasId].offscreenCanvas,
                Module.canvas.id = e.moduleCanvasId))
            },
            threadInitTLS() {
                PThread.tlsInitFunctions.forEach(e => e())
            },
            loadWasmModuleToWorker: e => new Promise(t => {
                e.onmessage = r => {
                    var i = r.data
                      , n = i.cmd;
                    if (i.targetThread && i.targetThread != _pthread_self()) {
                        var o = PThread.pthreads[i.targetThread];
                        o ? o.postMessage(i, i.transferList) : err(`Internal error! Worker sent a message "${n}" to target pthread ${i.targetThread}, but that thread no longer exists!`);
                        return
                    }
                    "checkMailbox" === n ? checkMailbox() : "spawnThread" === n ? spawnThread(i) : "cleanupThread" === n ? cleanupThread(i.thread) : "markAsFinshed" === n ? markAsFinshed(i.thread) : "WASMFS_INIT_DONE" === n ? (!Module.WASMFS_INIT_DONE && Module.WASMFS_INIT_DONE_CALLBACK && Module.WASMFS_INIT_DONE_CALLBACK(),
                    Module.WASMFS_INIT_DONE = !0) : "killThread" === n ? killThread(i.thread) : "cancelThread" === n ? cancelThread(i.thread) : "loaded" === n ? (e.loaded = !0,
                    t(e)) : "alert" === n ? alert(`Thread ${i.threadId}: ${i.text}`) : "setimmediate" === i.target ? e.postMessage(i) : "callHandler" === n ? Module[i.handler](...i.args) : n && err(`worker sent an unknown command ${n}`)
                }
                ,
                e.onerror = e => {
                    if (err("worker sent an error!" + e.filename + ":" + e.lineno + ": " + e.message),
                    "vesdk_crash_handled" !== e.message) {
                        var t = {
                            filename: e.filename,
                            lineno: e.lineno,
                            colno: e.colno,
                            message: e.message
                        }
                          , r = "worker sent an error!" + e.lineno + "," + e.colno + ": " + e.message
                          , i = Module.getCrashCallback();
                        if (!i) {
                            console.warn("crashCallback not found");
                            return
                        }
                        i(r, t)
                    }
                    throw e
                }
                ;
                var r = [];
                for (var i of ["onExit", "onAbort", "print", "printErr"])
                    Module.hasOwnProperty(i) && r.push(i);
                e.postMessage({
                    cmd: "load",
                    handlers: r,
                    urlOrBlob: Module.mainScriptUrlOrBlob,
                    wasmMemory: wasmMemory,
                    wasmModule: wasmModule,
                    sharedModules: sharedModules,
                    veFS: Module.veFS
                })
            }
            ),
            loadWasmModuleToAllWorkers(e) {
                if (ENVIRONMENT_IS_PTHREAD)
                    return e();
                let t = Promise.all(PThread.unusedWorkers.map(PThread.loadWasmModuleToWorker));
                Module.pthreadPoolReady = t,
                e()
            },
            allocateUnusedWorker() {
                var e;
                if (Module.locateFile) {
                    var t = locateFile("vesdk-lvapi-opt.worker.mjs");
                    e = new Worker(t,{
                        type: "module"
                    })
                } else
                    e = new Worker(new URL("vesdk-lvapi-opt.worker.mjs",import.meta.url),{
                        type: "module"
                    });
                return PThread.unusedWorkers.push(e),
                e
            },
            getNewWorker: () => (0 == PThread.unusedWorkers.length && (PThread.allocateUnusedWorker(),
            PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])),
            PThread.unusedWorkers.shift())
        };
        Module.PThread = PThread;
        var callRuntimeCallbacks = e => {
            for (; e.length > 0; )
                e.shift()(Module)
        }
          , getCppExceptionTag = () => ___cpp_exception
          , getCppExceptionThrownObjectFromWebAssemblyException = e => {
            var t = e.getArg(getCppExceptionTag(), 0);
            return ___thrown_object_from_unwind_exception(t)
        }
          , establishStackSpace = () => {
            var e = _pthread_self()
              , t = GROWABLE_HEAP_U32()[e + 52 >> 2]
              , r = t - GROWABLE_HEAP_U32()[e + 56 >> 2];
            _emscripten_stack_set_limits(t, r),
            stackRestore(t)
        }
        ;
        function exitOnMainThread(e) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(1, 0, 0, e);
            _exit(e)
        }
        Module.establishStackSpace = establishStackSpace;
        var UTF8ArrayToString = (e, t, r) => {
            for (var i = t + r, n = ""; !(t >= i); ) {
                var o = e[t++];
                if (!o)
                    break;
                if (!(128 & o)) {
                    n += String.fromCharCode(o);
                    continue
                }
                var a = 63 & e[t++];
                if ((224 & o) == 192) {
                    n += String.fromCharCode((31 & o) << 6 | a);
                    continue
                }
                var s = 63 & e[t++];
                if ((o = (240 & o) == 224 ? (15 & o) << 12 | a << 6 | s : (7 & o) << 18 | a << 12 | s << 6 | 63 & e[t++]) < 65536)
                    n += String.fromCharCode(o);
                else {
                    var u = o - 65536;
                    n += String.fromCharCode(55296 | u >> 10, 56320 | 1023 & u)
                }
            }
            return n
        }
          , getDylinkMetadata = e => {
            var t = 0
              , r = 0;
            function i() {
                return e[t++]
            }
            function n() {
                for (var r = 0, i = 1; ; ) {
                    var n = e[t++];
                    if (r += (127 & n) * i,
                    i *= 128,
                    !(128 & n))
                        break
                }
                return r
            }
            function o() {
                var r = n();
                return t += r,
                UTF8ArrayToString(e, t - r, r)
            }
            function a(e, t) {
                if (e)
                    throw Error(t)
            }
            var s = "dylink.0";
            if (e instanceof WebAssembly.Module) {
                var u = WebAssembly.Module.customSections(e, s);
                0 === u.length && (s = "dylink",
                u = WebAssembly.Module.customSections(e, s)),
                a(0 === u.length, "need dylink section"),
                r = (e = new Uint8Array(u[0])).length
            } else {
                a(0x6d736100 != new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0], "need to see wasm magic number"),
                a(0 !== e[8], "need the dylink section to be first"),
                t = 9;
                var l = n();
                r = t + l,
                s = o()
            }
            var c = {
                neededDynlibs: [],
                tlsExports: new Set,
                weakImports: new Set
            };
            if ("dylink" == s) {
                c.memorySize = n(),
                c.memoryAlign = n(),
                c.tableSize = n(),
                c.tableAlign = n();
                for (var p = n(), d = 0; d < p; ++d) {
                    var f = o();
                    c.neededDynlibs.push(f)
                }
            } else {
                a("dylink.0" !== s);
                for (var m = 1, h = 2, g = 3, _ = 4, v = 256, x = 3, b = 1; t < r; ) {
                    var y = i()
                      , w = n();
                    if (y === m)
                        c.memorySize = n(),
                        c.memoryAlign = n(),
                        c.tableSize = n(),
                        c.tableAlign = n();
                    else if (y === h) {
                        for (var p = n(), d = 0; d < p; ++d)
                            f = o(),
                            c.neededDynlibs.push(f)
                    } else if (y === g) {
                        for (var T = n(); T--; ) {
                            var S = o()
                              , C = n();
                            C & v && c.tlsExports.add(S)
                        }
                    } else if (y === _) {
                        for (var T = n(); T--; ) {
                            o();
                            var S = o()
                              , C = n();
                            (C & x) == b && c.weakImports.add(S)
                        }
                    } else
                        t += w
                }
            }
            return c
        }
          , UTF8ToString = (e, t) => e ? UTF8ArrayToString(GROWABLE_HEAP_U8(), e, t) : ""
          , getExceptionMessageCommon = e => withStackSave( () => {
            var t, r = stackAlloc(4), i = stackAlloc(4);
            ___get_exception_message(e, r, i);
            var n = GROWABLE_HEAP_U32()[r >> 2]
              , o = GROWABLE_HEAP_U32()[i >> 2]
              , a = UTF8ToString(n);
            return _free(n),
            o && (t = UTF8ToString(o),
            _free(o)),
            [a, t]
        }
        )
          , getExceptionMessage = e => getExceptionMessageCommon(getCppExceptionThrownObjectFromWebAssemblyException(e));
        Module.getExceptionMessage = getExceptionMessage;
        var wasmTable = new WebAssembly.Table({
            initial: 81610,
            element: "anyfunc"
        })
          , getWasmTableEntry = e => wasmTable.get(e)
          , invokeEntryPoint = (e, t) => {
            __emscripten_dlsync_self(),
            function e(e) {
                keepRuntimeAlive() ? PThread.setExitStatus(e) : __emscripten_thread_exit(e)
            }(getWasmTableEntry(e)(t))
        }
        ;
        Module.invokeEntryPoint = invokeEntryPoint;
        var newDSO = (e, t, r) => {
            var i = {
                refcount: 1 / 0,
                name: e,
                exports: r,
                global: !0
            };
            return LDSO.loadedLibsByName[e] = i,
            void 0 != t && (LDSO.loadedLibsByHandle[t] = i),
            i
        }
          , LDSO = {
            loadedLibsByName: {},
            loadedLibsByHandle: {},
            init() {
                newDSO("__main__", 0, wasmImports)
            }
        }
          , ___heap_base = 0x1644330
          , alignMemory = (e, t) => Math.ceil(e / t) * t
          , getMemory = e => {
            if (runtimeInitialized)
                return zeroMemory(_malloc(e), e);
            var t = ___heap_base
              , r = t + alignMemory(e, 16);
            return ___heap_base = r,
            GOT.__heap_base.value = r,
            t
        }
          , isInternalSym = e => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(e) || e.startsWith("__em_js__")
          , uleb128Encode = (e, t) => {
            e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7)
        }
          , sigToWasmTypes = e => {
            for (var t = {
                i: "i32",
                j: "i64",
                f: "f32",
                d: "f64",
                e: "externref",
                p: "i32"
            }, r = {
                parameters: [],
                results: "v" == e[0] ? [] : [t[e[0]]]
            }, i = 1; i < e.length; ++i)
                r.parameters.push(t[e[i]]);
            return r
        }
          , generateFuncType = (e, t) => {
            var r = e.slice(0, 1)
              , i = e.slice(1)
              , n = {
                i: 127,
                p: 127,
                j: 126,
                f: 125,
                d: 124,
                e: 111
            };
            t.push(96),
            uleb128Encode(i.length, t);
            for (var o = 0; o < i.length; ++o)
                t.push(n[i[o]]);
            "v" == r ? t.push(0) : t.push(1, n[r])
        }
          , convertJsFunctionToWasm = (e, t) => {
            if ("function" == typeof WebAssembly.Function)
                return new WebAssembly.Function(sigToWasmTypes(t),e);
            var r = [1];
            generateFuncType(t, r);
            var i = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            uleb128Encode(r.length, i),
            i.push(...r),
            i.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
            var n = new WebAssembly.Module(new Uint8Array(i));
            return new WebAssembly.Instance(n,{
                e: {
                    f: e
                }
            }).exports.f
        }
          , updateTableMap = (e, t) => {
            if (functionsInTableMap)
                for (var r = e; r < e + t; r++) {
                    var i = getWasmTableEntry(r);
                    i && functionsInTableMap.set(i, r)
                }
        }
          , getFunctionAddress = e => (!functionsInTableMap && (functionsInTableMap = new WeakMap,
        updateTableMap(0, wasmTable.length)),
        functionsInTableMap.get(e) || 0)
          , freeTableIndexes = []
          , getEmptyTableSlot = () => {
            if (freeTableIndexes.length)
                return freeTableIndexes.pop();
            try {
                wasmTable.grow(1)
            } catch (e) {
                if (!(e instanceof RangeError))
                    throw e;
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."
            }
            return wasmTable.length - 1
        }
          , setWasmTableEntry = (e, t) => wasmTable.set(e, t)
          , addFunction = (e, t) => {
            var r = getFunctionAddress(e);
            if (r)
                return r;
            var i = getEmptyTableSlot();
            try {
                setWasmTableEntry(i, e)
            } catch (r) {
                if (!(r instanceof TypeError))
                    throw r;
                setWasmTableEntry(i, convertJsFunctionToWasm(e, t))
            }
            return functionsInTableMap.set(e, i),
            i
        }
          , updateGOT = (e, t) => {
            for (var r in e) {
                if (!isInternalSym(r)) {
                    var i = e[r];
                    GOT[r] ||= new WebAssembly.Global({
                        value: "i32",
                        mutable: !0
                    }),
                    (t || 0 == GOT[r].value) && ("function" == typeof i ? GOT[r].value = addFunction(i) : "number" == typeof i ? GOT[r].value = i : err(`unhandled export type for '${r}': ${typeof i}`))
                }
            }
        }
          , relocateExports = (e, t, r) => {
            var i = {};
            for (var n in e) {
                var o = e[n];
                "object" == typeof o && (o = o.value),
                "number" == typeof o && (o += t),
                i[n] = o
            }
            return updateGOT(i, r),
            i
        }
          , isSymbolDefined = e => {
            var t = wasmImports[e];
            return !!t && !t.stub && !0
        }
          , resolveGlobalSymbol = (e, t=!1) => {
            var r;
            return isSymbolDefined(e) && (r = wasmImports[e]),
            {
                sym: r,
                name: e
            }
        }
          , loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
            var metadata = getDylinkMetadata(binary);
            function loadModule() {
                var moduleExports, firstLoad = !handle || !GROWABLE_HEAP_I8()[handle + 8];
                if (firstLoad) {
                    var memAlign = Math.pow(2, metadata.memoryAlign)
                      , memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0
                      , tableBase = metadata.tableSize ? wasmTable.length : 0;
                    handle && (GROWABLE_HEAP_I8()[handle + 8] = 1,
                    GROWABLE_HEAP_U32()[handle + 12 >> 2] = memoryBase,
                    GROWABLE_HEAP_I32()[handle + 16 >> 2] = metadata.memorySize,
                    GROWABLE_HEAP_U32()[handle + 20 >> 2] = tableBase,
                    GROWABLE_HEAP_I32()[handle + 24 >> 2] = metadata.tableSize)
                } else
                    memoryBase = GROWABLE_HEAP_U32()[handle + 12 >> 2],
                    tableBase = GROWABLE_HEAP_U32()[handle + 20 >> 2];
                var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
                function resolveSymbol(e) {
                    var t = resolveGlobalSymbol(e).sym;
                    return !t && localScope && (t = localScope[e]),
                    !t && (t = moduleExports[e]),
                    t
                }
                tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
                var proxyHandler = {
                    get(e, t) {
                        switch (t) {
                        case "__memory_base":
                            return memoryBase;
                        case "__table_base":
                            return tableBase
                        }
                        if (t in wasmImports && !wasmImports[t].stub)
                            return wasmImports[t];
                        if (!(t in e)) {
                            var r;
                            e[t] = (...e) => (r ||= resolveSymbol(t))(...e)
                        }
                        return e[t]
                    }
                }
                  , proxy = new Proxy({},proxyHandler)
                  , info = {
                    "GOT.mem": new Proxy({},GOTHandler),
                    "GOT.func": new Proxy({},GOTHandler),
                    env: proxy,
                    wasi_snapshot_preview1: proxy
                };
                function postInstantiation(module, instance) {
                    function addEmAsm(addr, body) {
                        for (var args = [], arity = 0; arity < 16; arity++)
                            if (-1 != body.indexOf("$" + arity))
                                args.push("$" + arity);
                            else
                                break;
                        args = args.join(",");
                        var func = `(${args}) => { ${body} };`;
                        ASM_CONSTS[start] = eval(func)
                    }
                    if (!ENVIRONMENT_IS_PTHREAD && libName && (sharedModules[libName] = module),
                    updateTableMap(tableBase, metadata.tableSize),
                    moduleExports = relocateExports(instance.exports, memoryBase),
                    !flags.allowUndefined && reportUndefinedSymbols(),
                    "__start_em_asm"in moduleExports) {
                        for (var start = moduleExports.__start_em_asm, stop = moduleExports.__stop_em_asm; start < stop; ) {
                            var jsString = UTF8ToString(start);
                            addEmAsm(start, jsString),
                            start = GROWABLE_HEAP_U8().indexOf(0, start) + 1
                        }
                    }
                    function addEmJs(name, cSig, body) {
                        var jsArgs = [];
                        if (cSig = cSig.slice(1, -1),
                        "void" != cSig)
                            for (var i in cSig = cSig.split(",")) {
                                var jsArg = cSig[i].split(" ").pop();
                                jsArgs.push(jsArg.replace("*", ""))
                            }
                        var func = `(${jsArgs}) => ${body};`;
                        moduleExports[name] = eval(func)
                    }
                    for (var name in moduleExports)
                        if (name.startsWith("__em_js__")) {
                            var start = moduleExports[name]
                              , jsString = UTF8ToString(start)
                              , parts = jsString.split("<::>");
                            addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]),
                            delete moduleExports[name]
                        }
                    if (registerTLSInit(moduleExports._emscripten_tls_init, instance.exports, metadata),
                    firstLoad) {
                        var applyRelocs = moduleExports.__wasm_apply_data_relocs;
                        applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
                        var init = moduleExports.__wasm_call_ctors;
                        init && (runtimeInitialized ? init() : __ATINIT__.push(init))
                    }
                    return moduleExports
                }
                if (flags.loadAsync) {
                    if (binary instanceof WebAssembly.Module) {
                        var instance = new WebAssembly.Instance(binary,info);
                        return Promise.resolve(postInstantiation(binary, instance))
                    }
                    return WebAssembly.instantiate(binary, info).then(e => postInstantiation(e.module, e.instance))
                }
                var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary)
                  , instance = new WebAssembly.Instance(module,info);
                return postInstantiation(module, instance)
            }
            return (currentModuleWeakSymbols = metadata.weakImports,
            flags.loadAsync) ? metadata.neededDynlibs.reduce( (e, t) => e.then( () => loadDynamicLibrary(t, flags)), Promise.resolve()).then(loadModule) : (metadata.neededDynlibs.forEach(e => loadDynamicLibrary(e, flags, localScope)),
            loadModule())
        }
          , mergeLibSymbols = (e, t) => {
            for (var [r,i] of Object.entries(e)) {
                let e = e => {
                    !isSymbolDefined(e) && (wasmImports[e] = i)
                }
                ;
                e(r);
                let t = "__main_argc_argv";
                "main" == r && e(t),
                r == t && e("main"),
                r.startsWith("dynCall_") && !Module.hasOwnProperty(r) && (Module[r] = i)
            }
        }
          , asyncLoad = (e, t, r, i) => {
            var n = i ? "" : getUniqueRunDependency(`al ${e}`);
            readAsync(e, e => {
                t(new Uint8Array(e)),
                n && removeRunDependency(n)
            }
            , t => {
                if (r)
                    r();
                else
                    throw `Loading data file "${e}" failed.`
            }
            ),
            n && addRunDependency(n)
        }
          , preloadPlugins = Module.preloadPlugins || []
          , registerWasmPlugin = () => {
            var e = {
                promiseChainEnd: Promise.resolve(),
                canHandle: e => !Module.noWasmDecoding && e.endsWith(".so"),
                handle: (t, r, i, n) => {
                    e.promiseChainEnd = e.promiseChainEnd.then( () => loadWebAssemblyModule(t, {
                        loadAsync: !0,
                        nodelete: !0
                    }, r)).then(e => {
                        preloadedWasm[r] = e,
                        i(t)
                    }
                    , e => {
                        err(`failed to instantiate wasm: ${r}: ${e}`),
                        n()
                    }
                    )
                }
            };
            preloadPlugins.push(e)
        }
          , preloadedWasm = {};
        function loadDynamicLibrary(e, t={
            global: !0,
            nodelete: !0
        }, r, i) {
            var n = LDSO.loadedLibsByName[e];
            if (n)
                return t.global ? !n.global && (n.global = !0,
                mergeLibSymbols(n.exports, e)) : r && Object.assign(r, n.exports),
                t.nodelete && n.refcount !== 1 / 0 && (n.refcount = 1 / 0),
                n.refcount++,
                i && (LDSO.loadedLibsByHandle[i] = n),
                !t.loadAsync || Promise.resolve(!0);
            function o() {
                var r = sharedModules[e];
                if (r)
                    return t.loadAsync ? Promise.resolve(r) : r;
                if (i) {
                    var n = GROWABLE_HEAP_U32()[i + 28 >> 2]
                      , o = GROWABLE_HEAP_U32()[i + 32 >> 2];
                    if (n && o) {
                        var a = GROWABLE_HEAP_I8().slice(n, n + o);
                        return t.loadAsync ? Promise.resolve(a) : a
                    }
                }
                var s = locateFile(e);
                return t.loadAsync ? new Promise(function(e, t) {
                    asyncLoad(s, e, t)
                }
                ) : Module.binaryDynamicLibraries[s]
            }
            function a() {
                var n = preloadedWasm[e];
                return n ? t.loadAsync ? Promise.resolve(n) : n : t.loadAsync ? o().then(n => loadWebAssemblyModule(n, t, e, r, i)) : loadWebAssemblyModule(o(), t, e, r, i)
            }
            function s(t) {
                n.global ? mergeLibSymbols(t, e) : r && Object.assign(r, t),
                n.exports = t
            }
            return ((n = newDSO(e, i, "loading")).refcount = t.nodelete ? 1 / 0 : 1,
            n.global = t.global,
            t.loadAsync) ? a().then(e => (s(e),
            !0)) : (s(a()),
            !0)
        }
        var reportUndefinedSymbols = () => {
            for (var [e,t] of Object.entries(GOT))
                if (0 == t.value) {
                    var r = resolveGlobalSymbol(e, !0).sym;
                    if (!r && !t.required)
                        continue;
                    if ("function" == typeof r)
                        t.value = addFunction(r, r.sig);
                    else if ("number" == typeof r)
                        t.value = r;
                    else
                        throw Error(`bad export type for '${e}': ${typeof r}`)
                }
        }
          , loadDylibs = () => {
            if (!dynamicLibraries.length) {
                reportUndefinedSymbols();
                return
            }
            addRunDependency("loadDylibs"),
            dynamicLibraries.reduce( (e, t) => e.then( () => loadDynamicLibrary(t, {
                loadAsync: decideDynamicLibloadAsync(),
                global: !0,
                nodelete: !0,
                allowUndefined: !0
            })), Promise.resolve()).then( () => {
                reportUndefinedSymbols(),
                removeRunDependency("loadDylibs")
            }
            ).catch(e => {
                abort(e)
            }
            )
        }
          , noExitRuntime = Module.noExitRuntime || !0
          , registerTLSInit = (e, t, r) => {
            function i() {
                var i = e();
                if (!!i) {
                    var n = {};
                    r.tlsExports.forEach(e => n[e] = t[e]),
                    relocateExports(n, i, !0)
                }
            }
            PThread.tlsInitFunctions.push(i),
            runtimeInitialized && i()
        }
        ;
        function _CancelHttp(e) {
            let t = xmlHttpRequestMap[e];
            return null != t && t.abort(),
            0
        }
        _CancelHttp.sig = "ii";
        var TEJSImageDecoder = {
            imageBitmapSet: {},
            imageBitmapCacheSet: {},
            heicOffscreenCanvasSet: {}
        };
        function _ImageBitmapBindToTexture(e) {
            let t = Module.UTF8ToString(e);
            null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {});
            let r = TEJSImageDecoder.imageBitmapSet[t];
            return r ? (GLctx.pixelStorei(GLctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
            GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, r),
            GLctx.pixelStorei(GLctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            0) : -1
        }
        function _SendHttp(e, t, r, i) {
            let n = Module.UTF8ToString(e)
              , o = new XMLHttpRequest;
            function a() {
                let e = o.getResponseHeader("content-range").split("/");
                e.length < 2 && Module.out("Parse range error");
                let t = parseInt(e[1])
                  , r = new Uint8Array(o.response);
                var n = r.length * r.BYTES_PER_ELEMENT
                  , a = Module._malloc(n)
                  , s = new Uint8Array(GROWABLE_HEAP_U8().buffer,a,n);
                s.set(new Uint8Array(r.buffer)),
                Module.ccall("SendHttpOnLoad", "number", ["number", "number", "number", "number", "number"], [i, s.byteOffset, n, parseInt(o.status), t]),
                Module._free(a),
                null != xmlHttpRequestMap[o.xmlHttpRequestIndex] && delete xmlHttpRequestMap[o.xmlHttpRequestIndex]
            }
            function s() {
                Module.ccall("SendHttpOnError", "number", ["number", "number"], [i, parseInt(o.status)]),
                null != xmlHttpRequestMap[o.xmlHttpRequestIndex] && delete xmlHttpRequestMap[o.xmlHttpRequestIndex]
            }
            return o.open("GET", n, !0),
            o.responseType = "arraybuffer",
            o.setRequestHeader("Range", "bytes=" + t + "-" + r),
            o.onload = a,
            o.onerror = s,
            o.send(),
            ++xmlHttpRequestIndex <= 0 && (xmlHttpRequestIndex = 0),
            xmlHttpRequestMap[xmlHttpRequestIndex] = o,
            o.xmlHttpRequestIndex = xmlHttpRequestIndex,
            xmlHttpRequestIndex
        }
        function _TEAudioWorkletClearCache(e) {
            return void 0 !== globalThis.ringBuffer ? (console.log(`worklet clearing ring buffer ${globalThis.ringBuffer.availableRead()} will be discarded`),
            globalThis.ringBuffer.clear(),
            0) : -1
        }
        function _TEAudioWorkletGetVolume() {
            return ENVIRONMENT_IS_WEB ? TEGetAudioWorkletVolume() : 1
        }
        function _TEAudioWorkletPause(e) {
            if (self.postMessage({
                cmd: "pause_audio_worklet",
                userData: e
            }),
            void 0 !== globalThis.ringBuffer) {
                let e = new Float32Array(globalThis.ringBuffer.availableRead());
                globalThis.ringBuffer.pop(e, e.length),
                console.log(`worklet remove ${e.length} samples from ring buffer`)
            }
            return console.log("worklet pause post"),
            0
        }
        function _TEAudioWorkletPushSamples(e, t, r) {
            try {
                if (globalThis.ringBuffer.availableWrite() < r * globalThis.channelCount)
                    return -1;
                if (t >= GROWABLE_HEAP_F32().buffer.byteLength)
                    return console.error(`worklet pushing, heap size ${GROWABLE_HEAP_F32().buffer.byteLength}, ptr ${t}`),
                    0;
                return globalThis.ringBuffer.push(GROWABLE_HEAP_F32(), r * globalThis.channelCount, t / Float32Array.BYTES_PER_ELEMENT),
                0
            } catch (e) {
                return console.error(e),
                -2
            }
        }
        function _TEAudioWorkletResume(e) {
            return self.postMessage({
                cmd: "resume_audio_worklet",
                userData: e
            }),
            console.log("worklet resume post"),
            0
        }
        function _TEAudioWorkletSetVolume(e) {
            return ENVIRONMENT_IS_WEB ? TESetAudioWorkletVolume(e) : -1
        }
        function _TECreateAudioWorklet(e, t, r) {
            if (out(`sampleRate: ${t}, channelCount: ${r}`),
            void 0 !== globalThis.ve_audio_shared_buffer)
                return console.log("try to recreate audio worklet"),
                -1;
            {
                let i = t || 44100
                  , n = RingBuffer.getStorageForCapacity(.05 * i * r, Float32Array);
                return self.postMessage({
                    cmd: "start_audio_worklet",
                    sab: n,
                    sampleRate: t,
                    channelCount: r,
                    userData: e
                }),
                globalThis.ve_audio_shared_buffer = n,
                globalThis.ringBuffer = new RingBuffer(globalThis.ve_audio_shared_buffer,Float32Array),
                globalThis.sampleRate = i,
                globalThis.channelCount = r,
                globalThis.RingBuffer = RingBuffer,
                console.log("create audio worklet"),
                0
            }
        }
        _ImageBitmapBindToTexture.sig = "ip",
        _SendHttp.sig = "ipiip",
        _TEAudioWorkletClearCache.sig = "ip",
        _TEAudioWorkletGetVolume.sig = "f",
        _TEAudioWorkletPause.sig = "ip",
        _TEAudioWorkletPushSamples.sig = "ippi",
        _TEAudioWorkletResume.sig = "ip",
        _TEAudioWorkletSetVolume.sig = "if",
        _TECreateAudioWorklet.sig = "ipii";
        var createWebcodecInit = function(e, t, r, i) {
            let n = {
                output: r => {
                    if (-1 === Object.keys(WebCodecs.decoderSet).indexOf(e)) {
                        r.close();
                        return
                    }
                    let i = WebCodecs.decoderSet[e];
                    if (i.gops.length > 1)
                        for (let e = i.gops.length - 1; e > 0; e--) {
                            let t = i.gops[e];
                            if (t.length > 0) {
                                let n = t[0];
                                if (r.timestamp >= n.timestamp) {
                                    i.gops.splice(0, e);
                                    break
                                }
                            }
                        }
                    WebCodecs.frameCnt++,
                    performance.now() - WebCodecs.lastFrameReport > 1e3 && (console.log("FPS:", WebCodecs.frameCnt, i.decoder.decodeQueueSize),
                    WebCodecs.frameCnt = 0,
                    WebCodecs.lastFrameReport = performance.now());
                    let n = Module.ccall("TEJSEvent_WebCodec_GetFirstTimestamp", "number", ["number"], [i.handle])
                      , o = parseInt(UTF8ToString(n));
                    if (_free(n),
                    o >= 0 && r.timestamp < o || i.flushingAndDrop) {
                        r.close();
                        return
                    }
                    let a = r.timestamp
                      , s = r.displayWidth
                      , u = r.displayHeight
                      , l = -1;
                    "I420" == r.format ? l = 1 : "I422" == r.format ? l = 2 : "NV12" == r.format && (l = 3);
                    let c = 0;
                    if (!i.dropFramePtsSet && (i.dropFramePtsSet = {}),
                    null != i.currentFlushingPromise) {
                        let e = allocateUTF8(i.canvasId);
                        c = Module.ccall("TEJSEvent_WebCodec_Gen_GLTexture", "number", ["number"], [e]),
                        _free(e);
                        let t = GL.currentContext.GLctx;
                        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r),
                        r.close()
                    }
                    let p = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                      , d = Module.UTF8ToString(p);
                    WebCodecs.frameSet[d] = {
                        decoder: i,
                        decoderIndex: e,
                        offscreen: null,
                        glTexture: c,
                        frameIndex: d,
                        frameClosed: !1,
                        time: a,
                        frame: 0 === c ? r : null,
                        canvasId: i.canvasId
                    },
                    i.frameCount++,
                    Module.ccall("TEJSEvent_WebCodec_OnFramesInJSUpdated", null, ["number", "number"], [t, i.frameCount]);
                    let f = allocateUTF8(a.toString())
                      , m = Module.ccall("TEJSEvent_WebCodec_On_Output_HW_Frame", "number", ["number", "number", "number", "string", "number", "number"], [t, s, u, d, f, c]);
                    _free(f),
                    _free(p)
                }
                ,
                error: t => {
                    if (console.error(t),
                    "QuotaExceededError" === t.name) {
                        let t = WebCodecs.decoderSet[e];
                        if ("closed" !== t.decoder.state && err("Origin decoder is not closed"),
                        t.decoder = new VideoDecoder(n),
                        t.decoder.configure(r),
                        t.frameCount = 0,
                        t.sendPacketCount = 0,
                        void 0 !== t.decoder.ondequeue && (t.decoder.ondequeue = i),
                        console.log("Reconfigured with ", r, t.gops),
                        t.gops.length > 0)
                            for (let e of t.gops)
                                for (let r of e)
                                    t.decoder.decode(r)
                    } else if ("OperationError" === t.name && "Decoding error." === t.message) {
                        let t = WebCodecs.decoderSet[e];
                        Module.ccall("TEJSEvent_WebCodec_On_Error", null, ["number", "number"], [t.handle, 2])
                    } else {
                        let t = WebCodecs.decoderSet[e];
                        Module.ccall("TEJSEvent_WebCodec_On_Error", null, ["number", "number"], [t.handle, 1])
                    }
                }
            };
            return n
        }
          , WebCodecs = {
            _showStack: !1,
            frameCnt: 0,
            lastFrameReport: 0,
            frameSet: {},
            _pendingFrame: null,
            _renderAnimationFrame: function() {
                renderer.draw(WebCodecs.pendingFrame),
                WebCodecs.pendingFrame = null
            },
            _putFrame: function(e) {
                WebCodecs.pendingFrame ? WebCodecs.pendingFrame.close() : requestAnimationFrame(WebCodecs.renderAnimationFrame),
                WebCodecs.pendingFrame = e.frame
            },
            closeFrame: function(e) {
                if (e && !e.frameClosed) {
                    if (e.glTexture > 0) {
                        let t = allocateUTF8(e.canvasId);
                        Module.ccall("TEJSEvent_WebCodec_Delete_GLTexture", null, ["number", "number"], [e.glTexture, t]),
                        _free(t)
                    }
                    e.frame && (e.frame.close(),
                    e.frame = null),
                    e.frameClosed = !0
                }
                e && e.frameIndex && delete WebCodecs.frameSet[e.frameIndex],
                0 !== e.decoder.handle && Module.ccall("TEJSEvent_WebCodec_OnFramesInJSUpdated", null, ["number", "number"], [e.decoder.handle, e.decoder.frameCount])
            },
            clearFrames: function(e) {
                Module.ccall("TEJSEvent_WebCodec_Clear_Frames", null, ["number"], [e.handle])
            },
            renderToTexture: function(e) {
                for (let t of Object.values(WebCodecs.frameSet))
                    if (null != t.frame && !t.frameClosed && e == t.decoderIndex) {
                        let e = allocateUTF8(t.canvasId)
                          , r = Module.ccall("TEJSEvent_WebCodec_Gen_GLTexture", "number", ["number"], [e]);
                        _free(e);
                        let i = GL.currentContext.GLctx;
                        i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.frame),
                        t.frame.close(),
                        t.frame = null,
                        t.glTexture = r
                    }
            },
            getFramesCount: function(e) {
                return Module.ccall("TEJSEvent_WebCodec_Get_Frames_Count", "number", ["number"], [e])
            },
            _getTotalNativeFramesCount: function() {
                return Module.ccall("TEJSEvent_WebCodec_GetTotalNativeFrames", "number", [], [])
            },
            _getTotalPtrCount: function() {
                return Module.ccall("TEJSEvent_WebCodec_GetTotalPtrs", "number", [], [])
            },
            ondequeueSupported: -1,
            isOndequeueSupported: function() {
                return -1 !== WebCodecs.ondequeueSupported ? WebCodecs.ondequeueSupported : (WebCodecs.ondequeueSupported = "function" == typeof VideoDecoder && VideoDecoder.prototype.hasOwnProperty("ondequeue"),
                WebCodecs.ondequeueSupported)
            },
            __reclaim: function() {
                for (let e in WebCodecs.decoderSet)
                    WebCodecs.decoderSet[e].__reclaim()
            }
        };
        function _TECreateStack() {
            if (!WebCodecs._showStack || "function" != typeof Error.captureStackTrace)
                return 0;
            let e = Error.prepareStackTrace
              , t = Error.stackTraceLimit;
            Error.stackTraceLimit = 15,
            Error.prepareStackTrace = (e, t) => {
                let r = ["Stack: "];
                for (let e in t) {
                    let i = t[e];
                    i.getFunctionName() && 0 !== i.getFunctionName().indexOf("invoke_") && 0 !== i.getFunctionName().indexOf("_TECreateStack") && r.push(`at ${i.getFunctionName()} (${i.getFileName()}:${i.getLineNumber()}:${i.getColumnNumber()})`)
                }
                return r.join("\n")
            }
            ;
            let r = Error().stack;
            return Error.prepareStackTrace = e,
            Error.stackTraceLimit = t,
            r ? allocateUTF8(r) : 0
        }
        function _TEJSEventFetch_Fetch_Abort(e, t) {
            null == self.fetchSet && (self.fetchSet = {});
            let r = self.fetchSet[e];
            return null == r ? -1 : (Module.out("start abort..."),
            r.abort(),
            0)
        }
        function _TEJSEventFetch_Fetch_Send(e, t, r, i, n, o, a) {
            null == self.fetchSet && (self.fetchSet = {});
            let s = Module.UTF8ToString(e)
              , u = Module.UTF8ToString(t)
              , l = Module.UTF8ToString(i)
              , c = new Headers;
            try {
                let e = JSON.parse(u);
                if (null != e)
                    for (let t in e)
                        c.append(t, e[t])
            } catch (e) {
                Module.out("Error parsing headers:", e)
            }
            n >= 0 && o >= n && c.append("Range", "bytes=" + n + "-" + o);
            let p = {
                method: "GET",
                headers: c,
                credentials: 0 === r ? "omit" : "include"
            };
            if (null != l && void 0 != l && "" != l)
                try {
                    let e = JSON.parse(l);
                    for (let t in !e.headers && (e.headers = {}),
                    c)
                        e.headers.append(t, c[t]);
                    p = e
                } catch (e) {
                    Module.err("Error parsing fetchOption:", e)
                }
            let d = new AbortController;
            p.signal = d.signal,
            fetch(s, p).then(e => {
                if (e.status < 200 || e.status >= 300)
                    Module.ccall("TEJSEventFetch_Fetch_OnFail", "number", ["number", "number"], [a, e.status]);
                else {
                    function t(e) {
                        let[t,r] = e.split(" ")[1].split("/")
                          , [i,n] = t.split("-").map(Number)
                          , o = n - i + 1;
                        return {
                            rangeStart: i,
                            rangeEnd: n,
                            contentLength: o,
                            totalSize: Number(r)
                        }
                    }
                    let i = -1
                      , s = e.headers.get("content-length");
                    null != s && (i = parseInt(s));
                    let u = -1
                      , l = e.headers.get("content-range");
                    if (null != l) {
                        let e = t(l);
                        e.totalSize > 0 ? u = e.totalSize : Module.err("parse content range to get total size error, range " + l),
                        i <= 0 && (i = e.contentLength) <= 0 && (Module.err("parse content length from range still error, range " + l),
                        i = o - n)
                    }
                    Module.ccall("TEJSEventFetch_Fetch_OnHeaderReceived", "number", ["number", "number", "number", "number"], [a, e.status, u, i]);
                    let c = e.body.getReader();
                    function r({done: e, value: t}) {
                        if (e) {
                            Module.ccall("TEJSEventFetch_Fetch_OnBodyDone", "number", ["number"], [a]);
                            return
                        }
                        let i = Module._malloc(t.length);
                        return GROWABLE_HEAP_U8().set(t, i),
                        Module.ccall("TEJSEventFetch_Fetch_OnBodyProgress", "number", ["number", "number", "number"], [a, i, t.length]),
                        Module._free(i),
                        c.read().then(r)
                    }
                    return c.read().then(r)
                }
            }
            ).catch(e => {
                if (Module.out(`StreamEdit TEVirtualResourceFetch error:${e} when fetch ${s} , options:${JSON.stringify(p)} `),
                "AbortError" === e.name) {
                    Module.out("AbortError");
                    return
                }
                Module.ccall("TEJSEventFetch_Fetch_OnFail", "number", ["number", "number"], [a, -1])
            }
            );
            let f = 1;
            for (; ; ) {
                if (f <= 0 && (f = 1),
                null == self.fetchSet[f]) {
                    self.fetchSet[f] = d;
                    break
                }
                f++
            }
            return f
        }
        function createReaderContext() {
            function e() {
                this._handle = 0,
                this._blob = null,
                this._cursor = 0,
                this._objUrl = null,
                this._size = 0,
                this._lastModified = 0,
                this._type = ""
            }
            return e.prototype.open = function(e, t) {
                this._handle = t,
                this._objUrl = e;
                let r = BlobMapper.map[e];
                return r ? (this._blob = r,
                this._size = this._blob.size,
                r instanceof File && (r.lastModified,
                r.type,
                this._lastModified = this._blob.lastModified,
                this._type = this._blob.type),
                out(`[js] open url ${e}, file size:${this._size}, 0x${this._handle.toString(16)}`),
                this._size) : (err(`can not find blob of :${e}`),
                -1)
            }
            ,
            e.prototype.close = function() {
                this._blob = null,
                this._cursor = 0
            }
            ,
            e.prototype.read = function(e, t) {
                let r = this._blob.slice(this._cursor, this._cursor + t);
                return new Promise( (t, i) => r.arrayBuffer().then(i => {
                    this._cursor += r.size;
                    let n = new Uint8Array(i);
                    GROWABLE_HEAP_U8().set(n, e),
                    t([r.size])
                }
                ).catch(e => {
                    i(e)
                }
                ))
            }
            ,
            e.prototype.seek = function(e) {
                return e < 0 || e > this._size ? -1 : (this._cursor = e,
                this._cursor)
            }
            ,
            new e
        }
        _TECreateStack.sig = "p",
        _TEJSEventFetch_Fetch_Abort.sig = "iip",
        _TEJSEventFetch_Fetch_Send.sig = "ippipiip";
        var BlobReaderManager = {
            _ctxs: {},
            getReaderCtx: function(e) {
                for (let t in BlobReaderManager._ctxs)
                    if (t == e)
                        return BlobReaderManager._ctxs[t];
                return null
            },
            addCtx: function(e, t) {
                let r = BlobReaderManager.getReaderCtx(e);
                null != r && (r.close(),
                r = null),
                BlobReaderManager._ctxs[e] = t
            },
            deleteCtx: function(e) {
                for (let t in out(`delete context, handle:${e}`),
                BlobReaderManager._ctxs)
                    t == e && (BlobReaderManager._ctxs[t].close(),
                    delete BlobReaderManager._ctxs[t])
            }
        }
          , BlobMapper = {
            map: {},
            insertBlob: function(e, t) {
                BlobMapper.map[e] = t
            },
            removeBlob: function(e) {
                delete BlobMapper.map[e]
            }
        };
        function _TEJSEvent_BlobClose(e) {
            out(`[js] close handle:0x${e.toString(16)}`),
            BlobReaderManager.deleteCtx(e)
        }
        function _TEJSEvent_BlobOpen(e, t) {
            let r = UTF8ToString(e)
              , i = createReaderContext()
              , n = i.open(r, t);
            return BlobReaderManager.addCtx(t, i),
            allocateUTF8(n.toString())
        }
        function _TEJSEvent_BlobOpen_GetLastModified(e) {
            let t = BlobReaderManager.getReaderCtx(e);
            return null == t ? allocateUTF8("0") : allocateUTF8(t._lastModified.toString())
        }
        function _TEJSEvent_BlobOpen_GetType(e) {
            let t = BlobReaderManager.getReaderCtx(e);
            return null == t ? allocateUTF8("null/null") : allocateUTF8(t._type)
        }
        function _TEJSEvent_BlobRead(e, t, r, i) {
            let n = BlobReaderManager.getReaderCtx(t);
            if (null == n) {
                err(`ctx not found! handle:${t}`),
                Module.ccall("TEJSEvent_OnBlobReadResult", null, ["number", "number"], [e, -1]);
                return
            }
            n.read(r, i).then( ([t]) => {
                Module.ccall("TEJSEvent_OnBlobReadResult", null, ["number", "number"], [e, t])
            }
            ).catch(t => {
                Module.ccall("TEJSEvent_OnBlobReadResult", null, ["number", "number"], [e, -1])
            }
            )
        }
        function _TEJSEvent_BlobSeek(e, t) {
            let r = parseInt(UTF8ToString(t))
              , i = BlobReaderManager.getReaderCtx(e);
            return null == i ? (err(`ctx not found! url:${UTF8ToString(url)}, handle:${e}`),
            allocateUTF8("-1")) : allocateUTF8(i.seek(r).toString())
        }
        function _TEJSEvent_Blob_Direct_GetType(e) {
            let t = UTF8ToString(e)
              , r = BlobMapper.map[t];
            return r ? r instanceof File ? allocateUTF8(r.type) : allocateUTF8("null/null") : allocateUTF8("null/null")
        }
        function _TEJSEvent_Fetch_Abort(e) {
            null == self.fetchControllerSet && (self.fetchControllerSet = {});
            let t = self.fetchControllerSet[e];
            if (null == t)
                return -1;
            console.debug("will abort fetch " + e);
            try {
                t.abort()
            } catch (e) {
                console.warn("te fetch error: " + e)
            }
            return delete self.fetchControllerSet[e],
            0
        }
        _TEJSEvent_BlobClose.sig = "vp",
        _TEJSEvent_BlobOpen.sig = "ppp",
        _TEJSEvent_BlobOpen_GetLastModified.sig = "pp",
        _TEJSEvent_BlobOpen_GetType.sig = "pp",
        _TEJSEvent_BlobRead.sig = "vpppi",
        _TEJSEvent_BlobSeek.sig = "ppp",
        _TEJSEvent_Blob_Direct_GetType.sig = "pp",
        _TEJSEvent_Fetch_Abort.sig = "ip";
        var _TEJSEvent_HEIC_Decode_Init = function(e, t, r, i, n, o, a, s, u, l, c, p, d) {
            let f, m = Module.UTF8ToString(e), h = Module.UTF8ToString(t), g = Module.UTF8ToString(u), _ = new Uint8Array(GROWABLE_HEAP_U8().subarray(l, l + c)), v = {
                output: e => {
                    let t = e.displayWidth
                      , u = e.displayHeight
                      , l = TEJSImageDecoder.heicOffscreenCanvasSet[h];
                    if (!l && ((l = new OffscreenCanvas(r,i)).tileRenderedNum = 0,
                    TEJSImageDecoder.heicOffscreenCanvasSet[h] = l),
                    l.getContext("2d").drawImage(e, n * t, o * u, t, u),
                    l.tileRenderedNum++,
                    e.close(),
                    l.tileRenderedNum >= s) {
                        let e = l;
                        if (0 == a)
                            e = l;
                        else if (90 == a) {
                            let t = (e = new OffscreenCanvas(l.height,l.width)).getContext("2d")
                              , r = l.transferToImageBitmap();
                            t.rotate(-90 * Math.PI / 180),
                            t.drawImage(r, -r.width, 0, r.width, r.height)
                        } else if (180 == a) {
                            let t = (e = new OffscreenCanvas(l.width,l.height)).getContext("2d")
                              , r = l.transferToImageBitmap();
                            t.rotate(180 * Math.PI / 180),
                            t.drawImage(r, -r.width, -r.height, r.width, r.height)
                        } else if (270 == a) {
                            let t = (e = new OffscreenCanvas(l.height,l.width)).getContext("2d")
                              , r = l.transferToImageBitmap();
                            t.rotate(90 * Math.PI / 180),
                            t.drawImage(r, 0, -r.height, r.width, r.height)
                        }
                        if (0 == p) {
                            let t = new Uint8Array(e.getContext("2d").getImageData(0, 0, e.width, e.height).data);
                            if (t.length > 0) {
                                let r = t.length * t.BYTES_PER_ELEMENT
                                  , i = Module._malloc(r);
                                GROWABLE_HEAP_U8().set(t, i),
                                Module.ccall("TEJSEvent_HEIC_Decode_Succ_With_RGBA", "number", ["number", "number", "number", "number", "number"], [d, i, r, e.width, e.height])
                            } else
                                Module.ccall("TEJSEvent_Image_Decode_Fail", "number", ["number"], [d])
                        } else if (1 == p) {
                            let t = e.transferToImageBitmap();
                            console.log(t);
                            let r = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                              , i = Module.UTF8ToString(r);
                            TEJSImageDecoder.imageBitmapSet[i] = t,
                            t.srcWidth = t.width,
                            t.srcHeight = t.height,
                            t.cacheKey = m,
                            t.updateTime = (new Date).valueOf(),
                            Module.ccall("TEJSEvent_HEIC_Decode_Succ_With_Bitmap", null, ["number", "string", "number", "number", "number"], [d, i, t.width, t.height, 0]),
                            _free(r)
                        }
                        delete TEJSImageDecoder.heicOffscreenCanvasSet[h]
                    } else
                        Module.ccall("TEJSEvent_HEIC_Decode_Succ", null, ["number"], [d])
                }
                ,
                error: e => {
                    Module.ccall("TEJSEvent_HEIC_Decode_Fail", null, ["number"], [d])
                }
            }, x = {
                codec: g
            };
            try {
                f = VideoDecoder.isConfigSupported(x)
            } catch (e) {
                console.log("VideoDecoder.isConfigSupported error, ", e)
            }
            return f ? (f.then(e => {
                if (e.supported) {
                    let e = new VideoDecoder(v);
                    e.configure(x);
                    let t = new EncodedVideoChunk({
                        timestamp: 0,
                        type: "key",
                        data: _
                    });
                    e.decode(t),
                    e.flush().then( () => {
                        e.close()
                    }
                    ).catch(e => {
                        console.log("TEJSEvent_HEIC_Decode flush, ", e)
                    }
                    )
                } else
                    console.log("The codec id is not supported", x),
                    Module.ccall("TEJSEvent_HEIC_Decode_Fail", null, ["number"], [d])
            }
            ).catch(e => {
                console.log("The codec id is not supported", x),
                Module.ccall("TEJSEvent_HEIC_Decode_Fail", null, ["number"], [d])
            }
            ),
            0) : (Module.ccall("TEJSEvent_HEIC_Decode_Fail", null, ["number"], [d]),
            0)
        };
        function _TEJSEvent_HEIC_Get_From_Cache(e, t) {
            let r = Module.UTF8ToString(e)
              , i = TEJSImageDecoder.imageBitmapCacheSet[r];
            if (i) {
                delete TEJSImageDecoder.imageBitmapCacheSet[r];
                let e = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                  , n = Module.UTF8ToString(e);
                null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {}),
                TEJSImageDecoder.imageBitmapSet[n] = i;
                let o = i.width;
                i.srcWidth && (o = i.srcWidth);
                let a = i.height;
                i.srcHeight && (a = i.srcHeight),
                i.updateTime = (new Date).valueOf(),
                Module.ccall("TEJSEvent_HEIC_Get_From_Cache_Succ", null, ["number", "string", "number", "number"], [t, n, o, a]),
                _free(e)
            } else
                Module.ccall("TEJSEvent_HEIC_Get_From_Cache_Fail", null, ["number"], [t]);
            return 0
        }
        function _TEJSEvent_HTTPRequest_Abort(e, t) {
            null == self.xmlHttpRequestSet && (self.xmlHttpRequestSet = {});
            let r = self.xmlHttpRequestSet[e];
            return null == r ? -1 : (r.abort(),
            0)
        }
        function _TEJSEvent_HTTPRequest_Send(e, t, r, i, n, o) {
            let a = Module.UTF8ToString(e)
              , s = Module.UTF8ToString(t)
              , u = new XMLHttpRequest;
            u.open("GET", a, !0),
            u.responseType = "arraybuffer",
            0 == r ? u.withCredentials = !1 : u.withCredentials = !0;
            try {
                let e = JSON.parse(s);
                if (null != e)
                    for (let t in e)
                        u.setRequestHeader(t, e[t])
            } catch (e) {}
            i >= 0 && n >= i && u.setRequestHeader("Range", "bytes=" + i + "-" + n),
            u.onreadystatechange = function() {
                if (u.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                    let e = -1
                      , t = u.getResponseHeader("content-range");
                    if (null != t) {
                        let r = t.split("/");
                        r.length < 2 ? Module.out("Parse range error") : e = parseInt(r[1])
                    }
                    let r = -1
                      , i = u.getResponseHeader("content-length");
                    null != i && (r = parseInt(i)),
                    Module.ccall("TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED", "number", ["number", "number", "number", "number"], [o, u.status, e, r])
                } else if (u.readyState === XMLHttpRequest.DONE) {
                    try {
                        let e = new Uint8Array(u.response)
                          , t = e.length * e.BYTES_PER_ELEMENT;
                        if (t > 0) {
                            let r = Module._malloc(t);
                            GROWABLE_HEAP_U8().set(e, r),
                            Module.ccall("TEJSEvent_HTTPRequest_Send_On_DONE", "number", ["number", "number", "number", "number"], [o, u.status, r, t]),
                            Module._free(r)
                        } else
                            Module.ccall("TEJSEvent_HTTPRequest_Send_On_DONE", "number", ["number", "number", "number", "number"], [o, 0, 0, 0])
                    } catch (e) {
                        Module.out("request.readyState === XMLHttpRequest.DONE Error"),
                        Module.out(e),
                        Module.ccall("TEJSEvent_HTTPRequest_Send_On_DONE", "number", ["number", "number", "number", "number"], [o, 0, 0, 0])
                    }
                    null == self.xmlHttpRequestSet && (self.xmlHttpRequestSet = {});
                    let e = u.jsRequestIndex;
                    null != self.xmlHttpRequestSet[e] && delete self.xmlHttpRequestSet[e]
                }
            }
            ,
            u.send(),
            null == self.xmlHttpRequestSet && (self.xmlHttpRequestSet = {});
            let l = 1;
            for (; ; ) {
                if (l <= 0 && (l = 1),
                null == self.xmlHttpRequestSet[l]) {
                    self.xmlHttpRequestSet[l] = u,
                    u.jsRequestIndex = l;
                    break
                }
                l++
            }
            return l
        }
        function _TEJSEvent_IDB_Del(e, t, r) {
            null == self.indexedDBSet && (self.indexedDBSet = {});
            let i = self.indexedDBSet[e]
              , n = Module.UTF8ToString(t)
              , o = null;
            try {
                o = i.transaction(["blocks"], "readwrite")
            } catch (e) {
                return Module.err(e.toString()),
                Module.ccall("TEJSEvent_IDB_Del_error", "number", ["number"], [r]),
                -1
            }
            return o.oncomplete = function(e) {
                Module.ccall("TEJSEvent_IDB_Del_complete", "number", ["number"], [r])
            }
            ,
            o.onerror = function(e) {
                Module.err(e.toString()),
                Module.ccall("TEJSEvent_IDB_Del_error", "number", ["number"], [r])
            }
            ,
            o.objectStore("blocks").delete(n),
            0
        }
        function _TEJSEvent_IDB_Get(e, t, r, i) {
            null == self.indexedDBSet && (self.indexedDBSet = {});
            let n = Module.UTF8ToString(t)
              , o = self.indexedDBSet[e]
              , a = null;
            try {
                a = o.transaction(["blocks"], "readwrite")
            } catch (e) {
                Module.err(e.toString()),
                Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i]);
                return
            }
            let s = a.objectStore("blocks")
              , u = s.get(n);
            u.onerror = function(e) {
                Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i])
            }
            ,
            u.onsuccess = function(e) {
                if (null == u.result) {
                    Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i]);
                    return
                }
                if (r) {
                    Module.ccall("TEJSEvent_IDB_Get_success", "number", ["number", "number", "number", "number", "number"], [i, 0, 0, 0, 0]);
                    return
                }
                if (null == u.result.file_content) {
                    Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i]);
                    return
                }
                let t = u.result.file_content
                  , n = u.result.filesize;
                null == n && (n = 0);
                let o = u.result.md5str;
                null == o && (o = "");
                try {
                    if (t.length > 0) {
                        let e = t.length * t.BYTES_PER_ELEMENT
                          , r = Module._malloc(e);
                        GROWABLE_HEAP_U8().set(t, r);
                        let a = Module.allocate(Module.intArrayFromString(o), Module.ALLOC_NORMAL);
                        Module.ccall("TEJSEvent_IDB_Get_success", "number", ["number", "number", "number", "number", "number"], [i, r, e, n, a]),
                        Module._free(a)
                    } else
                        Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i])
                } catch (e) {
                    Module.out("new Uint8Array(HEAPU8.buffer, dataPtr, nDataBytes); Fail"),
                    Module.err(e.toString()),
                    Module.ccall("TEJSEvent_IDB_Get_error", "number", ["number"], [i])
                }
                let a = u.result;
                a.update_time = (new Date).valueOf();
                var l = s.put(a);
                l.onerror = function(e) {}
                ,
                l.onsuccess = function(e) {}
            }
        }
        function _TEJSEvent_IDB_Open(e, t, r) {
            let i = Module.UTF8ToString(e)
              , n = self.indexedDB.open(i, t);
            return n.onerror = function(e) {
                Module.out("Open IndexedDB onerror\n"),
                Module.out(e),
                Module.ccall("TEJSEvent_IDB_Open_error", "number", ["number"], [r])
            }
            ,
            n.onsuccess = function(e) {
                let t = e.target.result;
                null == self.indexedDBSet && (self.indexedDBSet = {});
                let i = 1;
                for (; ; ) {
                    if (i <= 0 && (i = 1),
                    null == self.indexedDBSet[i]) {
                        self.indexedDBSet[i] = t;
                        break
                    }
                    i++
                }
                Module.ccall("TEJSEvent_IDB_Open_success", "number", ["number", "number"], [r, i])
            }
            ,
            n.onupgradeneeded = function(e) {
                Module.out("Open IndexedDB onupgradeneeded\n"),
                Module.ccall("TEJSEvent_IDB_Open_upgrade", "number", ["number"], [r]);
                var t = e.target.result;
                t.objectStoreNames.contains("blocks") && t.deleteObjectStore("blocks");
                var i = t.createObjectStore("blocks", {
                    keyPath: "block_key"
                });
                i.createIndex("block_key", "block_key", {
                    unique: !0
                }),
                i.transaction.oncomplete = function(e) {
                    Module.out("createObjectStore oncomplete\n"),
                    Module.ccall("TEJSEvent_IDB_Open_upgrade_complete", "number", ["number"], [r])
                }
                ,
                i.transaction.onerror = function(e) {
                    Module.out("createObjectStore onerror\n"),
                    Module.out(e),
                    Module.ccall("TEJSEvent_IDB_Open_upgrade_complete", "number", ["number"], [r])
                }
            }
            ,
            0
        }
        function _TEJSEvent_IDB_Save(e, t, r, i, n, o, a) {
            function s() {
                let t = self.indexedDBSet[e]
                  , r = null;
                try {
                    r = t.transaction(["blocks"], "readwrite")
                } catch (e) {
                    Module.err(e.toString());
                    return
                }
                let i = r.objectStore("blocks");
                i.getAll().onsuccess = function(e) {
                    let t = e.target.result;
                    if (t.length <= 1e3)
                        return;
                    let r = null;
                    for (let e = 0; e < t.length; e++) {
                        let i = t[e];
                        null == r ? r = i : r && i && r.update_time && i.update_time && r.update_time >= i.update_time && (r = i)
                    }
                    r && r.block_key && (i.delete(r.block_key).onsuccess = function(e) {
                        s()
                    }
                    )
                }
            }
            null == self.indexedDBSet && (self.indexedDBSet = {});
            let u = self.indexedDBSet[e]
              , l = null;
            try {
                l = u.transaction(["blocks"], "readwrite")
            } catch (e) {
                return Module.err(e.toString()),
                Module.ccall("TEJSEvent_IDB_Save_error", "number", ["number"], [a]),
                -1
            }
            let c = Module.UTF8ToString(t)
              , p = Module.UTF8ToString(o)
              , d = new Uint8Array(GROWABLE_HEAP_U8().subarray(r, r + i));
            l.oncomplete = function(e) {
                Module.ccall("TEJSEvent_IDB_Save_complete", "number", ["number"], [a]),
                s()
            }
            ,
            l.onerror = function(e) {
                Module.out(e),
                Module.ccall("TEJSEvent_IDB_Save_error", "number", ["number"], [a]),
                s()
            }
            ;
            let f = l.objectStore("blocks")
              , m = {
                block_key: c,
                file_content: d,
                update_time: (new Date).valueOf(),
                md5str: p,
                filesize: n
            };
            try {
                f.add(m)
            } catch (e) {
                return Module.err(e.toString()),
                Module.ccall("TEJSEvent_IDB_Save_error", "number", ["number"], [a]),
                -1
            }
            return 0
        }
        function _TEJSEvent_Image_Decode(e, t, r, i, n) {
            let o = Module.UTF8ToString(i)
              , a = null;
            try {
                a = new Uint8Array(GROWABLE_HEAP_U8().subarray(t, t + r))
            } catch (t) {
                return console.log(t),
                Module.ccall("TEJSEvent_Image_Decode_Fail", "number", ["number"], [e]),
                -1
            }
            let s = new Blob([a]);
            if (null == TEJSImageDecoder.imageBitmapCacheSet && (TEJSImageDecoder.imageBitmapCacheSet = {}),
            1 == n && "" != o) {
                let t = TEJSImageDecoder.imageBitmapCacheSet[o];
                if (null != t && void 0 != t) {
                    delete TEJSImageDecoder.imageBitmapCacheSet[o];
                    let r = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                      , i = Module.UTF8ToString(r);
                    null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {}),
                    TEJSImageDecoder.imageBitmapSet[i] = t;
                    let n = t.width;
                    t.srcWidth && (n = t.srcWidth);
                    let a = t.height;
                    return t.srcHeight && (a = t.srcHeight),
                    t.updateTime = (new Date).valueOf(),
                    Module.ccall("TEJSEvent_Image_Decode_Success_IMAGE_BITMAP", "number", ["number", "string", "number", "number", "number"], [e, i, n, a, 1]),
                    _free(r),
                    0
                }
            }
            let u = 2048;
            if (1 == n) {
                let e = GLctx.getParameter(GLctx.MAX_TEXTURE_SIZE);
                u = Math.min(u, e)
            }
            return createImageBitmap(s).then(function(t) {
                if (0 == n) {
                    let r = new OffscreenCanvas(t.width,t.height)
                      , i = r.getContext("2d");
                    i.clearRect(0, 0, r.width, r.height),
                    i.drawImage(t, 0, 0, t.width, t.height);
                    let n = new Uint8Array(i.getImageData(0, 0, t.width, t.height).data);
                    if (n.length > 0) {
                        let r = n.length * n.BYTES_PER_ELEMENT
                          , i = Module._malloc(r);
                        GROWABLE_HEAP_U8().set(n, i),
                        Module.ccall("TEJSEvent_Image_Decode_Success_PIXEL_RGBA", "number", ["number", "number", "number", "number", "number"], [e, i, r, t.width, t.height])
                    } else
                        Module.ccall("TEJSEvent_Image_Decode_Fail", "number", ["number"], [e]);
                    t.close()
                } else if (1 == n) {
                    let r = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                      , i = Module.UTF8ToString(r);
                    null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {});
                    let n = t.width
                      , a = t.height
                      , s = t;
                    if (n > u || a > u) {
                        let e = function e(e, t, r, i) {
                            let n = 0
                              , o = 0;
                            return r / i >= e / t ? r > e ? (n = e,
                            o = i * e / r) : (n = r,
                            o = i) : i > t ? (o = t,
                            n = r * t / i) : (n = r,
                            o = i),
                            {
                                w: n,
                                h: o
                            }
                        }(u, u, n, a)
                          , r = e.w
                          , i = e.h
                          , o = new OffscreenCanvas(r,i)
                          , l = o.getContext("2d");
                        l.clearRect(0, 0, r, i),
                        l.drawImage(t, 0, 0, r, i),
                        s = o.transferToImageBitmap()
                    }
                    TEJSImageDecoder.imageBitmapSet[i] = s,
                    n = s.width,
                    a = s.height,
                    s.srcWidth = n,
                    s.srcHeight = a,
                    s.cacheKey = o,
                    s.updateTime = (new Date).valueOf(),
                    Module.ccall("TEJSEvent_Image_Decode_Success_IMAGE_BITMAP", "number", ["number", "string", "number", "number", "number"], [e, i, n, a, 0]),
                    _free(r)
                }
            }).catch(function(t) {
                console.log(t),
                Module.ccall("TEJSEvent_Image_Decode_Fail", "number", ["number"], [e])
            }),
            0
        }
        function _TEJSEvent_Image_Decode_ImageBitmap_Close(e, t) {
            let r = Module.UTF8ToString(t);
            null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {});
            let i = TEJSImageDecoder.imageBitmapSet[r];
            if (!i)
                return Module.ccall("TEJSEvent_Image_Decode_ImageBitmap_Close_Fail", "number", ["number"], [e]),
                -1;
            delete TEJSImageDecoder.imageBitmapSet[r];
            let n = i.cacheKey;
            if (!n)
                return Module.ccall("TEJSEvent_Image_Decode_ImageBitmap_Close_Fail", "number", ["number"], [e]),
                -1;
            function o(e) {
                let t = 0;
                for (let r in e)
                    t++;
                return t
            }
            function a(e) {
                let t = null;
                for (let r in e)
                    null == t ? t = e[r] : t.updateTime >= e[r].updateTime && (t = e[r]);
                return null == t ? null : t.cacheKey
            }
            for (null == TEJSImageDecoder.imageBitmapCacheSet && (TEJSImageDecoder.imageBitmapCacheSet = {}),
            TEJSImageDecoder.imageBitmapCacheSet[n] = i; o(TEJSImageDecoder.imageBitmapCacheSet) > 5; ) {
                let e = a(TEJSImageDecoder.imageBitmapCacheSet);
                if (null == e)
                    break;
                let t = TEJSImageDecoder.imageBitmapCacheSet[e];
                null != t && t.close(),
                delete TEJSImageDecoder.imageBitmapCacheSet[e]
            }
            return Module.ccall("TEJSEvent_Image_Decode_ImageBitmap_Close_Success", "number", ["number"], [e]),
            0
        }
        _TEJSEvent_HEIC_Decode_Init.sig = "ippiiiiiippiip",
        _TEJSEvent_HEIC_Get_From_Cache.sig = "ipp",
        _TEJSEvent_HTTPRequest_Abort.sig = "iip",
        _TEJSEvent_HTTPRequest_Send.sig = "ippiiip",
        _TEJSEvent_IDB_Del.sig = "iipp",
        _TEJSEvent_IDB_Get.sig = "vipip",
        _TEJSEvent_IDB_Open.sig = "ipip",
        _TEJSEvent_IDB_Save.sig = "iippiipp",
        _TEJSEvent_Image_Decode.sig = "ippipi",
        _TEJSEvent_Image_Decode_ImageBitmap_Close.sig = "ipp";
        var TEJSImageMovieDecoder = {
            imageDecoderSet: [],
            imageDecoderVideoFrameSet: []
        };
        function _TEJSEvent_Image_Decoder_Is_Support() {
            return "undefined" != typeof ImageDecoder
        }
        function _TEJSEvent_Image_Gen_Fail_Image(e, t) {
            let r = new OffscreenCanvas(e,t);
            r.getContext("2d").clearRect(0, 0, e, t);
            let i = null;
            try {
                i = r.transferToImageBitmap()
            } catch (e) {
                return 0
            }
            let n = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
              , o = Module.UTF8ToString(n);
            return TEJSImageDecoder.imageBitmapSet[o] = i,
            i.srcWidth = e,
            i.srcHeight = t,
            i.cacheKey = o,
            i.updateTime = (new Date).valueOf(),
            n
        }
        function _TEJSEvent_Image_Gen_Image(e, t, r, i, n, o, a, s, u, l, c) {
            let p = Module.UTF8ToString(r);
            null == TEJSImageDecoder.imageBitmapSet && (TEJSImageDecoder.imageBitmapSet = {});
            let d = TEJSImageDecoder.imageBitmapSet[p];
            if (!d)
                return 0;
            let f = new OffscreenCanvas(e,t)
              , m = f.getContext("2d");
            m.clearRect(0, 0, e, t),
            m.drawImage(d, i, n, o, a, s, u, l, c);
            let h = null;
            try {
                h = f.transferToImageBitmap()
            } catch (e) {
                return 0
            }
            let g = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
              , _ = Module.UTF8ToString(g);
            return TEJSImageDecoder.imageBitmapSet[_] = h,
            h.srcWidth = e,
            h.srcHeight = t,
            h.cacheKey = _,
            h.updateTime = (new Date).valueOf(),
            g
        }
        function _TEJSEvent_Image_Movie_Close(e) {
            let t = Module.UTF8ToString(e)
              , r = TEJSImageMovieDecoder.imageDecoderSet[t];
            return r ? (r.close(),
            0) : -1
        }
        function _TEJSEvent_Image_Movie_Decode(e, t, r) {
            let i = Module.UTF8ToString(t)
              , n = TEJSImageMovieDecoder.imageDecoderSet[i];
            return n ? (n.decode({
                frameIndex: r
            }).then(t => {
                let r = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                  , i = Module.UTF8ToString(r);
                TEJSImageMovieDecoder.imageDecoderVideoFrameSet[i] = t.image;
                let n = allocateUTF8(t.image.timestamp.toString())
                  , o = allocateUTF8(t.image.duration.toString());
                Module.ccall("TEJSEvent_Image_Movie_Decode_Succ", "number", ["number", "string", "number", "number", "number", "number"], [e, i, t.image.displayWidth, t.image.displayHeight, n, o]),
                _free(n),
                _free(o),
                _free(r)
            }
            ).catch(t => (console.log("TEJS image movie decode err", t),
            Module.ccall("TEJSEvent_Image_Movie_Decode_Fail", "number", ["number"], [e]),
            -1)),
            0) : (Module.ccall("TEJSEvent_Image_Movie_Decode_Fail", "number", ["number"], [e]),
            -1)
        }
        function _TEJSEvent_Image_Movie_Decode_VideoFrame_Close(e) {
            let t = Module.UTF8ToString(e);
            null == TEJSImageMovieDecoder.imageDecoderVideoFrameSet && (TEJSImageMovieDecoder.imageDecoderVideoFrameSet = {});
            let r = TEJSImageMovieDecoder.imageDecoderVideoFrameSet[t];
            return r ? (r.close(),
            delete TEJSImageMovieDecoder.imageDecoderVideoFrameSet[t],
            0) : -1
        }
        function _TEJSEvent_Image_Movie_Open(e, t, r) {
            let i = null;
            try {
                i = new Uint8Array(GROWABLE_HEAP_U8().subarray(t, t + r))
            } catch (t) {
                return console.log(t),
                Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e]),
                -1
            }
            let n = new ImageDecoder({
                type: "image/gif",
                data: i
            });
            return n.completed.then( () => {
                if (n.tracks <= 0)
                    return Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e]),
                    -1;
                n.tracks.ready.then( () => {
                    let t = n.tracks.selectedTrack.frameCount;
                    if (t <= 0)
                        return Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e]),
                        -1;
                    n.decode({
                        frameIndex: 0
                    }).then(r => {
                        let i = r.image.displayWidth
                          , o = r.image.displayHeight
                          , a = Module.ccall("TEWebCodec_GenerateUUID", "number", null)
                          , s = Module.UTF8ToString(a);
                        TEJSImageMovieDecoder.imageDecoderSet[s] = n;
                        let u = allocateUTF8(r.image.duration.toString());
                        Module.ccall("TEJSEvent_Image_Movie_Open_Succ", "number", ["number", "number", "number", "number", "string", "number"], [e, i, o, t, s, u]),
                        _free(u),
                        _free(a)
                    }
                    ).catch(t => {
                        console.log("TEJS image movie decode err", t),
                        Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e])
                    }
                    )
                }
                ).catch(t => {
                    console.log("TEJS image movie decode err", t),
                    Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e])
                }
                )
            }
            ).catch(t => {
                console.log("TEJS image movie decode err", t),
                Module.ccall("TEJSEvent_Image_Movie_Open_Fail", "number", ["number"], [e])
            }
            ),
            0
        }
        function _TEJSEvent_Image_Query_GL_Max_Tex_Size() {
            let e = -1;
            return GLctx && (e = GLctx.getParameter(GLctx.MAX_TEXTURE_SIZE)),
            e
        }
        function _TEJSEvent_StreamFetch(e, t, r, i, n, o, a, s) {
            null == self.fetchControllerSet && (self.fetchControllerSet = {});
            let u = Module.UTF8ToString(e)
              , l = Module.UTF8ToString(t)
              , c = Module.UTF8ToString(i)
              , p = new Headers;
            try {
                let e = JSON.parse(l);
                if (null != e)
                    for (let t in e)
                        p.append(t, e[t])
            } catch (e) {
                Module.out("Error parsing headers:", e)
            }
            n >= 0 && o >= n && p.append("Range", "bytes=" + n + "-" + o);
            let d = new AbortController
              , f = d.signal;
            self.fetchControllerSet[a] = d;
            let m = {
                method: "GET",
                headers: p,
                credentials: 0 === r ? "omit" : "include",
                signal: f
            };
            if (null != c && void 0 != c && "" != c)
                try {
                    let e = JSON.parse(c);
                    for (let t in !e.headers && (e.headers = {}),
                    p)
                        e.headers.append(t, p[t]);
                    m = e
                } catch (e) {
                    Module.out("Error parsing fetchOption:", e)
                }
            return fetch(u, m).then(e => {
                function t(e) {
                    let[t,r] = e.split(" ")[1].split("/")
                      , [i,n] = t.split("-").map(Number)
                      , o = n - i + 1;
                    return {
                        rangeStart: i,
                        rangeEnd: n,
                        contentLength: o,
                        totalSize: Number(r)
                    }
                }
                (e.status < 200 || e.status >= 300) && Module.err("fetch error, status " + e.status + " statusText " + e.statusText);
                let r = -1
                  , i = e.headers.get("content-length");
                null != i && (r = parseInt(i));
                let s = -1
                  , u = e.headers.get("content-range");
                if (null != u) {
                    let e = t(u);
                    e.totalSize > 0 ? s = e.totalSize : Module.err("parse content range to get total size error, range " + u),
                    r <= 0 && (r = e.contentLength) <= 0 && (Module.err("parse content length from range still error, range " + u),
                    r = o - n)
                }
                Module.ccall("TEJSEvent_StreamFetch_OnHeaderReceived", "number", ["number", "number", "number", "number"], [a, e.status, s, r]);
                let l = e.body.getReader()
                  , c = 0;
                function p({done: e, value: t}) {
                    if (e) {
                        if (c < r) {
                            Module.out("fetch error: received " + c + ", acquiring " + r + " user data: " + a),
                            Module.ccall("TEJSEvent_StreamFetch_OnFail", "number", ["number"], [a]);
                            return
                        }
                        Module.ccall("TEJSEvent_StreamFetch_OnFetchDone", "number", ["number", "number"], [a, 200]),
                        Module.out("fetch done " + a);
                        return
                    }
                    c += t.length;
                    let i = Module._malloc(t.length);
                    GROWABLE_HEAP_U8().set(t, i);
                    let s = Module.ccall("TEJSEvent_StreamFetch_OnFetchProgress", "number", ["number", "number", "number", "number"], [a, i, t.length, c - t.length]);
                    if (Module._free(i),
                    s && c < o - n) {
                        Module.out("fetch: aborting, now receive " + c + ", acquiring " + (o - n)),
                        d.abort();
                        return
                    }
                    return l.read().then(p)
                }
                return r <= 0 && (r = o - n + 1),
                l.read().then(p)
            }
            ).catch(e => {
                Module.out("fetch error:", e),
                Module.ccall("TEJSEvent_StreamFetch_OnFail", "number", ["number"], [a])
            }
            ),
            0
        }
        function _TEJSEvent_WebCodec_Close(e) {
            let t = Module.UTF8ToString(e)
              , r = WebCodecs.decoderSet[t]
              , i = r.decoder;
            if (!i)
                return console.warn("Decoder not found!"),
                0;
            try {
                i.close()
            } catch (e) {
                console.error(e)
            }
            return delete WebCodecs.decoderSet[t],
            r.handle = 0,
            console.log("Decoder closed ", t),
            0
        }
        function _TEJSEvent_WebCodec_Close_Frame(e) {
            let t = Module.UTF8ToString(e);
            null == WebCodecs.frameSet && (WebCodecs.frameSet = {});
            let r = WebCodecs.frameSet[t];
            return null != r && WebCodecs.closeFrame(r),
            0
        }
        function _TEJSEvent_WebCodec_ConfigVerify(e, t, r, i, n, o) {
            let a = Module.UTF8ToString(t)
              , s = {
                codec: a
            };
            o > 0 && (s.codedWidth = r,
            s.codedHeight = i),
            VideoDecoder.isConfigSupported(s).then(t => {
                !t.supported && console.log("The codec id is not supported", a),
                Module.ccall("TEJSEvent_WebCodec_ConfigResult", null, ["number", "number"], [e, t.supported])
            }
            ).catch(t => {
                out("The codec can not supported, id:" + a),
                Module.ccall("TEJSEvent_WebCodec_ConfigResult", null, ["number", "number"], [e, 0])
            }
            )
        }
        function _TEJSEvent_WebCodec_Flush(e, t, r) {
            let i = Module.UTF8ToString(e)
              , n = Module.UTF8ToString(r)
              , o = WebCodecs.decoderSet[i]
              , a = o.decoder
              , s = performance.now()
              , u = o.handle;
            if (t && (o.flushingAndDrop = !0,
            WebCodecs.clearFrames(o),
            o.dropFramePtsSet = {},
            o.frameCount > 0 || 0 == o.sendPacketCount))
                try {
                    if (o.flushingAndDrop = !1,
                    o.currentFlushingPromise = null,
                    o.frameCount = 0,
                    o.sendPacketCount = 0,
                    o.frameCount > 0)
                        a.reset(),
                        a.configure(o.config);
                    else {
                        a.close();
                        let e = function(e) {
                            if (e && e.target) {
                                let t = e.target.decodeQueueSize;
                                Module.ccall("TEJSEvent_WebCodec_On_UpdateQueueSize", null, ["number", "number"], [u, t])
                            }
                        }
                          , t = createWebcodecInit(i, u, o.config, e);
                        (a = new VideoDecoder(t)).configure(o.config),
                        o.decoder = a
                    }
                    return o.lastConfiguredAt = performance.now(),
                    Module.ccall("TEJSEvent_WebCodec_On_Flush_Done", "number", ["number", "number"], [o.handle, t]),
                    console.log("Flush done with reset", i, "Cost ", performance.now() - s, n),
                    0
                } catch (e) {
                    return Module.ccall("TEJSEvent_WebCodec_On_Flush_Done", "number", ["number", "number"], [o.handle, t]),
                    console.error("Flush and drop failed!", e, n),
                    0
                }
            function l() {
                Module.ccall("TEJSEvent_WebCodec_On_Flush_Done", "number", ["number", "number"], [o.handle, t]),
                o.currentFlushingPromise = null,
                o.flushingAndDrop = !1,
                t && (o.frameCount = 0,
                o.sendPacketCount = 0)
            }
            let c = !1
              , p = new Promise( (e, t) => {
                setTimeout( () => {
                    !c && (c = !0,
                    console.log("Flush done timeout", i, "Cost ", performance.now() - s, n),
                    l(),
                    e())
                }
                , 1e4)
            }
            );
            WebCodecs.renderToTexture(i);
            let d = a.flush().then( () => {
                !c && (c = !0,
                console.log("FPS:", 1e3 * WebCodecs.frameCnt / (performance.now() - WebCodecs.lastFrameReport)),
                WebCodecs.frameCnt = 0,
                WebCodecs.lastFrameReport = performance.now(),
                console.log("Flush done", i, "Cost ", performance.now() - s, n),
                l())
            }
            ).catch(e => {
                !c && (c = !0,
                console.log("Flush done with error", i, "Cost ", performance.now() - s, e, n),
                l())
            }
            );
            return o.currentFlushingPromise = Promise.race([p, d]),
            console.log("Flushed ", i, t, n),
            0
        }
        function _TEJSEvent_WebCodec_Get_GLTexture(e) {
            let t = Module.UTF8ToString(e)
              , r = WebCodecs.frameSet[t];
            if (!r)
                return console.log("Frame not found", t),
                -1;
            if (!GL.currentContext)
                return console.log("Gl context is error"),
                -1;
            if (r.frameClosed)
                return console.log("Frame already closed"),
                -1;
            if (r.frame) {
                let e = allocateUTF8(r.canvasId)
                  , t = Module.ccall("TEJSEvent_WebCodec_Gen_GLTexture", "number", ["number"], [e]);
                _free(e);
                let i = GL.currentContext.GLctx;
                i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, r.frame),
                r.glTexture = t,
                r.frame.close(),
                r.frame = null
            }
            return r.glTexture
        }
        function _TEJSEvent_WebCodec_Init(e, t, r, i, n, o, a, s) {
            let u;
            !Module.WebCodecs && (Module.WebCodecs = WebCodecs);
            let l = Module.UTF8ToString(t)
              , c = Module.UTF8ToString(r)
              , p = Module.UTF8ToString(s)
              , d = {
                codec: c
            };
            a > 0 && (d.codedWidth = i,
            d.codedHeight = n);
            let f = function(e) {
                if (e && e.target) {
                    let t = e.target.decodeQueueSize
                      , r = WebCodecs.decoderSet[l];
                    r && r.handle && Module.ccall("TEJSEvent_WebCodec_On_UpdateQueueSize", null, ["number", "number"], [r.handle, t])
                }
            }
              , m = createWebcodecInit(l, e, d, f);
            return ((u = new VideoDecoder(m)).configure(d),
            void 0 !== u.ondequeue && (u.ondequeue = f),
            console.log("Configured with ", d),
            null == WebCodecs.decoderSet && (WebCodecs.decoderSet = {}),
            WebCodecs.decoderSet[l]) ? (console.error("Decoder index already exists"),
            u.close(),
            -1) : (WebCodecs.decoderSet[l] = {
                frameCount: 0,
                sendPacketCount: 0,
                decoder: u,
                decoderIndex: l,
                config: d,
                handle: e,
                canvasId: p,
                gops: [],
                __reclaim: function() {
                    u.close(),
                    m.error({
                        name: "QuotaExceededError"
                    })
                }
            },
            Module.ccall("TEJSEvent_WebCodec_OnFramesInJSUpdated", null, ["number", "number"], [e, u.frameCount]),
            0)
        }
        function _TEJSEvent_WebCodec_IsFlushing(e) {
            let t = Module.UTF8ToString(e);
            return null != WebCodecs.decoderSet[t].currentFlushingPromise
        }
        function _TEJSEvent_WebCodec_Is_Support() {
            return "undefined" != typeof VideoDecoder
        }
        function _TEJSEvent_WebCodec_RenderTexutre(e) {
            let t = Module.UTF8ToString(e);
            console.log("Render to texture for ", t),
            WebCodecs.renderToTexture(t)
        }
        function _TEJSEvent_WebCodec_SendPacket(e, t, r, i, n, o) {
            let a = Module.UTF8ToString(e)
              , s = parseInt(UTF8ToString(n))
              , u = {
                timestamp: s,
                type: t ? "key" : "delta",
                data: new Uint8Array(GROWABLE_HEAP_U8().subarray(r, r + i))
            }
              , l = WebCodecs.decoderSet[a]
              , c = l.decoder;
            if ("closed" == c.state)
                return console.log("Decoder is closed"),
                l.error = 2,
                -2;
            try {
                let e = new EncodedVideoChunk(u);
                1 === t && (l.chunks = [],
                l.gops.push(l.chunks)),
                l.chunks.push(e),
                c.decode(e),
                l.sendPacketCount++,
                0 != o && 1 !== t && (!l.dropFramePtsSet && (l.dropFramePtsSet = {}),
                l.dropFramePtsSet[s] = s)
            } catch (e) {
                return Module.ccall("TEJSEvent_WebCodec_On_Error", null, ["number", "number"], [l.handle, 3]),
                console.error(e),
                -1
            }
            return 0
        }
        function _TEJSEvent_WebCodec_SupportDequeueEvent() {
            return WebCodecs.isOndequeueSupported()
        }
        function _TEJSEvent_WebCodec_UpdateAllQueueSize() {
            if (!WebCodecs.isOndequeueSupported())
                for (let e in WebCodecs.decoderSet) {
                    let t = WebCodecs.decoderSet[e]
                      , r = t.decoder.decodeQueueSize;
                    Module.ccall("TEJSEvent_WebCodec_On_UpdateQueueSize", null, ["number", "number"], [t.handle, r])
                }
        }
        function _VideoFrameBindToTexture(e) {
            let t = Module.UTF8ToString(e);
            null == TEJSImageMovieDecoder.imageDecoderVideoFrameSet && (TEJSImageMovieDecoder.imageDecoderVideoFrameSet = {});
            let r = TEJSImageMovieDecoder.imageDecoderVideoFrameSet[t];
            return r ? (GLctx.pixelStorei(GLctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0),
            GLctx.texImage2D(GLctx.TEXTURE_2D, 0, GLctx.RGBA, GLctx.RGBA, GLctx.UNSIGNED_BYTE, r),
            GLctx.pixelStorei(GLctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            0) : -1
        }
        function bytenn_wrapper() {
            var e = function() {
                this.engine = [],
                this.device = []
            };
            e.prototype.initWithContextWebGL = function(e, t, r, i) {
                let n = library_bytenn
                  , o = n.WebGLDevice.createDeviceWithGLContext({}, GLctx);
                this.device.push(o);
                let a = new n.Engine;
                this.engine.push(a);
                let s = GROWABLE_HEAP_U8().buffer.slice(e, e + t)
                  , u = UTF8ToString(r).split(",")
                  , l = UTF8ToString(i).split(",");
                u.pop(),
                l.pop();
                let c = {
                    model: s,
                    parser: new n.ByteNNUnifyParser,
                    inputNames: u,
                    outputNames: l,
                    devices: [o]
                };
                return a.init(c),
                this.engine.length - 1
            }
            ,
            e.prototype.initWithCanvasIdWebGL = function(e, t, r, i, n) {
                let o = library_bytenn
                  , a = document.getElementById(e)
                  , s = o.WebGLDevice.create({}, a);
                this.device.push(s);
                let u = new o.Engine;
                this.engine.push(u);
                let l = GROWABLE_HEAP_U8().buffer.slice(t, t + r)
                  , c = UTF8ToString(i).split(",")
                  , p = UTF8ToString(n).split(",");
                c.pop(),
                p.pop();
                let d = {
                    model: l,
                    parser: new o.ByteNNUnifyParser,
                    inputNames: c,
                    outputNames: p,
                    devices: [s]
                };
                return u.init(d),
                this.engine.length - 1
            }
            ,
            e.prototype.initWebGL = function(e, t, r, i) {
                let n;
                let o = library_bytenn;
                n = GLctx ? o.WebGLDevice.createDeviceWithGLContext({}, GLctx) : o.WebGLDevice.create({}),
                this.device.push(n);
                let a = new o.Engine;
                this.engine.push(a);
                let s = GROWABLE_HEAP_U8().buffer.slice(e, e + t)
                  , u = UTF8ToString(r).split(",")
                  , l = UTF8ToString(i).split(",");
                u.pop(),
                l.pop();
                let c = {
                    model: s,
                    parser: new o.ByteNNUnifyParser,
                    inputNames: u,
                    outputNames: l,
                    devices: [n]
                };
                return a.init(c),
                this.engine.length - 1
            }
            ,
            e.prototype.initWebGPU = function(e, t, r, i) {
                let n, o, a, s;
                let u = library_bytenn;
                if ("function" == typeof getGlobalGPUDevice)
                    o = getGlobalGPUDevice();
                else
                    throw Error("No available gpu device found");
                "function" == typeof getGlobalGLCanvas ? a = getGlobalGLCanvas() : void 0 !== GLctx && void 0 !== GL && (GLctx.canvas && (a = GLctx.canvas),
                GL.offscreenCanvases && Object.keys(GL.offscreenCanvases).length && (a = GL.offscreenCanvases(Object.keys(GL.offscreenCanvases)[0]))),
                "function" == typeof getGlobalGPUCanvas && (s = getGlobalGPUCanvas()),
                n = u.WebGPUDevice.createDeviceWithContext(o, a, s),
                this.device.push(n);
                let l = new u.Engine;
                this.engine.push(l);
                let c = GROWABLE_HEAP_U8().buffer.slice(e, e + t)
                  , p = UTF8ToString(r).split(",")
                  , d = UTF8ToString(i).split(",");
                p.pop(),
                d.pop();
                let f = {
                    model: c,
                    parser: new u.ByteNNUnifyParser,
                    inputNames: p,
                    outputNames: d,
                    devices: [n]
                };
                return l.init(f),
                this.engine.length - 1
            }
            ,
            e.prototype.getInputShape = function(e, t, r) {
                let i = UTF8ToString(t)
                  , n = this.engine[e].getInputs()[i]
                  , o = 4;
                for (let e = 0; e < o; e++)
                    GROWABLE_HEAP_I32()[r / 4 + e] = n.shape.dims[e]
            }
            ,
            e.prototype.getOutputShape = function(e, t, r) {
                let i = UTF8ToString(t)
                  , n = this.engine[e].getOutputs()[i]
                  , o = 4;
                for (let e = 0; e < o; e++)
                    GROWABLE_HEAP_I32()[r / 4 + e] = n.shape.dims[e]
            }
            ,
            e.prototype.setInput = function(e, t, r) {
                let i = UTF8ToString(t)
                  , [n,o,a,s] = this.engine[e].getInputs()[i].shape.dims
                  , u = n * o * a * s
                  , l = this.device[e].tensorFromData([n, o, a, s], GROWABLE_HEAP_F32().subarray(r / 4, r / 4 + u))
                  , c = [];
                c[i] = l,
                this.engine[e].setInputs(c)
            }
            ,
            e.prototype.setInputTexture = function(e, t, r) {
                let i = UTF8ToString(t)
                  , [n,o,a,s] = this.engine[e].getInputs()[i].shape.dims
                  , u = this.device[e].tensorFromTexture([n, o, a, s], 4, GL.textures[r])
                  , l = [];
                l[i] = u,
                this.engine[e].setInputs(l)
            }
            ,
            e.prototype.setOutputTexture = function(e, t, r, i, n, o, a) {
                let s = UTF8ToString(t)
                  , u = this.device[e].tensorFromTexture([i, n, o, a], 4, GL.textures[r])
                  , l = [];
                l[s] = u,
                this.engine[e].setOutputs(l)
            }
            ,
            e.prototype.webGPUSetInputGLTexture = function(e, t, r, i, n) {
                let o = UTF8ToString(t)
                  , [a,s,u,l] = this.engine[e].getInputs()[o].shape.dims
                  , c = this.device[e].tensorFromWebGLTexture([a, s, u, l], 4, GL.textures[r], u, s, i, n)
                  , p = [];
                p[o] = c,
                this.engine[e].setInputs(p),
                this.engine[e].setSourceInputs({
                    [o]: {
                        source: GL.textures[r],
                        zero: i,
                        scale: n
                    }
                })
            }
            ,
            e.prototype.webGPUSetOutputGLTexture = function(e, t, r, i, n, o, a, s, u) {
                let l = UTF8ToString(t)
                  , c = this.device[e].tensorFromWebGLTexture([i, n, o, a], 4, GL.textures[r], o, n, s, u)
                  , p = [];
                p[l] = c,
                this.engine[e].setOutputs(p),
                this.engine[e].setSourceOutputs({
                    [l]: {
                        source: GL.textures[r],
                        zero: s,
                        scale: u
                    }
                })
            }
            ,
            e.prototype.getOutput = function(e, t, r) {
                let i = UTF8ToString(t)
                  , n = this.engine[e].getOutputs()[i].data;
                GROWABLE_HEAP_F32().set(n, r / 4)
            }
            ,
            e.prototype.inference = function(e) {
                this.engine[e].inference()
            }
            ,
            e.prototype.webGPUInference = function(e) {
                let t = this.engine[e].getInputs()
                  , r = this.engine[e].getSourceInputs();
                for (let i in r) {
                    let {source: n, zero: o, scale: a} = r[i]
                      , s = t[i]
                      , [u,l,c,p] = s.shape.dims;
                    this.device[e].tensorFromWebGLTexture(s.shape, s.type, n, c, l, o, a, s)
                }
                this.engine[e].inference();
                let i = this.engine[e].getOutputs()
                  , n = this.engine[e].getSourceOutputs();
                for (let t in n) {
                    let {source: r, zero: o, scale: a} = n[t]
                      , s = i[t]
                      , [u,l,c,p] = s.shape.dims;
                    this.device[e].tensorToWebGLTexture(s, r, c, l, o, a)
                }
            }
            ,
            e.prototype.release = function(e) {
                this.engine[e].dispose(),
                this.engine[e] = void 0
            }
            ,
            e.prototype.reInferShape = function(e, t, r) {
                this.engine[e].reInferShape(t, r)
            }
            ;
            var t = new e;
            _WebGLInit = t.initWebGL.bind(t),
            _WebGLSetInput = t.setInput.bind(t),
            _WebGLInference = t.inference.bind(t),
            _WebGLGetOutput = t.getOutput.bind(t),
            _WebGLGetOutputShape = t.getOutputShape.bind(t),
            _WebGLRelease = t.release.bind(t),
            _WebGLSetInputTexture = t.setInputTexture.bind(t),
            _WebGLSetOutputTexture = t.setOutputTexture.bind(t),
            _WebGLGetInputShape = t.getInputShape.bind(t),
            _WebGLReInferShape = t.reInferShape.bind(t),
            _WebGPUInit = t.initWebGPU.bind(t),
            _WebGPUSetInput = t.setInput.bind(t),
            _WebGPUInference = t.webGPUInference.bind(t),
            _WebGPUGetOutput = t.getOutput.bind(t),
            _WebGPUGetOutputShape = t.getOutputShape.bind(t),
            _WebGPURelease = t.release.bind(t),
            _WebGPUSetInputGLTexture = t.webGPUSetInputGLTexture.bind(t),
            _WebGPUSetOutputGLTexture = t.webGPUSetOutputGLTexture.bind(t),
            _WebGPUGetInputShape = t.getInputShape.bind(t),
            _WebGPUReInferShape = t.reInferShape.bind(t)
        }
        function _WebGLGetInputShape(e, t) {}
        function _WebGLGetOutput(e, t) {}
        function _WebGLGetOutputShape(e, t) {}
        function _WebGLInference() {}
        function _WebGLInit(e, t, r, i) {}
        function _WebGLReInferShape() {}
        function _WebGLRelease(e) {}
        function _WebGLSetInput(e, t) {}
        function _WebGLSetInputTexture(e, t) {}
        function _WebGLSetOutputTexture(e, t, r, i, n, o) {}
        function _WebGPUGetInputShape(e, t) {}
        function _WebGPUGetOutput(e, t) {}
        function _WebGPUGetOutputShape(e, t) {}
        function _WebGPUInference() {}
        function _WebGPUInit(e, t, r, i) {}
        function _WebGPUReInferShape() {}
        function _WebGPURelease(e) {}
        function _WebGPUSetInput(e, t) {}
        function _WebGPUSetInputGLTexture(e, t) {}
        function _WebGPUSetOutputGLTexture(e, t, r, i, n, o) {}
        _TEJSEvent_Image_Decoder_Is_Support.sig = "i",
        _TEJSEvent_Image_Gen_Fail_Image.sig = "pii",
        _TEJSEvent_Image_Gen_Image.sig = "piipiiiiiiii",
        _TEJSEvent_Image_Movie_Close.sig = "ip",
        _TEJSEvent_Image_Movie_Decode.sig = "ippi",
        _TEJSEvent_Image_Movie_Decode_VideoFrame_Close.sig = "ip",
        _TEJSEvent_Image_Movie_Open.sig = "ippi",
        _TEJSEvent_Image_Query_GL_Max_Tex_Size.sig = "i",
        _TEJSEvent_StreamFetch.sig = "ippipiipp",
        _TEJSEvent_WebCodec_Close.sig = "ip",
        _TEJSEvent_WebCodec_Close_Frame.sig = "ip",
        _TEJSEvent_WebCodec_ConfigVerify.sig = "vppiipi",
        _TEJSEvent_WebCodec_Flush.sig = "ipip",
        _TEJSEvent_WebCodec_Get_GLTexture.sig = "ip",
        _TEJSEvent_WebCodec_Init.sig = "ipppiipip",
        _TEJSEvent_WebCodec_IsFlushing.sig = "ip",
        _TEJSEvent_WebCodec_Is_Support.sig = "i",
        _TEJSEvent_WebCodec_RenderTexutre.sig = "vp",
        _TEJSEvent_WebCodec_SendPacket.sig = "ipipipi",
        _TEJSEvent_WebCodec_SupportDequeueEvent.sig = "i",
        _TEJSEvent_WebCodec_UpdateAllQueueSize.sig = "v",
        _VideoFrameBindToTexture.sig = "ip";
        var ___assert_fail = (e, t, r, i) => {
            abort(`Assertion failed: ${UTF8ToString(e)}, at: ` + [t ? UTF8ToString(t) : "unknown filename", r, i ? UTF8ToString(i) : "unknown function"])
        }
        ;
        ___assert_fail.sig = "vppip";
        var ___c_longjmp = new WebAssembly.Tag({
            parameters: ["i32"]
        })
          , ___cpp_exception = new WebAssembly.Tag({
            parameters: ["i32"]
        })
          , ___emscripten_init_main_thread_js = e => {
            __emscripten_thread_init(e, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB, 1048576, !1),
            PThread.threadInitTLS()
        }
        ;
        ___emscripten_init_main_thread_js.sig = "vp";
        var ___emscripten_thread_cleanup = e => {
            ENVIRONMENT_IS_PTHREAD ? postMessage({
                cmd: "cleanupThread",
                thread: e
            }) : cleanupThread(e)
        }
        ;
        ___emscripten_thread_cleanup.sig = "vp";
        var ___memory_base = new WebAssembly.Global({
            value: "i32",
            mutable: !1
        },1024);
        function pthreadCreateProxied(e, t, r, i) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(2, 0, 1, e, t, r, i) : ___pthread_create_js(e, t, r, i)
        }
        var ___pthread_create_js = (e, t, r, i) => {
            let n;
            if ("undefined" == typeof SharedArrayBuffer)
                return err("Current environment does not support SharedArrayBuffer, pthreads are not available!"),
                6;
            var o = []
              , a = 0
              , s = t ? GROWABLE_HEAP_U32()[t + 40 >> 2] : 0;
            0xffffffff == s ? s = "#canvas" : s &&= UTF8ToString(s).trim(),
            s &&= s.split(",");
            var u = {}
              , l = Module.canvas ? Module.canvas.id : "";
            for (var c in s) {
                var p, d = s[c].trim();
                try {
                    if ("#canvas" == d) {
                        if (!Module.canvas) {
                            err(`pthread_create: could not find canvas with ID "${d}" to transfer to thread!`),
                            a = 28;
                            break
                        }
                        d = Module.canvas.id
                    }
                    if (GL.offscreenCanvases[d])
                        p = GL.offscreenCanvases[d],
                        GL.offscreenCanvases[d] = null,
                        Module.canvas instanceof OffscreenCanvas && d === Module.canvas.id && (Module.canvas = null);
                    else if (!ENVIRONMENT_IS_PTHREAD) {
                        var f = Module.canvas && Module.canvas.id === d ? Module.canvas : document.querySelector(d);
                        if (!f) {
                            err(`pthread_create: could not find canvas with ID "${d}" to transfer to thread!`),
                            a = 28;
                            break
                        }
                        if (f.controlTransferredOffscreen) {
                            err(`pthread_create: cannot transfer canvas with ID "${d}" to thread, since the current thread does not have control over it!`),
                            a = 63;
                            break
                        }
                        if (!f.transferControlToOffscreen)
                            return err(`pthread_create: cannot transfer control of canvas "${d}" to pthread, because current browser does not support OffscreenCanvas!`),
                            err("pthread_create: Build with -sOFFSCREEN_FRAMEBUFFER to enable fallback proxying of GL commands from pthread to main thread."),
                            52;
                        !f.canvasSharedPtr && (f.canvasSharedPtr = _malloc(12),
                        GROWABLE_HEAP_I32()[f.canvasSharedPtr >> 2] = f.width,
                        GROWABLE_HEAP_I32()[f.canvasSharedPtr + 4 >> 2] = f.height,
                        GROWABLE_HEAP_U32()[f.canvasSharedPtr + 8 >> 2] = 0),
                        p = {
                            offscreenCanvas: f.transferControlToOffscreen(),
                            canvasSharedPtr: f.canvasSharedPtr,
                            id: f.id
                        },
                        f.controlTransferredOffscreen = !0
                    }
                    p && (o.push(p.offscreenCanvas),
                    u[p.id] = p)
                } catch (e) {
                    return err(`pthread_create: failed to transfer control of canvas "${d}" to OffscreenCanvas! Error: ${e}`),
                    28
                }
            }
            "number" == typeof Error.stackTraceLimit && (n = Error.stackTraceLimit,
            Error.stackTraceLimit = 20);
            let m = Error().stack;
            if ("number" == typeof Error.stackTraceLimit && (Error.stackTraceLimit = n),
            ENVIRONMENT_IS_PTHREAD && (0 === o.length || a)) {
                let n = Module.allocate(Module.intArrayFromString(m), Module.ALLOC_NORMAL);
                return _vesdk_log_custom_pthread_create(e, t, r, i, n)
            }
            if (void 0 !== Module.pthread_vesdk_log_create_stack_str) {
                let e = Module.pthread_vesdk_log_create_stack_str;
                m = UTF8ToString(e),
                Module._free(e),
                delete Module.pthread_vesdk_log_create_stack_str
            }
            if (a)
                return a;
            for (var f of Object.values(u))
                GROWABLE_HEAP_U32()[f.canvasSharedPtr + 8 >> 2] = e;
            var h = {
                startRoutine: r,
                pthread_ptr: e,
                arg: i,
                moduleCanvasId: l,
                offscreenCanvases: u,
                transferList: o,
                createStack: m
            };
            return ENVIRONMENT_IS_PTHREAD ? (h.cmd = "spawnThread",
            postMessage(h, o),
            0) : spawnThread(h)
        }
        ;
        ___pthread_create_js.sig = "ipppp";
        var ___stack_high = 0x1644330
          , ___stack_low = 0x1544330
          , ___stack_pointer = new WebAssembly.Global({
            value: "i32",
            mutable: !0
        },0x1644330)
          , ___table_base = new WebAssembly.Global({
            value: "i32",
            mutable: !1
        },1)
          , ___throw_exception_with_stack_trace = e => {
            var t = new WebAssembly.Exception(getCppExceptionTag(),[e],{
                traceStack: !0
            });
            if (t.message = getExceptionMessage(t),
            t.message && t.stack) {
                var r = t.stack.split("\n")
                  , i = r[0]
                  , n = t.stack
                  , o = /libffmpeg(?:_simd)?\.wasm\.(\w+)\s*\(/
                  , a = /\n.*?(?:(\d*?:\d*?)\)|wasm-function\[(\d*)\]:0x[0-9a-z]+\)?)/gim;
                /wasm-function\[\d*\]/gim.test(n) && (i = n.replace(a, function(e, t, r) {
                    var i = e.match(o);
                    return i ? "," + i[1] : "," + (t || r)
                })),
                withStackSave( () => {
                    var e = allocateUTF8OnStack(i);
                    ___logExceptionStackInVELOG(0, e)
                }
                ),
                r.splice(1, 1);
                try {
                    t.stack = r.join("\n")
                } catch (e) {}
            }
            throw t
        }
          , ENV = {}
          , lengthBytesUTF8 = e => {
            for (var t = 0, r = 0; r < e.length; ++r) {
                var i = e.charCodeAt(r);
                i <= 127 ? t++ : i <= 2047 ? t += 2 : i >= 55296 && i <= 57343 ? (t += 4,
                ++r) : t += 3
            }
            return t
        }
          , stringToUTF8Array = (e, t, r, i) => {
            if (!(i > 0))
                return 0;
            for (var n = r, o = r + i - 1, a = 0; a < e.length; ++a) {
                var s = e.charCodeAt(a);
                if (s >= 55296 && s <= 57343 && (s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++a)),
                s <= 127) {
                    if (r >= o)
                        break;
                    t[r++] = s
                } else if (s <= 2047) {
                    if (r + 1 >= o)
                        break;
                    t[r++] = 192 | s >> 6,
                    t[r++] = 128 | 63 & s
                } else if (s <= 65535) {
                    if (r + 2 >= o)
                        break;
                    t[r++] = 224 | s >> 12,
                    t[r++] = 128 | s >> 6 & 63,
                    t[r++] = 128 | 63 & s
                } else {
                    if (r + 3 >= o)
                        break;
                    t[r++] = 240 | s >> 18,
                    t[r++] = 128 | s >> 12 & 63,
                    t[r++] = 128 | s >> 6 & 63,
                    t[r++] = 128 | 63 & s
                }
            }
            return t[r] = 0,
            r - n
        }
          , stringToUTF8 = (e, t, r) => stringToUTF8Array(e, GROWABLE_HEAP_U8(), t, r)
          , stringToUTF8OnStack = e => {
            var t = lengthBytesUTF8(e) + 1
              , r = stackAlloc(t);
            return stringToUTF8(e, r, t),
            r
        }
          , dlSetError = e => {
            withStackSave( () => {
                var t = stringToUTF8OnStack(e);
                ___dl_seterr(t, 0)
            }
            )
        }
          , PATH = {
            isAbs: e => "/" === e.charAt(0),
            splitPath: e => /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1),
            normalizeArray: (e, t) => {
                for (var r = 0, i = e.length - 1; i >= 0; i--) {
                    var n = e[i];
                    "." === n ? e.splice(i, 1) : ".." === n ? (e.splice(i, 1),
                    r++) : r && (e.splice(i, 1),
                    r--)
                }
                if (t)
                    for (; r; r--)
                        e.unshift("..");
                return e
            }
            ,
            normalize: e => {
                var t = PATH.isAbs(e)
                  , r = "/" === e.substr(-1);
                return !(e = PATH.normalizeArray(e.split("/").filter(e => !!e), !t).join("/")) && !t && (e = "."),
                e && r && (e += "/"),
                (t ? "/" : "") + e
            }
            ,
            dirname: e => {
                var t = PATH.splitPath(e)
                  , r = t[0]
                  , i = t[1];
                return r || i ? (i && (i = i.substr(0, i.length - 1)),
                r + i) : "."
            }
            ,
            basename: e => {
                if ("/" === e)
                    return "/";
                var t = (e = (e = PATH.normalize(e)).replace(/\/$/, "")).lastIndexOf("/");
                return -1 === t ? e : e.substr(t + 1)
            }
            ,
            join: (...e) => PATH.normalize(e.join("/")),
            join2: (e, t) => PATH.normalize(e + "/" + t)
        }
          , dlopenInternal = (e, t) => {
            var r = UTF8ToString(e + 36)
              , i = GROWABLE_HEAP_I32()[e + 4 >> 2];
            r = PATH.normalize(r);
            var n = !!(256 & i)
              , o = n ? null : {}
              , a = {
                global: n,
                nodelete: !!(4096 & i),
                loadAsync: t.loadAsync
            };
            if (t.loadAsync)
                return loadDynamicLibrary(r, a, o, e);
            try {
                return loadDynamicLibrary(r, a, o, e)
            } catch (e) {
                return dlSetError(`Could not load dynamic lib: ${r}
${e}`),
                0
            }
        }
          , __dlopen_js = e => dlopenInternal(e, {
            loadAsync: !1
        });
        __dlopen_js.sig = "pp";
        var __dlsym_catchup_js = (e, t) => {
            var r = LDSO.loadedLibsByHandle[e].exports
              , i = Object.keys(r)[t]
              , n = r[i];
            return addFunction(n, n.sig)
        }
        ;
        __dlsym_catchup_js.sig = "ppi";
        var structRegistrations = {}
          , runDestructors = e => {
            for (; e.length; ) {
                var t = e.pop();
                e.pop()(t)
            }
        }
        ;
        function readPointer(e) {
            return this.fromWireType(GROWABLE_HEAP_U32()[e >> 2])
        }
        var awaitingDependencies = {}
          , registeredTypes = {}
          , typeDependencies = {}
          , throwInternalError = e => {
            throw new InternalError(e)
        }
          , whenDependentTypesAreResolved = (e, t, r) => {
            function i(t) {
                var i = r(t);
                i.length !== e.length && throwInternalError("Mismatched type converter count");
                for (var n = 0; n < e.length; ++n)
                    registerType(e[n], i[n])
            }
            e.forEach(function(e) {
                typeDependencies[e] = t
            });
            var n = Array(t.length)
              , o = []
              , a = 0;
            t.forEach( (e, t) => {
                registeredTypes.hasOwnProperty(e) ? n[t] = registeredTypes[e] : (o.push(e),
                !awaitingDependencies.hasOwnProperty(e) && (awaitingDependencies[e] = []),
                awaitingDependencies[e].push( () => {
                    n[t] = registeredTypes[e],
                    ++a === o.length && i(n)
                }
                ))
            }
            ),
            0 === o.length && i(n)
        }
          , __embind_finalize_value_object = e => {
            var t = structRegistrations[e];
            delete structRegistrations[e];
            var r = t.rawConstructor
              , i = t.rawDestructor
              , n = t.fields;
            whenDependentTypesAreResolved([e], n.map(e => e.getterReturnType).concat(n.map(e => e.setterArgumentType)), e => {
                var o = {};
                return n.forEach( (t, r) => {
                    var i = t.fieldName
                      , a = e[r]
                      , s = t.getter
                      , u = t.getterContext
                      , l = e[r + n.length]
                      , c = t.setter
                      , p = t.setterContext;
                    o[i] = {
                        read: e => a.fromWireType(s(u, e)),
                        write: (e, t) => {
                            var r = [];
                            c(p, e, l.toWireType(r, t)),
                            runDestructors(r)
                        }
                    }
                }
                ),
                [{
                    name: t.name,
                    fromWireType: e => {
                        var t = {};
                        for (var r in o)
                            t[r] = o[r].read(e);
                        return i(e),
                        t
                    }
                    ,
                    toWireType: (e, t) => {
                        for (var n in o)
                            if (!(n in t))
                                throw TypeError(`Missing field: "${n}"`);
                        var a = r();
                        for (n in o)
                            o[n].write(a, t[n]);
                        return null !== e && e.push(i, a),
                        a
                    }
                    ,
                    argPackAdvance: GenericWireTypeSize,
                    readValueFromPointer: readPointer,
                    destructorFunction: i
                }]
            }
            )
        }
        ;
        __embind_finalize_value_object.sig = "vp";
        var embindRepr = e => {
            if (null === e)
                return "null";
            var t = typeof e;
            return "object" === t || "array" === t || "function" === t ? e.toString() : "" + e
        }
          , embind_init_charCodes = () => {
            for (var e = Array(256), t = 0; t < 256; ++t)
                e[t] = String.fromCharCode(t);
            embind_charCodes = e
        }
          , readLatin1String = e => {
            for (var t = "", r = e; GROWABLE_HEAP_U8()[r]; )
                t += embind_charCodes[GROWABLE_HEAP_U8()[r++]];
            return t
        }
          , throwBindingError = e => {
            throw new BindingError(e)
        }
        ;
        function sharedRegisterType(e, t, r={}) {
            var i = t.name;
            if (!e && throwBindingError(`type "${i}" must have a positive integer typeid pointer`),
            registeredTypes.hasOwnProperty(e)) {
                if (r.ignoreDuplicateRegistrations)
                    return;
                throwBindingError(`Cannot register type '${i}' twice`)
            }
            if (registeredTypes[e] = t,
            delete typeDependencies[e],
            awaitingDependencies.hasOwnProperty(e)) {
                var n = awaitingDependencies[e];
                delete awaitingDependencies[e],
                n.forEach(e => e())
            }
        }
        function registerType(e, t, r={}) {
            if (!("argPackAdvance"in t))
                throw TypeError("registerType registeredInstance requires argPackAdvance");
            return sharedRegisterType(e, t, r)
        }
        var integerReadValueFromPointer = (e, t, r) => {
            switch (t) {
            case 1:
                return r ? e => GROWABLE_HEAP_I8()[e] : e => GROWABLE_HEAP_U8()[e];
            case 2:
                return r ? e => GROWABLE_HEAP_I16()[e >> 1] : e => GROWABLE_HEAP_U16()[e >> 1];
            case 4:
                return r ? e => GROWABLE_HEAP_I32()[e >> 2] : e => GROWABLE_HEAP_U32()[e >> 2];
            case 8:
                return r ? e => HEAP64[e >> 3] : e => HEAPU64[e >> 3];
            default:
                throw TypeError(`invalid integer width (${t}): ${e}`)
            }
        }
          , __embind_register_bigint = (e, t, r, i, n) => {
            var o = -1 != (t = readLatin1String(t)).indexOf("u");
            o && (n = (1n << 64n) - 1n),
            registerType(e, {
                name: t,
                fromWireType: e => e,
                toWireType: function(e, t) {
                    if ("bigint" != typeof t && "number" != typeof t)
                        throw TypeError(`Cannot convert "${embindRepr(t)}" to ${this.name}`);
                    return "number" == typeof t && (t = BigInt(t)),
                    t
                },
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: integerReadValueFromPointer(t, r, !o),
                destructorFunction: null
            })
        }
        ;
        __embind_register_bigint.sig = "vpppjj";
        var GenericWireTypeSize = 8
          , __embind_register_bool = (e, t, r, i) => {
            registerType(e, {
                name: t = readLatin1String(t),
                fromWireType: function(e) {
                    return !!e
                },
                toWireType: function(e, t) {
                    return t ? r : i
                },
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: function(e) {
                    return this.fromWireType(GROWABLE_HEAP_U8()[e])
                },
                destructorFunction: null
            })
        }
        ;
        __embind_register_bool.sig = "vppii";
        var shallowCopyInternalPointer = e => ({
            count: e.count,
            deleteScheduled: e.deleteScheduled,
            preservePointerOnDelete: e.preservePointerOnDelete,
            ptr: e.ptr,
            ptrType: e.ptrType,
            smartPtr: e.smartPtr,
            smartPtrType: e.smartPtrType
        })
          , throwInstanceAlreadyDeleted = e => {
            throwBindingError(function e(e) {
                return e.$$.ptrType.registeredClass.name
            }(e) + " instance already deleted")
        }
          , finalizationRegistry = !1
          , detachFinalizer = e => {}
          , runDestructor = e => {
            e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr)
        }
          , releaseClassHandle = e => {
            e.count.value -= 1,
            0 === e.count.value && runDestructor(e)
        }
          , downcastPointer = (e, t, r) => {
            if (t === r)
                return e;
            if (void 0 === r.baseClass)
                return null;
            var i = downcastPointer(e, t, r.baseClass);
            return null === i ? null : r.downcast(i)
        }
          , registeredPointers = {}
          , getInheritedInstanceCount = () => Object.keys(registeredInstances).length
          , getLiveInheritedInstances = () => {
            var e = [];
            for (var t in registeredInstances)
                registeredInstances.hasOwnProperty(t) && e.push(registeredInstances[t]);
            return e
        }
          , deletionQueue = []
          , flushPendingDeletes = () => {
            for (; deletionQueue.length; ) {
                var e = deletionQueue.pop();
                e.$$.deleteScheduled = !1,
                e.delete()
            }
        }
          , setDelayFunction = e => {
            delayFunction = e,
            deletionQueue.length && delayFunction && delayFunction(flushPendingDeletes)
        }
          , init_embind = () => {
            Module.getInheritedInstanceCount = getInheritedInstanceCount,
            Module.getLiveInheritedInstances = getLiveInheritedInstances,
            Module.flushPendingDeletes = flushPendingDeletes,
            Module.setDelayFunction = setDelayFunction
        }
          , registeredInstances = {}
          , getBasestPointer = (e, t) => {
            for (void 0 === t && throwBindingError("ptr should not be undefined"); e.baseClass; )
                t = e.upcast(t),
                e = e.baseClass;
            return t
        }
          , getInheritedInstance = (e, t) => registeredInstances[t = getBasestPointer(e, t)]
          , makeClassHandle = (e, t) => ((!t.ptrType || !t.ptr) && throwInternalError("makeClassHandle requires ptr and ptrType"),
        !!t.smartPtrType != !!t.smartPtr && throwInternalError("Both smartPtrType and smartPtr must be specified"),
        t.count = {
            value: 1
        },
        attachFinalizer(Object.create(e, {
            $$: {
                value: t,
                writable: !0
            }
        })));
        function RegisteredPointer_fromWireType(e) {
            var t, r = this.getPointee(e);
            if (!r)
                return this.destructor(e),
                null;
            var i = getInheritedInstance(this.registeredClass, r);
            if (void 0 !== i) {
                if (0 === i.$$.count.value)
                    return i.$$.ptr = r,
                    i.$$.smartPtr = e,
                    i.clone();
                var n = i.clone();
                return this.destructor(e),
                n
            }
            function o() {
                return this.isSmartPointer ? makeClassHandle(this.registeredClass.instancePrototype, {
                    ptrType: this.pointeeType,
                    ptr: r,
                    smartPtrType: this,
                    smartPtr: e
                }) : makeClassHandle(this.registeredClass.instancePrototype, {
                    ptrType: this,
                    ptr: e
                })
            }
            var a = registeredPointers[this.registeredClass.getActualType(r)];
            if (!a)
                return o.call(this);
            t = this.isConst ? a.constPointerType : a.pointerType;
            var s = downcastPointer(r, this.registeredClass, t.registeredClass);
            return null === s ? o.call(this) : this.isSmartPointer ? makeClassHandle(t.registeredClass.instancePrototype, {
                ptrType: t,
                ptr: s,
                smartPtrType: this,
                smartPtr: e
            }) : makeClassHandle(t.registeredClass.instancePrototype, {
                ptrType: t,
                ptr: s
            })
        }
        var attachFinalizer = e => "undefined" == typeof FinalizationRegistry ? (attachFinalizer = e => e,
        e) : (finalizationRegistry = new FinalizationRegistry(e => {
            releaseClassHandle(e.$$)
        }
        ),
        attachFinalizer = e => {
            var t = e.$$;
            if (t.smartPtr) {
                var r = {
                    $$: t
                };
                finalizationRegistry.register(e, r, e)
            }
            return e
        }
        ,
        detachFinalizer = e => finalizationRegistry.unregister(e),
        attachFinalizer(e))
          , init_ClassHandle = () => {
            Object.assign(ClassHandle.prototype, {
                isAliasOf(e) {
                    if (!(this instanceof ClassHandle) || !(e instanceof ClassHandle))
                        return !1;
                    var t = this.$$.ptrType.registeredClass
                      , r = this.$$.ptr;
                    e.$$ = e.$$;
                    for (var i = e.$$.ptrType.registeredClass, n = e.$$.ptr; t.baseClass; )
                        r = t.upcast(r),
                        t = t.baseClass;
                    for (; i.baseClass; )
                        n = i.upcast(n),
                        i = i.baseClass;
                    return t === i && r === n
                },
                clone() {
                    if (!this.$$.ptr && throwInstanceAlreadyDeleted(this),
                    this.$$.preservePointerOnDelete)
                        return this.$$.count.value += 1,
                        this;
                    var e = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                        $$: {
                            value: shallowCopyInternalPointer(this.$$)
                        }
                    }));
                    return e.$$.count.value += 1,
                    e.$$.deleteScheduled = !1,
                    e
                },
                delete() {
                    !this.$$.ptr && throwInstanceAlreadyDeleted(this),
                    this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && throwBindingError("Object already scheduled for deletion"),
                    detachFinalizer(this),
                    releaseClassHandle(this.$$),
                    !this.$$.preservePointerOnDelete && (this.$$.smartPtr = void 0,
                    this.$$.ptr = void 0)
                },
                isDeleted() {
                    return !this.$$.ptr
                },
                deleteLater() {
                    return !this.$$.ptr && throwInstanceAlreadyDeleted(this),
                    this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && throwBindingError("Object already scheduled for deletion"),
                    deletionQueue.push(this),
                    1 === deletionQueue.length && delayFunction && delayFunction(flushPendingDeletes),
                    this.$$.deleteScheduled = !0,
                    this
                }
            })
        }
        ;
        function ClassHandle() {}
        var createNamedFunction = (e, t) => Object.defineProperty(t, "name", {
            value: e
        })
          , ensureOverloadTable = (e, t, r) => {
            if (void 0 === e[t].overloadTable) {
                var i = e[t];
                e[t] = function(...i) {
                    return !e[t].overloadTable.hasOwnProperty(i.length) && throwBindingError(`Function '${r}' called with an invalid number of arguments (${i.length}) - expects one of (${e[t].overloadTable})!`),
                    e[t].overloadTable[i.length].apply(this, i)
                }
                ,
                e[t].overloadTable = [],
                e[t].overloadTable[i.argCount] = i
            }
        }
          , exposePublicSymbol = (e, t, r) => {
            Module.hasOwnProperty(e) ? ((void 0 === r || void 0 !== Module[e].overloadTable && void 0 !== Module[e].overloadTable[r]) && throwBindingError(`Cannot register public name '${e}' twice`),
            ensureOverloadTable(Module, e, e),
            Module.hasOwnProperty(r) && throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`),
            Module[e].overloadTable[r] = t) : (Module[e] = t,
            void 0 !== r && (Module[e].numArguments = r))
        }
          , char_0 = 48
          , char_9 = 57
          , makeLegalFunctionName = e => {
            if (void 0 === e)
                return "_unknown";
            var t = (e = e.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
            return t >= char_0 && t <= char_9 ? `_${e}` : e
        }
        ;
        function RegisteredClass(e, t, r, i, n, o, a, s) {
            this.name = e,
            this.constructor = t,
            this.instancePrototype = r,
            this.rawDestructor = i,
            this.baseClass = n,
            this.getActualType = o,
            this.upcast = a,
            this.downcast = s,
            this.pureVirtualFunctions = []
        }
        var upcastPointer = (e, t, r) => {
            for (; t !== r; )
                !t.upcast && throwBindingError(`Expected null or instance of ${r.name}, got an instance of ${t.name}`),
                e = t.upcast(e),
                t = t.baseClass;
            return e
        }
        ;
        function constNoSmartPtrRawPointerToWireType(e, t) {
            if (null === t)
                return this.isReference && throwBindingError(`null is not a valid ${this.name}`),
                0;
            !t.$$ && throwBindingError(`Cannot pass "${embindRepr(t)}" as a ${this.name}`),
            !t.$$.ptr && throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
            var r = t.$$.ptrType.registeredClass;
            return upcastPointer(t.$$.ptr, r, this.registeredClass)
        }
        function genericPointerToWireType(e, t) {
            if (null === t)
                return (this.isReference && throwBindingError(`null is not a valid ${this.name}`),
                this.isSmartPointer) ? (r = this.rawConstructor(),
                null !== e && e.push(this.rawDestructor, r),
                r) : 0;
            (!t || !t.$$) && throwBindingError(`Cannot pass "${embindRepr(t)}" as a ${this.name}`),
            !t.$$.ptr && throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`),
            !this.isConst && t.$$.ptrType.isConst && throwBindingError(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            var r, i = t.$$.ptrType.registeredClass;
            if (r = upcastPointer(t.$$.ptr, i, this.registeredClass),
            this.isSmartPointer)
                switch (void 0 === t.$$.smartPtr && throwBindingError("Passing raw pointer to smart pointer is illegal"),
                this.sharingPolicy) {
                case 0:
                    t.$$.smartPtrType === this ? r = t.$$.smartPtr : throwBindingError(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
                    break;
                case 1:
                    r = t.$$.smartPtr;
                    break;
                case 2:
                    if (t.$$.smartPtrType === this)
                        r = t.$$.smartPtr;
                    else {
                        var n = t.clone();
                        r = this.rawShare(r, Emval.toHandle( () => n.delete())),
                        null !== e && e.push(this.rawDestructor, r)
                    }
                    break;
                default:
                    throwBindingError("Unsupporting sharing policy")
                }
            return r
        }
        function nonConstNoSmartPtrRawPointerToWireType(e, t) {
            if (null === t)
                return this.isReference && throwBindingError(`null is not a valid ${this.name}`),
                0;
            !t.$$ && throwBindingError(`Cannot pass "${embindRepr(t)}" as a ${this.name}`),
            !t.$$.ptr && throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`),
            t.$$.ptrType.isConst && throwBindingError(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
            var r = t.$$.ptrType.registeredClass;
            return upcastPointer(t.$$.ptr, r, this.registeredClass)
        }
        var init_RegisteredPointer = () => {
            Object.assign(RegisteredPointer.prototype, {
                getPointee(e) {
                    return this.rawGetPointee && (e = this.rawGetPointee(e)),
                    e
                },
                destructor(e) {
                    this.rawDestructor?.(e)
                },
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: readPointer,
                fromWireType: RegisteredPointer_fromWireType
            })
        }
        ;
        function RegisteredPointer(e, t, r, i, n, o, a, s, u, l, c) {
            this.name = e,
            this.registeredClass = t,
            this.isReference = r,
            this.isConst = i,
            this.isSmartPointer = n,
            this.pointeeType = o,
            this.sharingPolicy = a,
            this.rawGetPointee = s,
            this.rawConstructor = u,
            this.rawShare = l,
            this.rawDestructor = c,
            n || void 0 !== t.baseClass ? this.toWireType = genericPointerToWireType : (i ? this.toWireType = constNoSmartPtrRawPointerToWireType : this.toWireType = nonConstNoSmartPtrRawPointerToWireType,
            this.destructorFunction = null)
        }
        var replacePublicSymbol = (e, t, r) => {
            !Module.hasOwnProperty(e) && throwInternalError("Replacing nonexistant public symbol"),
            void 0 !== Module[e].overloadTable && void 0 !== r ? Module[e].overloadTable[r] = t : (Module[e] = t,
            Module[e].argCount = r)
        }
          , embind__requireFunction = (e, t) => {
            e = readLatin1String(e);
            var r = function e() {
                return getWasmTableEntry(t)
            }();
            return "function" != typeof r && throwBindingError(`unknown function pointer with signature ${e}: ${t}`),
            r
        }
          , extendError = (e, t) => {
            var r = createNamedFunction(t, function(e) {
                this.name = t,
                this.message = e;
                var r = Error(e).stack;
                void 0 !== r && (this.stack = this.toString() + "\n" + r.replace(/^Error(:[^\n]*)?\n/, ""))
            });
            return r.prototype = Object.create(e.prototype),
            r.prototype.constructor = r,
            r.prototype.toString = function() {
                return void 0 === this.message ? this.name : `${this.name}: ${this.message}`
            }
            ,
            r
        }
          , getTypeName = e => {
            var t = ___getTypeName(e)
              , r = readLatin1String(t);
            return _free(t),
            r
        }
          , throwUnboundTypeError = (e, t) => {
            var r = []
              , i = {};
            function n(e) {
                if (!i[e] && !registeredTypes[e]) {
                    if (typeDependencies[e]) {
                        typeDependencies[e].forEach(n);
                        return
                    }
                    r.push(e),
                    i[e] = !0
                }
            }
            throw t.forEach(n),
            new UnboundTypeError(`${e}: ` + r.map(getTypeName).join([", "]))
        }
          , __embind_register_class = (e, t, r, i, n, o, a, s, u, l, c, p, d) => {
            c = readLatin1String(c),
            o = embind__requireFunction(n, o),
            s &&= embind__requireFunction(a, s),
            l &&= embind__requireFunction(u, l),
            d = embind__requireFunction(p, d);
            var f = makeLegalFunctionName(c);
            exposePublicSymbol(f, function() {
                throwUnboundTypeError(`Cannot construct ${c} due to unbound types`, [i])
            }),
            whenDependentTypesAreResolved([e, t, r], i ? [i] : [], t => {
                t = t[0],
                n = i ? (r = t.registeredClass).instancePrototype : ClassHandle.prototype;
                var r, n, a = createNamedFunction(c, function(...e) {
                    if (Object.getPrototypeOf(this) !== u)
                        throw new BindingError("Use 'new' to construct " + c);
                    if (void 0 === p.constructor_body)
                        throw new BindingError(c + " has no accessible constructor");
                    var t = p.constructor_body[e.length];
                    if (void 0 === t)
                        throw new BindingError(`Tried to invoke ctor of ${c} with invalid number of parameters (${e.length}) - expected (${Object.keys(p.constructor_body).toString()}) parameters instead!`);
                    return t.apply(this, e)
                }), u = Object.create(n, {
                    constructor: {
                        value: a
                    }
                });
                a.prototype = u;
                var p = new RegisteredClass(c,a,u,d,r,o,s,l);
                p.baseClass && (p.baseClass.__derivedClasses ??= [],
                p.baseClass.__derivedClasses.push(p));
                var m = new RegisteredPointer(c,p,!0,!1,!1)
                  , h = new RegisteredPointer(c + "*",p,!1,!1,!1)
                  , g = new RegisteredPointer(c + " const*",p,!1,!0,!1);
                return registeredPointers[e] = {
                    pointerType: h,
                    constPointerType: g
                },
                replacePublicSymbol(f, a),
                [m, h, g]
            }
            )
        }
        ;
        __embind_register_class.sig = "vppppppppppppp";
        var heap32VectorToArray = (e, t) => {
            for (var r = [], i = 0; i < e; i++)
                r.push(GROWABLE_HEAP_U32()[t + 4 * i >> 2]);
            return r
        }
        ;
        function usesDestructorStack(e) {
            for (var t = 1; t < e.length; ++t)
                if (null !== e[t] && void 0 === e[t].destructorFunction)
                    return !0;
            return !1
        }
        function newFunc(e, t) {
            if (!(e instanceof Function))
                throw TypeError(`new_ called with constructor type ${typeof e} which is not a function`);
            var r = createNamedFunction(e.name || "unknownFunctionName", function() {});
            r.prototype = e.prototype;
            var i = new r
              , n = e.apply(i, t);
            return n instanceof Object ? n : i
        }
        function createJsInvoker(e, t, r, i) {
            for (var n = usesDestructorStack(e), o = e.length, a = "", s = "", u = 0; u < o - 2; ++u)
                a += (0 !== u ? ", " : "") + "arg" + u,
                s += (0 !== u ? ", " : "") + "arg" + u + "Wired";
            var l = `
        return function (${a}) {
        if (arguments.length !== ${o - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${o - 2}');
        }`;
            n && (l += "var destructors = [];\n");
            var c = n ? "destructors" : "null"
              , p = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            t && (l += "var thisWired = classParam['toWireType'](" + c + ", this);\n");
            for (var u = 0; u < o - 2; ++u)
                l += "var arg" + u + "Wired = argType" + u + "['toWireType'](" + c + ", arg" + u + ");\n",
                p.push("argType" + u);
            if (t && (s = "thisWired" + (s.length > 0 ? ", " : "") + s),
            l += (r || i ? "var rv = " : "") + "invoker(fn" + (s.length > 0 ? ", " : "") + s + ");\n",
            n)
                l += "runDestructors(destructors);\n";
            else
                for (var u = t ? 1 : 2; u < e.length; ++u) {
                    var d = 1 === u ? "thisWired" : "arg" + (u - 2) + "Wired";
                    null !== e[u].destructorFunction && (l += `${d}_dtor(${d});
`,
                    p.push(`${d}_dtor`))
                }
            return r && (l += "var ret = retType['fromWireType'](rv);\nreturn ret;\n"),
            [p, l += "}\n"]
        }
        function craftInvokerFunction(e, t, r, i, n, o) {
            var a = t.length;
            a < 2 && throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            for (var s = null !== t[1] && null !== r, u = usesDestructorStack(t), l = "void" !== t[0].name, c = [e, throwBindingError, i, n, runDestructors, t[0], t[1]], p = 0; p < a - 2; ++p)
                c.push(t[p + 2]);
            if (!u)
                for (var p = s ? 1 : 2; p < t.length; ++p)
                    null !== t[p].destructorFunction && c.push(t[p].destructorFunction);
            let[d,f] = createJsInvoker(t, s, l, o);
            return d.push(f),
            createNamedFunction(e, newFunc(Function, d)(...c))
        }
        var __embind_register_class_constructor = (e, t, r, i, n, o) => {
            var a = heap32VectorToArray(t, r);
            n = embind__requireFunction(i, n),
            whenDependentTypesAreResolved([], [e], e => {
                e = e[0];
                var r = `constructor ${e.name}`;
                if (void 0 === e.registeredClass.constructor_body && (e.registeredClass.constructor_body = []),
                void 0 !== e.registeredClass.constructor_body[t - 1])
                    throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${e.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
                return e.registeredClass.constructor_body[t - 1] = () => {
                    throwUnboundTypeError(`Cannot construct ${e.name} due to unbound types`, a)
                }
                ,
                whenDependentTypesAreResolved([], a, i => (i.splice(1, 0, null),
                e.registeredClass.constructor_body[t - 1] = craftInvokerFunction(r, i, null, n, o),
                [])),
                []
            }
            )
        }
        ;
        __embind_register_class_constructor.sig = "vpipppp";
        var getFunctionName = e => {
            let t = (e = e.trim()).indexOf("(");
            return -1 !== t ? e.substr(0, t) : e
        }
          , __embind_register_class_function = (e, t, r, i, n, o, a, s, u) => {
            var l = heap32VectorToArray(r, i);
            t = getFunctionName(t = readLatin1String(t)),
            o = embind__requireFunction(n, o),
            whenDependentTypesAreResolved([], [e], e => {
                e = e[0];
                var i = `${e.name}.${t}`;
                function n() {
                    throwUnboundTypeError(`Cannot call ${i} due to unbound types`, l)
                }
                t.startsWith("@@") && (t = Symbol[t.substring(2)]),
                s && e.registeredClass.pureVirtualFunctions.push(t);
                var c = e.registeredClass.instancePrototype
                  , p = c[t];
                return void 0 === p || void 0 === p.overloadTable && p.className !== e.name && p.argCount === r - 2 ? (n.argCount = r - 2,
                n.className = e.name,
                c[t] = n) : (ensureOverloadTable(c, t, i),
                c[t].overloadTable[r - 2] = n),
                whenDependentTypesAreResolved([], l, n => {
                    var s = craftInvokerFunction(i, n, e, o, a, u);
                    return void 0 === c[t].overloadTable ? (s.argCount = r - 2,
                    c[t] = s) : c[t].overloadTable[r - 2] = s,
                    []
                }
                ),
                []
            }
            )
        }
        ;
        __embind_register_class_function.sig = "vppippppii";
        var validateThis = (e, t, r) => (!(e instanceof Object) && throwBindingError(`${r} with invalid "this": ${e}`),
        !(e instanceof t.registeredClass.constructor) && throwBindingError(`${r} incompatible with "this" of type ${e.constructor.name}`),
        !e.$$.ptr && throwBindingError(`cannot call emscripten binding method ${r} on deleted object`),
        upcastPointer(e.$$.ptr, e.$$.ptrType.registeredClass, t.registeredClass))
          , __embind_register_class_property = (e, t, r, i, n, o, a, s, u, l) => {
            t = readLatin1String(t),
            n = embind__requireFunction(i, n),
            whenDependentTypesAreResolved([], [e], e => {
                e = e[0];
                var i = `${e.name}.${t}`
                  , c = {
                    get() {
                        throwUnboundTypeError(`Cannot access ${i} due to unbound types`, [r, a])
                    },
                    enumerable: !0,
                    configurable: !0
                };
                return u ? c.set = () => throwUnboundTypeError(`Cannot access ${i} due to unbound types`, [r, a]) : c.set = e => throwBindingError(i + " is a read-only property"),
                Object.defineProperty(e.registeredClass.instancePrototype, t, c),
                whenDependentTypesAreResolved([], u ? [r, a] : [r], r => {
                    var a = r[0]
                      , c = {
                        get() {
                            var t = validateThis(this, e, i + " getter");
                            return a.fromWireType(n(o, t))
                        },
                        enumerable: !0
                    };
                    if (u) {
                        u = embind__requireFunction(s, u);
                        var p = r[1];
                        c.set = function(t) {
                            var r = validateThis(this, e, i + " setter")
                              , n = [];
                            u(l, r, p.toWireType(n, t)),
                            runDestructors(n)
                        }
                    }
                    return Object.defineProperty(e.registeredClass.instancePrototype, t, c),
                    []
                }
                ),
                []
            }
            )
        }
        ;
        __embind_register_class_property.sig = "vpppppppppp";
        var emval_freelist = []
          , emval_handles = []
          , __emval_decref = e => {
            e > 9 && 0 == --emval_handles[e + 1] && (emval_handles[e] = void 0,
            emval_freelist.push(e))
        }
        ;
        __emval_decref.sig = "vp";
        var count_emval_handles = () => emval_handles.length / 2 - 5 - emval_freelist.length
          , init_emval = () => {
            emval_handles.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1),
            Module.count_emval_handles = count_emval_handles
        }
          , Emval = {
            toValue: e => (!e && throwBindingError("Cannot use deleted val. handle = " + e),
            emval_handles[e]),
            toHandle: e => {
                switch (e) {
                case void 0:
                    return 2;
                case null:
                    return 4;
                case !0:
                    return 6;
                case !1:
                    return 8;
                default:
                    {
                        let t = emval_freelist.pop() || emval_handles.length;
                        return emval_handles[t] = e,
                        emval_handles[t + 1] = 1,
                        t
                    }
                }
            }
        }
          , EmValType = {
            name: "emscripten::val",
            fromWireType: e => {
                var t = Emval.toValue(e);
                return __emval_decref(e),
                t
            }
            ,
            toWireType: (e, t) => Emval.toHandle(t),
            argPackAdvance: GenericWireTypeSize,
            readValueFromPointer: readPointer,
            destructorFunction: null
        }
          , __embind_register_emval = e => registerType(e, EmValType);
        __embind_register_emval.sig = "vp";
        var enumReadValueFromPointer = (e, t, r) => {
            switch (t) {
            case 1:
                return r ? function(e) {
                    return this.fromWireType(GROWABLE_HEAP_I8()[e])
                }
                : function(e) {
                    return this.fromWireType(GROWABLE_HEAP_U8()[e])
                }
                ;
            case 2:
                return r ? function(e) {
                    return this.fromWireType(GROWABLE_HEAP_I16()[e >> 1])
                }
                : function(e) {
                    return this.fromWireType(GROWABLE_HEAP_U16()[e >> 1])
                }
                ;
            case 4:
                return r ? function(e) {
                    return this.fromWireType(GROWABLE_HEAP_I32()[e >> 2])
                }
                : function(e) {
                    return this.fromWireType(GROWABLE_HEAP_U32()[e >> 2])
                }
                ;
            default:
                throw TypeError(`invalid integer width (${t}): ${e}`)
            }
        }
          , __embind_register_enum = (e, t, r, i) => {
            function n() {}
            t = readLatin1String(t),
            n.values = {},
            registerType(e, {
                name: t,
                constructor: n,
                fromWireType: function(e) {
                    return this.constructor.values[e]
                },
                toWireType: (e, t) => t.value,
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: enumReadValueFromPointer(t, r, i),
                destructorFunction: null
            }),
            exposePublicSymbol(t, n)
        }
        ;
        __embind_register_enum.sig = "vpppi";
        var requireRegisteredType = (e, t) => {
            var r = registeredTypes[e];
            return void 0 === r && throwBindingError(`${t} has unknown type ${getTypeName(e)}`),
            r
        }
          , __embind_register_enum_value = (e, t, r) => {
            var i = requireRegisteredType(e, "enum");
            t = readLatin1String(t);
            var n = i.constructor
              , o = Object.create(i.constructor.prototype, {
                value: {
                    value: r
                },
                constructor: {
                    value: createNamedFunction(`${i.name}_${t}`, function() {})
                }
            });
            n.values[r] = o,
            n[t] = o
        }
        ;
        __embind_register_enum_value.sig = "vppi";
        var floatReadValueFromPointer = (e, t) => {
            switch (t) {
            case 4:
                return function(e) {
                    return this.fromWireType(GROWABLE_HEAP_F32()[e >> 2])
                }
                ;
            case 8:
                return function(e) {
                    return this.fromWireType(GROWABLE_HEAP_F64()[e >> 3])
                }
                ;
            default:
                throw TypeError(`invalid float width (${t}): ${e}`)
            }
        }
          , __embind_register_float = (e, t, r) => {
            registerType(e, {
                name: t = readLatin1String(t),
                fromWireType: e => e,
                toWireType: (e, t) => t,
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: floatReadValueFromPointer(t, r),
                destructorFunction: null
            })
        }
        ;
        __embind_register_float.sig = "vppp";
        var __embind_register_integer = (e, t, r, i, n) => {
            t = readLatin1String(t),
            -1 === n && (n = 0xffffffff);
            var o, a = e => e;
            if (0 === i) {
                var s = 32 - 8 * r;
                a = e => e << s >>> s
            }
            var u = t.includes("unsigned")
              , l = (e, t) => {}
            ;
            registerType(e, {
                name: t,
                fromWireType: a,
                toWireType: o = u ? function(e, t) {
                    return l(t, this.name),
                    t >>> 0
                }
                : function(e, t) {
                    return l(t, this.name),
                    t
                }
                ,
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: integerReadValueFromPointer(t, r, 0 !== i),
                destructorFunction: null
            })
        }
        ;
        __embind_register_integer.sig = "vpppii";
        var __embind_register_memory_view = (e, t, r) => {
            var i = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array][t];
            function n(e) {
                var t = GROWABLE_HEAP_U32()[e >> 2]
                  , r = GROWABLE_HEAP_U32()[e + 4 >> 2];
                return new i(GROWABLE_HEAP_I8().buffer,r,t)
            }
            registerType(e, {
                name: r = readLatin1String(r),
                fromWireType: n,
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: n
            }, {
                ignoreDuplicateRegistrations: !0
            })
        }
        ;
        __embind_register_memory_view.sig = "vpip";
        var __embind_register_optional = (e, t) => {
            __embind_register_emval(e)
        }
        ;
        __embind_register_optional.sig = "vpp";
        var __embind_register_smart_ptr = (e, t, r, i, n, o, a, s, u, l, c, p) => {
            r = readLatin1String(r),
            o = embind__requireFunction(n, o),
            s = embind__requireFunction(a, s),
            l = embind__requireFunction(u, l),
            p = embind__requireFunction(c, p),
            whenDependentTypesAreResolved([e], [t], e => (e = e[0],
            [new RegisteredPointer(r,e.registeredClass,!1,!1,!0,e,i,o,s,l,p)]))
        }
        ;
        __embind_register_smart_ptr.sig = "vpppipppppppp";
        var __embind_register_std_string = (e, t) => {
            var r = "std::string" === (t = readLatin1String(t));
            registerType(e, {
                name: t,
                fromWireType(e) {
                    var t, i = GROWABLE_HEAP_U32()[e >> 2], n = e + 4;
                    if (r) {
                        for (var o = n, a = 0; a <= i; ++a) {
                            var s = n + a;
                            if (a == i || 0 == GROWABLE_HEAP_U8()[s]) {
                                var u = s - o
                                  , l = UTF8ToString(o, u);
                                void 0 === t ? t = l : (t += "\0",
                                t += l),
                                o = s + 1
                            }
                        }
                    } else {
                        for (var c = Array(i), a = 0; a < i; ++a)
                            c[a] = String.fromCharCode(GROWABLE_HEAP_U8()[n + a]);
                        t = c.join("")
                    }
                    return _free(e),
                    t
                },
                toWireType(e, t) {
                    t instanceof ArrayBuffer && (t = new Uint8Array(t));
                    var i, n = "string" == typeof t;
                    !(n || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Int8Array) && throwBindingError("Cannot pass non-string to std::string"),
                    i = r && n ? lengthBytesUTF8(t) : t.length;
                    var o = _malloc(4 + i + 1)
                      , a = o + 4;
                    if (GROWABLE_HEAP_U32()[o >> 2] = i,
                    r && n)
                        stringToUTF8(t, a, i + 1);
                    else if (n)
                        for (var s = 0; s < i; ++s) {
                            var u = t.charCodeAt(s);
                            u > 255 && (_free(a),
                            throwBindingError("String has UTF-16 code units that do not fit in 8 bits")),
                            GROWABLE_HEAP_U8()[a + s] = u
                        }
                    else
                        for (var s = 0; s < i; ++s)
                            GROWABLE_HEAP_U8()[a + s] = t[s];
                    return null !== e && e.push(_free, o),
                    o
                },
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: readPointer,
                destructorFunction(e) {
                    _free(e)
                }
            })
        }
        ;
        __embind_register_std_string.sig = "vpp";
        var UTF16ToString = (e, t) => {
            for (var r = "", i = 0; !(i >= t / 2); ++i) {
                var n = GROWABLE_HEAP_I16()[e + 2 * i >> 1];
                if (0 == n)
                    break;
                r += String.fromCharCode(n)
            }
            return r
        }
          , stringToUTF16 = (e, t, r) => {
            if ((r ??= 0x7fffffff) < 2)
                return 0;
            for (var i = t, n = (r -= 2) < 2 * e.length ? r / 2 : e.length, o = 0; o < n; ++o) {
                var a = e.charCodeAt(o);
                GROWABLE_HEAP_I16()[t >> 1] = a,
                t += 2
            }
            return GROWABLE_HEAP_I16()[t >> 1] = 0,
            t - i
        }
          , lengthBytesUTF16 = e => 2 * e.length
          , UTF32ToString = (e, t) => {
            for (var r = 0, i = ""; !(r >= t / 4); ) {
                var n = GROWABLE_HEAP_I32()[e + 4 * r >> 2];
                if (0 == n)
                    break;
                if (++r,
                n >= 65536) {
                    var o = n - 65536;
                    i += String.fromCharCode(55296 | o >> 10, 56320 | 1023 & o)
                } else
                    i += String.fromCharCode(n)
            }
            return i
        }
          , stringToUTF32 = (e, t, r) => {
            if ((r ??= 0x7fffffff) < 4)
                return 0;
            for (var i = t, n = i + r - 4, o = 0; o < e.length; ++o) {
                var a = e.charCodeAt(o);
                if (a >= 55296 && a <= 57343 && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++o)),
                GROWABLE_HEAP_I32()[t >> 2] = a,
                (t += 4) + 4 > n)
                    break
            }
            return GROWABLE_HEAP_I32()[t >> 2] = 0,
            t - i
        }
          , lengthBytesUTF32 = e => {
            for (var t = 0, r = 0; r < e.length; ++r) {
                var i = e.charCodeAt(r);
                i >= 55296 && i <= 57343 && ++r,
                t += 4
            }
            return t
        }
          , __embind_register_std_wstring = (e, t, r) => {
            var i, n, o, a;
            r = readLatin1String(r),
            2 === t ? (i = UTF16ToString,
            n = stringToUTF16,
            a = lengthBytesUTF16,
            o = e => GROWABLE_HEAP_U16()[e >> 1]) : 4 === t && (i = UTF32ToString,
            n = stringToUTF32,
            a = lengthBytesUTF32,
            o = e => GROWABLE_HEAP_U32()[e >> 2]),
            registerType(e, {
                name: r,
                fromWireType: e => {
                    for (var r, n = GROWABLE_HEAP_U32()[e >> 2], a = e + 4, s = 0; s <= n; ++s) {
                        var u = e + 4 + s * t;
                        if (s == n || 0 == o(u)) {
                            var l = u - a
                              , c = i(a, l);
                            void 0 === r ? r = c : (r += "\0",
                            r += c),
                            a = u + t
                        }
                    }
                    return _free(e),
                    r
                }
                ,
                toWireType: (e, i) => {
                    "string" != typeof i && throwBindingError(`Cannot pass non-string to C++ string type ${r}`);
                    var o = a(i)
                      , s = _malloc(4 + o + t);
                    return GROWABLE_HEAP_U32()[s >> 2] = o / t,
                    n(i, s + 4, o + t),
                    null !== e && e.push(_free, s),
                    s
                }
                ,
                argPackAdvance: GenericWireTypeSize,
                readValueFromPointer: readPointer,
                destructorFunction(e) {
                    _free(e)
                }
            })
        }
        ;
        __embind_register_std_wstring.sig = "vppp";
        var __embind_register_value_object = (e, t, r, i, n, o) => {
            structRegistrations[e] = {
                name: readLatin1String(t),
                rawConstructor: embind__requireFunction(r, i),
                rawDestructor: embind__requireFunction(n, o),
                fields: []
            }
        }
        ;
        __embind_register_value_object.sig = "vpppppp";
        var __embind_register_value_object_field = (e, t, r, i, n, o, a, s, u, l) => {
            structRegistrations[e].fields.push({
                fieldName: readLatin1String(t),
                getterReturnType: r,
                getter: embind__requireFunction(i, n),
                getterContext: o,
                setterArgumentType: a,
                setter: embind__requireFunction(s, u),
                setterContext: l
            })
        }
        ;
        __embind_register_value_object_field.sig = "vpppppppppp";
        var __embind_register_void = (e, t) => {
            registerType(e, {
                isVoid: !0,
                name: t = readLatin1String(t),
                argPackAdvance: 0,
                fromWireType: () => void 0,
                toWireType: (e, t) => void 0
            })
        }
        ;
        __embind_register_void.sig = "vpp";
        var maybeExit = () => {
            if (!keepRuntimeAlive())
                try {
                    ENVIRONMENT_IS_PTHREAD ? __emscripten_thread_exit(EXITSTATUS) : _exit(EXITSTATUS)
                } catch (e) {
                    handleException(e)
                }
        }
          , callUserCallback = e => {
            if (!ABORT)
                try {
                    e(),
                    maybeExit()
                } catch (e) {
                    try {
                        handleException(e)
                    } catch (e) {
                        if (e && "number" == typeof e && (e = Error("Number exception " + e)),
                        e && e.stack) {
                            err(e.stack);
                            var t = "videoeditor uncaught exception"
                              , r = e.stack
                              , i = /libffmpeg(?:_simd)?\.wasm\.(\w+)\s*\(/
                              , n = /\n.*?(?:(\d*?:\d*?)\)|wasm-function\[(\d*)\]:0x[0-9a-z]+\)?)/gim;
                            /wasm-function\[\d*\]/gim.test(r) && (t = r.replace(n, function(e, t, r) {
                                var n = e.match(i);
                                return n ? "," + n[1] : "," + (t || r)
                            })),
                            postMessage({
                                cmd: "vesdk_crash",
                                stack: r,
                                msg: t,
                                threadId: Module._PThreadId
                            }),
                            setTimeout( () => {
                                throw t
                            }
                            , 2e3)
                        } else
                            throw Module._PThreadId + ": " + e.message + "," + e.name + "," + e
                    }
                }
        }
          , runtimeKeepalivePush = () => {
            runtimeKeepaliveCounter += 1
        }
        ;
        runtimeKeepalivePush.sig = "v";
        var runtimeKeepalivePop = () => {
            runtimeKeepaliveCounter -= 1
        }
        ;
        runtimeKeepalivePop.sig = "v";
        var __emscripten_dlopen_js = (e, t, r, i) => {
            function n(t) {
                var n = UTF8ToString(e + 36);
                dlSetError(`'Could not load dynamic lib: ${n}
${t}`),
                runtimeKeepalivePop(),
                callUserCallback( () => getWasmTableEntry(r)(e, i))
            }
            function o() {
                runtimeKeepalivePop(),
                callUserCallback( () => getWasmTableEntry(t)(e, i))
            }
            runtimeKeepalivePush();
            var a = dlopenInternal(e, {
                loadAsync: !0
            });
            a ? a.then(o, n) : n()
        }
        ;
        __emscripten_dlopen_js.sig = "vpppp";
        var nowIsMonotonic = 1
          , __emscripten_get_now_is_monotonic = () => nowIsMonotonic;
        __emscripten_get_now_is_monotonic.sig = "i";
        var __emscripten_thread_mailbox_await = e => {
            if ("function" == typeof Atomics.waitAsync) {
                Atomics.waitAsync(GROWABLE_HEAP_I32(), e >> 2, e).value.then(checkMailbox);
                var t = e + 128;
                Atomics.store(GROWABLE_HEAP_I32(), t >> 2, 1)
            }
        }
        ;
        Module.__emscripten_thread_mailbox_await = __emscripten_thread_mailbox_await,
        __emscripten_thread_mailbox_await.sig = "vp";
        var checkMailbox = () => {
            var e = _pthread_self();
            e && (__emscripten_thread_mailbox_await(e),
            callUserCallback(__emscripten_check_mailbox))
        }
        ;
        Module.checkMailbox = checkMailbox;
        var __emscripten_notify_mailbox_postmessage = (e, t, r) => {
            if (e == t)
                setTimeout(checkMailbox);
            else if (ENVIRONMENT_IS_PTHREAD)
                postMessage({
                    targetThread: e,
                    cmd: "checkMailbox"
                });
            else {
                var i = PThread.pthreads[e];
                if (!i)
                    return;
                i.postMessage({
                    cmd: "checkMailbox"
                })
            }
        }
        ;
        __emscripten_notify_mailbox_postmessage.sig = "vppp";
        var proxiedJSCallArgs = []
          , __emscripten_receive_on_main_thread_js = (e, t, r, i, n) => {
            i /= 2,
            proxiedJSCallArgs.length = i;
            for (var o = n >> 3, a = 0; a < i; a++)
                HEAP64[o + 2 * a] ? proxiedJSCallArgs[a] = HEAP64[o + 2 * a + 1] : proxiedJSCallArgs[a] = GROWABLE_HEAP_F64()[o + 2 * a + 1];
            var s = t ? ASM_CONSTS[t] : proxiedFunctionTable[e];
            PThread.currentProxiedOperationCallerThread = r;
            var u = s(...proxiedJSCallArgs);
            return PThread.currentProxiedOperationCallerThread = 0,
            u
        }
        ;
        __emscripten_receive_on_main_thread_js.sig = "dippip";
        var JSEvents = {
            removeAllEventListeners() {
                for (; JSEvents.eventHandlers.length; )
                    JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);
                JSEvents.deferredCalls = []
            },
            inEventHandler: 0,
            deferredCalls: [],
            deferCall(e, t, r) {
                function i(e, t) {
                    if (e.length != t.length)
                        return !1;
                    for (var r in e)
                        if (e[r] != t[r])
                            return !1;
                    return !0
                }
                for (var n in JSEvents.deferredCalls) {
                    var o = JSEvents.deferredCalls[n];
                    if (o.targetFunction == e && i(o.argsList, r))
                        return
                }
                JSEvents.deferredCalls.push({
                    targetFunction: e,
                    precedence: t,
                    argsList: r
                }),
                JSEvents.deferredCalls.sort( (e, t) => e.precedence < t.precedence)
            },
            removeDeferredCalls(e) {
                for (var t = 0; t < JSEvents.deferredCalls.length; ++t)
                    JSEvents.deferredCalls[t].targetFunction == e && (JSEvents.deferredCalls.splice(t, 1),
                    --t)
            },
            canPerformEventHandlerRequests: () => navigator.userActivation ? navigator.userActivation.isActive : JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls,
            runDeferredCalls() {
                if (!!JSEvents.canPerformEventHandlerRequests())
                    for (var e = 0; e < JSEvents.deferredCalls.length; ++e) {
                        var t = JSEvents.deferredCalls[e];
                        JSEvents.deferredCalls.splice(e, 1),
                        --e,
                        t.targetFunction(...t.argsList)
                    }
            },
            eventHandlers: [],
            removeAllHandlersOnTarget: (e, t) => {
                for (var r = 0; r < JSEvents.eventHandlers.length; ++r)
                    JSEvents.eventHandlers[r].target == e && (!t || t == JSEvents.eventHandlers[r].eventTypeString) && JSEvents._removeHandler(r--)
            }
            ,
            _removeHandler(e) {
                var t = JSEvents.eventHandlers[e];
                t.target.removeEventListener(t.eventTypeString, t.eventListenerFunc, t.useCapture),
                JSEvents.eventHandlers.splice(e, 1)
            },
            registerOrRemoveHandler(e) {
                if (!e.target)
                    return -4;
                if (e.callbackfunc)
                    e.eventListenerFunc = function(t) {
                        ++JSEvents.inEventHandler,
                        JSEvents.currentEventHandler = e,
                        JSEvents.runDeferredCalls(),
                        e.handlerFunc(t),
                        JSEvents.runDeferredCalls(),
                        --JSEvents.inEventHandler
                    }
                    ,
                    e.target.addEventListener(e.eventTypeString, e.eventListenerFunc, e.useCapture),
                    JSEvents.eventHandlers.push(e);
                else
                    for (var t = 0; t < JSEvents.eventHandlers.length; ++t)
                        JSEvents.eventHandlers[t].target == e.target && JSEvents.eventHandlers[t].eventTypeString == e.eventTypeString && JSEvents._removeHandler(t--);
                return 0
            },
            getTargetThreadForEventCallback(e) {
                switch (e) {
                case 1:
                    return 0;
                case 2:
                    return PThread.currentProxiedOperationCallerThread;
                default:
                    return e
                }
            },
            getNodeNameForTarget: e => e ? e == window ? "#window" : e == screen ? "#screen" : e?.nodeName || "" : "",
            fullscreenEnabled: () => document.fullscreenEnabled || document.webkitFullscreenEnabled
        }
          , stringToNewUTF8 = e => {
            var t = lengthBytesUTF8(e) + 1
              , r = _malloc(t);
            return r && stringToUTF8(e, r, t),
            r
        }
          , setOffscreenCanvasSizeOnTargetThread = (e, t, r, i) => {
            t = t ? UTF8ToString(t) : "";
            var n = 0;
            t && (n = stringToNewUTF8(t)),
            __emscripten_set_offscreencanvas_size_on_thread(e, n, r, i)
        }
          , webgl_enable_ANGLE_instanced_arrays = e => {
            var t = e.getExtension("ANGLE_instanced_arrays");
            if (t)
                return e.vertexAttribDivisor = (e, r) => t.vertexAttribDivisorANGLE(e, r),
                e.drawArraysInstanced = (e, r, i, n) => t.drawArraysInstancedANGLE(e, r, i, n),
                e.drawElementsInstanced = (e, r, i, n, o) => t.drawElementsInstancedANGLE(e, r, i, n, o),
                1
        }
          , webgl_enable_OES_vertex_array_object = e => {
            var t = e.getExtension("OES_vertex_array_object");
            if (t)
                return e.createVertexArray = () => t.createVertexArrayOES(),
                e.deleteVertexArray = e => t.deleteVertexArrayOES(e),
                e.bindVertexArray = e => t.bindVertexArrayOES(e),
                e.isVertexArray = e => t.isVertexArrayOES(e),
                1
        }
          , webgl_enable_WEBGL_draw_buffers = e => {
            var t = e.getExtension("WEBGL_draw_buffers");
            if (t)
                return e.drawBuffers = (e, r) => t.drawBuffersWEBGL(e, r),
                1
        }
          , webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance = e => !!(e.dibvbi = e.getExtension("WEBGL_draw_instanced_base_vertex_base_instance"))
          , webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance = e => !!(e.mdibvbi = e.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance"))
          , webgl_enable_WEBGL_multi_draw = e => !!(e.multiDrawWebgl = e.getExtension("WEBGL_multi_draw"))
          , getEmscriptenSupportedExtensions = e => {
            var t = ["ANGLE_instanced_arrays", "EXT_blend_minmax", "EXT_disjoint_timer_query", "EXT_frag_depth", "EXT_shader_texture_lod", "EXT_sRGB", "OES_element_index_uint", "OES_fbo_render_mipmap", "OES_standard_derivatives", "OES_texture_float", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_color_buffer_float", "WEBGL_depth_texture", "WEBGL_draw_buffers", "EXT_color_buffer_float", "EXT_conservative_depth", "EXT_disjoint_timer_query_webgl2", "EXT_texture_norm16", "NV_shader_noperspective_interpolation", "WEBGL_clip_cull_distance", "EXT_color_buffer_half_float", "EXT_depth_clamp", "EXT_float_blend", "EXT_texture_compression_bptc", "EXT_texture_compression_rgtc", "EXT_texture_filter_anisotropic", "KHR_parallel_shader_compile", "OES_texture_float_linear", "WEBGL_blend_func_extended", "WEBGL_compressed_texture_astc", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_debug_renderer_info", "WEBGL_debug_shaders", "WEBGL_lose_context", "WEBGL_multi_draw"];
            return (e.getSupportedExtensions() || []).filter(e => t.includes(e))
        }
          , GL = {
            counter: 1,
            buffers: [],
            mappedBuffers: {},
            programs: [],
            framebuffers: [],
            renderbuffers: [],
            textures: [],
            shaders: [],
            vaos: [],
            contexts: {},
            offscreenCanvases: {},
            queries: [],
            samplers: [],
            transformFeedbacks: [],
            syncs: [],
            byteSizeByTypeRoot: 5120,
            byteSizeByType: [1, 1, 2, 2, 4, 4, 4, 2, 3, 4, 8],
            stringCache: {},
            stringiCache: {},
            unpackAlignment: 4,
            recordError: e => {
                !GL.lastError && (GL.lastError = e)
            }
            ,
            getNewId: e => {
                for (var t = GL.counter++, r = e.length; r < t; r++)
                    e[r] = null;
                return t
            }
            ,
            genObject: (e, t, r, i) => {
                for (var n = 0; n < e; n++) {
                    var o = GLctx[r]()
                      , a = o && GL.getNewId(i);
                    o ? (o.name = a,
                    i[a] = o) : GL.recordError(1282),
                    GROWABLE_HEAP_I32()[t + 4 * n >> 2] = a
                }
            }
            ,
            MAX_TEMP_BUFFER_SIZE: 2097152,
            numTempVertexBuffersPerSize: 64,
            log2ceilLookup: e => 32 - Math.clz32(0 === e ? 0 : e - 1),
            generateTempBuffers: (e, t) => {
                var r = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);
                t.tempVertexBufferCounters1 = [],
                t.tempVertexBufferCounters2 = [],
                t.tempVertexBufferCounters1.length = t.tempVertexBufferCounters2.length = r + 1,
                t.tempVertexBuffers1 = [],
                t.tempVertexBuffers2 = [],
                t.tempVertexBuffers1.length = t.tempVertexBuffers2.length = r + 1,
                t.tempIndexBuffers = [],
                t.tempIndexBuffers.length = r + 1;
                for (var i = 0; i <= r; ++i) {
                    t.tempIndexBuffers[i] = null,
                    t.tempVertexBufferCounters1[i] = t.tempVertexBufferCounters2[i] = 0;
                    var n = GL.numTempVertexBuffersPerSize;
                    t.tempVertexBuffers1[i] = [],
                    t.tempVertexBuffers2[i] = [];
                    var o = t.tempVertexBuffers1[i]
                      , a = t.tempVertexBuffers2[i];
                    o.length = a.length = n;
                    for (var s = 0; s < n; ++s)
                        o[s] = a[s] = null
                }
                if (e) {
                    t.tempQuadIndexBuffer = GLctx.createBuffer(),
                    t.GLctx.bindBuffer(34963, t.tempQuadIndexBuffer);
                    for (var u = GL.MAX_TEMP_BUFFER_SIZE >> 1, l = new Uint16Array(u), i = 0, c = 0; l[i++] = c,
                    !(i >= u); ) {
                        ;if (l[i++] = c + 1,
                        i >= u)
                            break;
                        if (l[i++] = c + 2,
                        i >= u)
                            break;
                        if (l[i++] = c,
                        i >= u)
                            break;
                        if (l[i++] = c + 2,
                        i >= u)
                            break;
                        if (l[i++] = c + 3,
                        i >= u)
                            break;
                        c += 4
                    }
                    t.GLctx.bufferData(34963, l, 35044),
                    t.GLctx.bindBuffer(34963, null)
                }
            }
            ,
            getTempVertexBuffer: e => {
                var t = GL.log2ceilLookup(e)
                  , r = GL.currentContext.tempVertexBuffers1[t]
                  , i = GL.currentContext.tempVertexBufferCounters1[t];
                GL.currentContext.tempVertexBufferCounters1[t] = GL.currentContext.tempVertexBufferCounters1[t] + 1 & GL.numTempVertexBuffersPerSize - 1;
                var n = r[i];
                if (n)
                    return n;
                var o = GLctx.getParameter(34964);
                return r[i] = GLctx.createBuffer(),
                GLctx.bindBuffer(34962, r[i]),
                GLctx.bufferData(34962, 1 << t, 35048),
                GLctx.bindBuffer(34962, o),
                r[i]
            }
            ,
            getTempIndexBuffer: e => {
                var t = GL.log2ceilLookup(e)
                  , r = GL.currentContext.tempIndexBuffers[t];
                if (r)
                    return r;
                var i = GLctx.getParameter(34965);
                return GL.currentContext.tempIndexBuffers[t] = GLctx.createBuffer(),
                GLctx.bindBuffer(34963, GL.currentContext.tempIndexBuffers[t]),
                GLctx.bufferData(34963, 1 << t, 35048),
                GLctx.bindBuffer(34963, i),
                GL.currentContext.tempIndexBuffers[t]
            }
            ,
            newRenderingFrameStarted: () => {
                if (!!GL.currentContext) {
                    var e = GL.currentContext.tempVertexBuffers1;
                    GL.currentContext.tempVertexBuffers1 = GL.currentContext.tempVertexBuffers2,
                    GL.currentContext.tempVertexBuffers2 = e,
                    e = GL.currentContext.tempVertexBufferCounters1,
                    GL.currentContext.tempVertexBufferCounters1 = GL.currentContext.tempVertexBufferCounters2,
                    GL.currentContext.tempVertexBufferCounters2 = e;
                    for (var t = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE), r = 0; r <= t; ++r)
                        GL.currentContext.tempVertexBufferCounters1[r] = 0
                }
            }
            ,
            getSource: (e, t, r, i) => {
                for (var n = "", o = 0; o < t; ++o) {
                    var a = i ? GROWABLE_HEAP_U32()[i + 4 * o >> 2] : void 0;
                    n += UTF8ToString(GROWABLE_HEAP_U32()[r + 4 * o >> 2], a)
                }
                return n
            }
            ,
            calcBufLength: (e, t, r, i) => r > 0 ? i * r : e * GL.byteSizeByType[t - GL.byteSizeByTypeRoot] * i,
            usedTempBuffers: [],
            preDrawHandleClientVertexAttribBindings: e => {
                GL.resetBufferBinding = !1;
                for (var t = 0; t < GL.currentContext.maxVertexAttribs; ++t) {
                    var r = GL.currentContext.clientBuffers[t];
                    if (r.clientside && r.enabled) {
                        GL.resetBufferBinding = !0;
                        var i = GL.calcBufLength(r.size, r.type, r.stride, e)
                          , n = GL.getTempVertexBuffer(i);
                        GLctx.bindBuffer(34962, n),
                        GLctx.bufferSubData(34962, 0, GROWABLE_HEAP_U8().subarray(r.ptr, r.ptr + i)),
                        r.vertexAttribPointerAdaptor.call(GLctx, t, r.size, r.type, r.normalized, r.stride, 0)
                    }
                }
            }
            ,
            postDrawHandleClientVertexAttribBindings: () => {
                GL.resetBufferBinding && GLctx.bindBuffer(34962, GL.buffers[GLctx.currentArrayBufferBinding])
            }
            ,
            createContext: (e, t) => {
                if (!e.getContextSafariWebGL2Fixed) {
                    function r(t, r) {
                        var i = e.getContextSafariWebGL2Fixed(t, r);
                        return "webgl" == t == i instanceof WebGLRenderingContext ? i : null
                    }
                    e.getContextSafariWebGL2Fixed = e.getContext,
                    e.getContext = r
                }
                var i = t.majorVersion > 1 ? e.getContext("webgl2", t) : e.getContext("webgl", t);
                return i ? GL.registerContext(i, t) : 0
            }
            ,
            registerContext: (e, t) => {
                var r = _malloc(8);
                GROWABLE_HEAP_U32()[r + 4 >> 2] = _pthread_self();
                var i = {
                    handle: r,
                    attributes: t,
                    version: t.majorVersion,
                    GLctx: e
                };
                e.canvas && (e.canvas.GLctxObject = i),
                GL.contexts[r] = i,
                (void 0 === t.enableExtensionsByDefault || t.enableExtensionsByDefault) && GL.initExtensions(i),
                i.maxVertexAttribs = i.GLctx.getParameter(34921),
                i.clientBuffers = [];
                for (var n = 0; n < i.maxVertexAttribs; n++)
                    i.clientBuffers[n] = {
                        enabled: !1,
                        clientside: !1,
                        size: 0,
                        type: 0,
                        normalized: 0,
                        stride: 0,
                        ptr: 0,
                        vertexAttribPointerAdaptor: null
                    };
                return GL.generateTempBuffers(!1, i),
                r
            }
            ,
            makeContextCurrent: e => (GL.currentContext = GL.contexts[e],
            Module.ctx = GLctx = GL.currentContext?.GLctx,
            !(e && !GLctx)),
            getContext: e => GL.contexts[e],
            deleteContext: e => {
                GL.currentContext === GL.contexts[e] && (GL.currentContext = null),
                "object" == typeof JSEvents && JSEvents.removeAllHandlersOnTarget(GL.contexts[e].GLctx.canvas),
                GL.contexts[e] && GL.contexts[e].GLctx.canvas && (GL.contexts[e].GLctx.canvas.GLctxObject = void 0),
                _free(GL.contexts[e].handle),
                GL.contexts[e] = null
            }
            ,
            initExtensions: e => {
                if (!(e ||= GL.currentContext).initExtensionsDone) {
                    e.initExtensionsDone = !0;
                    var t = e.GLctx;
                    webgl_enable_ANGLE_instanced_arrays(t),
                    webgl_enable_OES_vertex_array_object(t),
                    webgl_enable_WEBGL_draw_buffers(t),
                    webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(t),
                    webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(t),
                    e.version >= 2 && (t.disjointTimerQueryExt = t.getExtension("EXT_disjoint_timer_query_webgl2")),
                    (e.version < 2 || !t.disjointTimerQueryExt) && (t.disjointTimerQueryExt = t.getExtension("EXT_disjoint_timer_query")),
                    webgl_enable_WEBGL_multi_draw(t),
                    getEmscriptenSupportedExtensions(t).forEach(e => {
                        !e.includes("lose_context") && !e.includes("debug") && t.getExtension(e)
                    }
                    )
                }
            }
        }
          , maybeCStringToJsString = e => e > 2 ? UTF8ToString(e) : e
          , findCanvasEventTarget = e => (e = maybeCStringToJsString(e),
        GL.offscreenCanvases[e.substr(1)] || "canvas" == e && Object.keys(GL.offscreenCanvases)[0] || "undefined" != typeof document && document.querySelector(e))
          , setCanvasElementSizeCallingThread = (e, t, r) => {
            var i = findCanvasEventTarget(e);
            if (!i)
                return -4;
            if (i.canvasSharedPtr && (GROWABLE_HEAP_I32()[i.canvasSharedPtr >> 2] = t,
            GROWABLE_HEAP_I32()[i.canvasSharedPtr + 4 >> 2] = r),
            i.offscreenCanvas || !i.controlTransferredOffscreen) {
                i.offscreenCanvas && (i = i.offscreenCanvas);
                var n = !1;
                if (i.GLctxObject?.GLctx) {
                    var o = i.GLctxObject.GLctx.getParameter(2978);
                    n = 0 === o[0] && 0 === o[1] && o[2] === i.width && o[3] === i.height
                }
                i.width = t,
                i.height = r,
                n && i.GLctxObject.GLctx.viewport(0, 0, t, r)
            } else if (i.canvasSharedPtr)
                return setOffscreenCanvasSizeOnTargetThread(GROWABLE_HEAP_U32()[i.canvasSharedPtr + 8 >> 2], e, t, r),
                1;
            else
                return -4;
            return 0
        }
        ;
        function setCanvasElementSizeMainThread(e, t, r) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(3, 0, 1, e, t, r) : setCanvasElementSizeCallingThread(e, t, r)
        }
        var _emscripten_set_canvas_element_size = (e, t, r) => findCanvasEventTarget(e) ? setCanvasElementSizeCallingThread(e, t, r) : setCanvasElementSizeMainThread(e, t, r);
        _emscripten_set_canvas_element_size.sig = "ipii";
        var __emscripten_set_offscreencanvas_size = _emscripten_set_canvas_element_size;
        __emscripten_set_offscreencanvas_size.sig = "ipii";
        var __emscripten_system = e => e ? -52 : 0;
        __emscripten_system.sig = "ip";
        var __emscripten_thread_exit_joinable = e => {
            ENVIRONMENT_IS_PTHREAD ? postMessage({
                cmd: "markAsFinshed",
                thread: e
            }) : markAsFinshed(e)
        }
        ;
        __emscripten_thread_exit_joinable.sig = "vp";
        var __emscripten_thread_set_strongref = e => {}
        ;
        __emscripten_thread_set_strongref.sig = "vp";
        var emval_returnValue = (e, t, r) => {
            var i = []
              , n = e.toWireType(i, r);
            return i.length && (GROWABLE_HEAP_U32()[t >> 2] = Emval.toHandle(i)),
            n
        }
          , __emval_as = (e, t, r) => (e = Emval.toValue(e),
        emval_returnValue(t = requireRegisteredType(t, "emval::as"), r, e));
        __emval_as.sig = "dppp";
        var __emval_as_int64 = (e, t) => (e = Emval.toValue(e),
        (t = requireRegisteredType(t, "emval::as")).toWireType(null, e));
        __emval_as_int64.sig = "jpp";
        var emval_methodCallers = []
          , __emval_call = (e, t, r, i) => (e = emval_methodCallers[e],
        e(null, t = Emval.toValue(t), r, i));
        __emval_call.sig = "dpppp";
        var emval_symbols = {}
          , getStringOrSymbol = e => {
            var t = emval_symbols[e];
            return void 0 === t ? readLatin1String(e) : t
        }
          , __emval_call_method = (e, t, r, i, n) => (e = emval_methodCallers[e],
        t = Emval.toValue(t),
        e(t, t[r = getStringOrSymbol(r)], i, n));
        __emval_call_method.sig = "dppppp";
        var emval_addMethodCaller = e => {
            var t = emval_methodCallers.length;
            return emval_methodCallers.push(e),
            t
        }
          , emval_lookupTypes = (e, t) => {
            for (var r = Array(e), i = 0; i < e; ++i)
                r[i] = requireRegisteredType(GROWABLE_HEAP_U32()[t + 4 * i >> 2], "parameter " + i);
            return r
        }
          , reflectConstruct = Reflect.construct
          , __emval_get_method_caller = (e, t, r) => {
            var i = emval_lookupTypes(e, t)
              , n = i.shift();
            e--;
            var o = `return function (obj, func, destructorsRef, args) {
`
              , a = 0
              , s = [];
            0 === r && s.push("obj");
            for (var u = ["retType"], l = [n], c = 0; c < e; ++c)
                s.push("arg" + c),
                u.push("argType" + c),
                l.push(i[c]),
                o += `  var arg${c} = argType${c}.readValueFromPointer(args${a ? "+" + a : ""});
`,
                a += i[c].argPackAdvance;
            var p = 1 === r ? "new func" : "func.call";
            o += `  var rv = ${p}(${s.join(", ")});
`,
            !n.isVoid && (u.push("emval_returnValue"),
            l.push(emval_returnValue),
            o += "  return emval_returnValue(retType, destructorsRef, rv);\n"),
            o += "};\n",
            u.push(o);
            var d = newFunc(Function, u)(...l);
            return emval_addMethodCaller(createNamedFunction(`methodCaller<(${i.map(e => e.name).join(", ")}) => ${n.name}>`, d))
        }
        ;
        __emval_get_method_caller.sig = "pipi";
        var __emval_get_property = (e, t) => (e = Emval.toValue(e),
        t = Emval.toValue(t),
        Emval.toHandle(e[t]));
        __emval_get_property.sig = "ppp";
        var __emval_incref = e => {
            e > 9 && (emval_handles[e + 1] += 1)
        }
        ;
        __emval_incref.sig = "vp";
        var __emval_new_array = () => Emval.toHandle([]);
        __emval_new_array.sig = "p";
        var __emval_new_array_from_memory_view = e => {
            for (var t = Array((e = Emval.toValue(e)).length), r = 0; r < e.length; r++)
                t[r] = e[r];
            return Emval.toHandle(t)
        }
        ;
        __emval_new_array_from_memory_view.sig = "pp";
        var __emval_new_cstring = e => Emval.toHandle(getStringOrSymbol(e));
        __emval_new_cstring.sig = "pp";
        var __emval_new_object = () => Emval.toHandle({});
        __emval_new_object.sig = "p";
        var __emval_run_destructors = e => {
            runDestructors(Emval.toValue(e)),
            __emval_decref(e)
        }
        ;
        __emval_run_destructors.sig = "vp";
        var __emval_set_property = (e, t, r) => {
            e = Emval.toValue(e),
            t = Emval.toValue(t),
            r = Emval.toValue(r),
            e[t] = r
        }
        ;
        __emval_set_property.sig = "vppp";
        var __emval_take_value = (e, t) => {
            var r = (e = requireRegisteredType(e, "_emval_take_value")).readValueFromPointer(t);
            return Emval.toHandle(r)
        }
        ;
        function __gmtime_js(e, t) {
            var r = new Date(1e3 * (e = bigintToI53Checked(e)));
            GROWABLE_HEAP_I32()[t >> 2] = r.getUTCSeconds(),
            GROWABLE_HEAP_I32()[t + 4 >> 2] = r.getUTCMinutes(),
            GROWABLE_HEAP_I32()[t + 8 >> 2] = r.getUTCHours(),
            GROWABLE_HEAP_I32()[t + 12 >> 2] = r.getUTCDate(),
            GROWABLE_HEAP_I32()[t + 16 >> 2] = r.getUTCMonth(),
            GROWABLE_HEAP_I32()[t + 20 >> 2] = r.getUTCFullYear() - 1900,
            GROWABLE_HEAP_I32()[t + 24 >> 2] = r.getUTCDay();
            var i = Date.UTC(r.getUTCFullYear(), 0, 1, 0, 0, 0, 0)
              , n = (r.getTime() - i) / 864e5 | 0;
            GROWABLE_HEAP_I32()[t + 28 >> 2] = n
        }
        __emval_take_value.sig = "ppp",
        __gmtime_js.sig = "vjp";
        var isLeapYear = e => e % 4 == 0 && (e % 100 != 0 || e % 400 == 0)
          , MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]
          , MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
          , ydayFromDate = e => (isLeapYear(e.getFullYear()) ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE)[e.getMonth()] + e.getDate() - 1;
        function __localtime_js(e, t) {
            var r = new Date(1e3 * (e = bigintToI53Checked(e)));
            GROWABLE_HEAP_I32()[t >> 2] = r.getSeconds(),
            GROWABLE_HEAP_I32()[t + 4 >> 2] = r.getMinutes(),
            GROWABLE_HEAP_I32()[t + 8 >> 2] = r.getHours(),
            GROWABLE_HEAP_I32()[t + 12 >> 2] = r.getDate(),
            GROWABLE_HEAP_I32()[t + 16 >> 2] = r.getMonth(),
            GROWABLE_HEAP_I32()[t + 20 >> 2] = r.getFullYear() - 1900,
            GROWABLE_HEAP_I32()[t + 24 >> 2] = r.getDay();
            var i = 0 | ydayFromDate(r);
            GROWABLE_HEAP_I32()[t + 28 >> 2] = i,
            GROWABLE_HEAP_I32()[t + 36 >> 2] = -(60 * r.getTimezoneOffset());
            var n = new Date(r.getFullYear(),0,1)
              , o = new Date(r.getFullYear(),6,1).getTimezoneOffset()
              , a = n.getTimezoneOffset()
              , s = 0 | (o != a && r.getTimezoneOffset() == Math.min(a, o));
            GROWABLE_HEAP_I32()[t + 32 >> 2] = s
        }
        __localtime_js.sig = "vjp";
        var __mktime_js = function(e) {
            return BigInt(( () => {
                var t = new Date(GROWABLE_HEAP_I32()[e + 20 >> 2] + 1900,GROWABLE_HEAP_I32()[e + 16 >> 2],GROWABLE_HEAP_I32()[e + 12 >> 2],GROWABLE_HEAP_I32()[e + 8 >> 2],GROWABLE_HEAP_I32()[e + 4 >> 2],GROWABLE_HEAP_I32()[e >> 2],0)
                  , r = GROWABLE_HEAP_I32()[e + 32 >> 2]
                  , i = t.getTimezoneOffset()
                  , n = new Date(t.getFullYear(),0,1)
                  , o = new Date(t.getFullYear(),6,1).getTimezoneOffset()
                  , a = n.getTimezoneOffset()
                  , s = Math.min(a, o);
                if (r < 0)
                    GROWABLE_HEAP_I32()[e + 32 >> 2] = Number(o != a && s == i);
                else if (r > 0 != (s == i)) {
                    var u = Math.max(a, o)
                      , l = r > 0 ? s : u;
                    t.setTime(t.getTime() + (l - i) * 6e4)
                }
                GROWABLE_HEAP_I32()[e + 24 >> 2] = t.getDay();
                var c = 0 | ydayFromDate(t);
                GROWABLE_HEAP_I32()[e + 28 >> 2] = c,
                GROWABLE_HEAP_I32()[e >> 2] = t.getSeconds(),
                GROWABLE_HEAP_I32()[e + 4 >> 2] = t.getMinutes(),
                GROWABLE_HEAP_I32()[e + 8 >> 2] = t.getHours(),
                GROWABLE_HEAP_I32()[e + 12 >> 2] = t.getDate(),
                GROWABLE_HEAP_I32()[e + 16 >> 2] = t.getMonth(),
                GROWABLE_HEAP_I32()[e + 20 >> 2] = t.getYear();
                var p = t.getTime();
                return isNaN(p) ? -1 : p / 1e3
            }
            )())
        };
        __mktime_js.sig = "jp";
        var __tzset_js = (e, t, r) => {
            var i = (new Date).getFullYear()
              , n = new Date(i,0,1)
              , o = new Date(i,6,1)
              , a = n.getTimezoneOffset()
              , s = o.getTimezoneOffset()
              , u = Math.max(a, s);
            function l(e) {
                var t = e.toTimeString().match(/\(([A-Za-z ]+)\)$/);
                return t ? t[1] : "GMT"
            }
            GROWABLE_HEAP_U32()[e >> 2] = 60 * u,
            GROWABLE_HEAP_I32()[t >> 2] = Number(a != s);
            var c = l(n)
              , p = l(o)
              , d = stringToNewUTF8(c)
              , f = stringToNewUTF8(p);
            s < a ? (GROWABLE_HEAP_U32()[r >> 2] = d,
            GROWABLE_HEAP_U32()[r + 4 >> 2] = f) : (GROWABLE_HEAP_U32()[r >> 2] = f,
            GROWABLE_HEAP_U32()[r + 4 >> 2] = d)
        }
        ;
        __tzset_js.sig = "vppp";
        var __wasmfs_copy_preloaded_file_data = (e, t) => GROWABLE_HEAP_U8().set(wasmFSPreloadedFiles[e].fileData, t);
        __wasmfs_copy_preloaded_file_data.sig = "vip";
        var wasmFSPreloadedDirs = []
          , __wasmfs_get_num_preloaded_dirs = () => wasmFSPreloadedDirs.length;
        __wasmfs_get_num_preloaded_dirs.sig = "i";
        var wasmFSPreloadedFiles = []
          , wasmFSPreloadingFlushed = !1
          , __wasmfs_get_num_preloaded_files = () => (wasmFSPreloadingFlushed = !0,
        wasmFSPreloadedFiles.length);
        __wasmfs_get_num_preloaded_files.sig = "i";
        var __wasmfs_get_preloaded_child_path = (e, t) => {
            var r = wasmFSPreloadedDirs[e].childName
              , i = lengthBytesUTF8(r) + 1;
            stringToUTF8(r, t, i)
        }
        ;
        __wasmfs_get_preloaded_child_path.sig = "vip";
        var __wasmfs_get_preloaded_file_mode = e => wasmFSPreloadedFiles[e].mode;
        __wasmfs_get_preloaded_file_mode.sig = "ii";
        var __wasmfs_get_preloaded_file_size = e => wasmFSPreloadedFiles[e].fileData.length;
        __wasmfs_get_preloaded_file_size.sig = "pi";
        var __wasmfs_get_preloaded_parent_path = (e, t) => {
            var r = wasmFSPreloadedDirs[e].parentPath
              , i = lengthBytesUTF8(r) + 1;
            stringToUTF8(r, t, i)
        }
        ;
        __wasmfs_get_preloaded_parent_path.sig = "vip";
        var __wasmfs_get_preloaded_path_name = (e, t) => {
            var r = wasmFSPreloadedFiles[e].pathName
              , i = lengthBytesUTF8(r) + 1;
            stringToUTF8(r, t, i)
        }
        ;
        __wasmfs_get_preloaded_path_name.sig = "vip";
        var __wasmfs_jsimpl_alloc_file = (e, t) => wasmFS$backends[e].allocFile(t);
        __wasmfs_jsimpl_alloc_file.sig = "vpp";
        var __wasmfs_jsimpl_free_file = (e, t) => wasmFS$backends[e].freeFile(t);
        __wasmfs_jsimpl_free_file.sig = "vpp";
        var __wasmfs_jsimpl_get_size = (e, t) => wasmFS$backends[e].getSize(t);
        function __wasmfs_jsimpl_read(e, t, r, i, n) {
            return (n = bigintToI53Checked(n),
            wasmFS$backends[e].read) ? wasmFS$backends[e].read(t, r, i, n) : -28
        }
        function __wasmfs_jsimpl_write(e, t, r, i, n) {
            return (n = bigintToI53Checked(n),
            wasmFS$backends[e].write) ? wasmFS$backends[e].write(t, r, i, n) : -28
        }
        __wasmfs_jsimpl_get_size.sig = "ipp",
        __wasmfs_jsimpl_read.sig = "ippppj",
        __wasmfs_jsimpl_write.sig = "ippppj";
        var FS_stdin_getChar_buffer = [];
        function intArrayFromString(e, t, r) {
            var i = Array(r > 0 ? r : lengthBytesUTF8(e) + 1)
              , n = stringToUTF8Array(e, i, 0, i.length);
            return t && (i.length = n),
            i
        }
        var FS_stdin_getChar = () => {
            if (!FS_stdin_getChar_buffer.length) {
                var e = null;
                if ("undefined" != typeof window && "function" == typeof window.prompt ? null !== (e = window.prompt("Input: ")) && (e += "\n") : "function" == typeof readline && null !== (e = readline()) && (e += "\n"),
                !e)
                    return null;
                FS_stdin_getChar_buffer = intArrayFromString(e, !0)
            }
            return FS_stdin_getChar_buffer.shift()
        }
          , __wasmfs_stdin_get_char = () => {
            var e = FS_stdin_getChar();
            return "number" == typeof e ? e : -1
        }
        ;
        __wasmfs_stdin_get_char.sig = "i";
        var _abort = () => {
            abort("")
        }
        ;
        function _av_add_index_entry(...e) {
            return wasmImports.av_add_index_entry(...e)
        }
        function _av_audio_fifo_alloc(...e) {
            return wasmImports.av_audio_fifo_alloc(...e)
        }
        function _av_audio_fifo_drain(...e) {
            return wasmImports.av_audio_fifo_drain(...e)
        }
        function _av_audio_fifo_free(...e) {
            return wasmImports.av_audio_fifo_free(...e)
        }
        function _av_audio_fifo_peek_at(...e) {
            return wasmImports.av_audio_fifo_peek_at(...e)
        }
        function _av_audio_fifo_read(...e) {
            return wasmImports.av_audio_fifo_read(...e)
        }
        function _av_audio_fifo_reset(...e) {
            return wasmImports.av_audio_fifo_reset(...e)
        }
        function _av_audio_fifo_size(...e) {
            return wasmImports.av_audio_fifo_size(...e)
        }
        function _av_audio_fifo_space(...e) {
            return wasmImports.av_audio_fifo_space(...e)
        }
        function _av_audio_fifo_write(...e) {
            return wasmImports.av_audio_fifo_write(...e)
        }
        function _av_bsf_alloc(...e) {
            return wasmImports.av_bsf_alloc(...e)
        }
        function _av_bsf_free(...e) {
            return wasmImports.av_bsf_free(...e)
        }
        function _av_bsf_get_by_name(...e) {
            return wasmImports.av_bsf_get_by_name(...e)
        }
        function _av_bsf_init(...e) {
            return wasmImports.av_bsf_init(...e)
        }
        function _av_bsf_receive_packet(...e) {
            return wasmImports.av_bsf_receive_packet(...e)
        }
        function _av_bsf_send_packet(...e) {
            return wasmImports.av_bsf_send_packet(...e)
        }
        function _av_buffer_create(...e) {
            return wasmImports.av_buffer_create(...e)
        }
        function _av_buffer_default_free(...e) {
            return wasmImports.av_buffer_default_free(...e)
        }
        function _av_buffer_unref(...e) {
            return wasmImports.av_buffer_unref(...e)
        }
        function _av_buffersink_get_frame(...e) {
            return wasmImports.av_buffersink_get_frame(...e)
        }
        function _av_buffersink_get_frame_flags(...e) {
            return wasmImports.av_buffersink_get_frame_flags(...e)
        }
        function _av_buffersrc_add_frame_flags(...e) {
            return wasmImports.av_buffersrc_add_frame_flags(...e)
        }
        function _av_calloc(...e) {
            return wasmImports.av_calloc(...e)
        }
        function _av_codec_is_decoder(...e) {
            return wasmImports.av_codec_is_decoder(...e)
        }
        function _av_codec_is_encoder(...e) {
            return wasmImports.av_codec_is_encoder(...e)
        }
        function _av_copy_packet(...e) {
            return wasmImports.av_copy_packet(...e)
        }
        function _av_cpu_count(...e) {
            return wasmImports.av_cpu_count(...e)
        }
        function _av_default_item_name(...e) {
            return wasmImports.av_default_item_name(...e)
        }
        function _av_dict_copy(...e) {
            return wasmImports.av_dict_copy(...e)
        }
        function _av_dict_free(...e) {
            return wasmImports.av_dict_free(...e)
        }
        function _av_dict_get(...e) {
            return wasmImports.av_dict_get(...e)
        }
        function _av_dict_set(...e) {
            return wasmImports.av_dict_set(...e)
        }
        function _av_dict_set_int(...e) {
            return wasmImports.av_dict_set_int(...e)
        }
        function _av_display_rotation_get(...e) {
            return wasmImports.av_display_rotation_get(...e)
        }
        function _av_dump_format(...e) {
            return wasmImports.av_dump_format(...e)
        }
        function _av_fifo_alloc(...e) {
            return wasmImports.av_fifo_alloc(...e)
        }
        function _av_fifo_free(...e) {
            return wasmImports.av_fifo_free(...e)
        }
        function _av_fifo_generic_read(...e) {
            return wasmImports.av_fifo_generic_read(...e)
        }
        function _av_fifo_reset(...e) {
            return wasmImports.av_fifo_reset(...e)
        }
        function _av_fifo_size(...e) {
            return wasmImports.av_fifo_size(...e)
        }
        function _av_find_best_stream(...e) {
            return wasmImports.av_find_best_stream(...e)
        }
        function _av_format_inject_global_side_data(...e) {
            return wasmImports.av_format_inject_global_side_data(...e)
        }
        function _av_frame_alloc(...e) {
            return wasmImports.av_frame_alloc(...e)
        }
        function _av_frame_copy_props(...e) {
            return wasmImports.av_frame_copy_props(...e)
        }
        function _av_frame_free(...e) {
            return wasmImports.av_frame_free(...e)
        }
        function _av_frame_get_best_effort_timestamp(...e) {
            return wasmImports.av_frame_get_best_effort_timestamp(...e)
        }
        function _av_frame_get_buffer(...e) {
            return wasmImports.av_frame_get_buffer(...e)
        }
        function _av_frame_make_writable(...e) {
            return wasmImports.av_frame_make_writable(...e)
        }
        function _av_frame_move_ref(...e) {
            return wasmImports.av_frame_move_ref(...e)
        }
        function _av_frame_ref(...e) {
            return wasmImports.av_frame_ref(...e)
        }
        function _av_frame_set_best_effort_timestamp(...e) {
            return wasmImports.av_frame_set_best_effort_timestamp(...e)
        }
        function _av_frame_unref(...e) {
            return wasmImports.av_frame_unref(...e)
        }
        function _av_free(...e) {
            return wasmImports.av_free(...e)
        }
        function _av_freep(...e) {
            return wasmImports.av_freep(...e)
        }
        function _av_get_bytes_per_sample(...e) {
            return wasmImports.av_get_bytes_per_sample(...e)
        }
        function _av_get_channel_layout_nb_channels(...e) {
            return wasmImports.av_get_channel_layout_nb_channels(...e)
        }
        function _av_get_default_channel_layout(...e) {
            return wasmImports.av_get_default_channel_layout(...e)
        }
        function _av_get_pix_fmt(...e) {
            return wasmImports.av_get_pix_fmt(...e)
        }
        function _av_get_pix_fmt_name(...e) {
            return wasmImports.av_get_pix_fmt_name(...e)
        }
        function _av_get_sample_fmt(...e) {
            return wasmImports.av_get_sample_fmt(...e)
        }
        function _av_get_sample_fmt_name(...e) {
            return wasmImports.av_get_sample_fmt_name(...e)
        }
        function _av_get_time_base_q(...e) {
            return wasmImports.av_get_time_base_q(...e)
        }
        function _av_guess_format(...e) {
            return wasmImports.av_guess_format(...e)
        }
        function _av_guess_sample_aspect_ratio(...e) {
            return wasmImports.av_guess_sample_aspect_ratio(...e)
        }
        function _av_index_search_timestamp(...e) {
            return wasmImports.av_index_search_timestamp(...e)
        }
        function _av_init_packet(...e) {
            return wasmImports.av_init_packet(...e)
        }
        function _av_int_list_length_for_size(...e) {
            return wasmImports.av_int_list_length_for_size(...e)
        }
        function _av_interleaved_write_frame(...e) {
            return wasmImports.av_interleaved_write_frame(...e)
        }
        function _av_log(...e) {
            return wasmImports.av_log(...e)
        }
        function _av_log_default_callback(...e) {
            return wasmImports.av_log_default_callback(...e)
        }
        function _av_log_format_line(...e) {
            return wasmImports.av_log_format_line(...e)
        }
        function _av_log_get_level(...e) {
            return wasmImports.av_log_get_level(...e)
        }
        function _av_log_set_callback(...e) {
            return wasmImports.av_log_set_callback(...e)
        }
        function _av_log_set_level(...e) {
            return wasmImports.av_log_set_level(...e)
        }
        function _av_malloc(...e) {
            return wasmImports.av_malloc(...e)
        }
        function _av_mallocz(...e) {
            return wasmImports.av_mallocz(...e)
        }
        function _av_md5_alloc(...e) {
            return wasmImports.av_md5_alloc(...e)
        }
        function _av_md5_final(...e) {
            return wasmImports.av_md5_final(...e)
        }
        function _av_md5_init(...e) {
            return wasmImports.av_md5_init(...e)
        }
        function _av_md5_update(...e) {
            return wasmImports.av_md5_update(...e)
        }
        function _av_opt_get(...e) {
            return wasmImports.av_opt_get(...e)
        }
        function _av_opt_set(...e) {
            return wasmImports.av_opt_set(...e)
        }
        function _av_opt_set_bin(...e) {
            return wasmImports.av_opt_set_bin(...e)
        }
        function _av_opt_set_channel_layout(...e) {
            return wasmImports.av_opt_set_channel_layout(...e)
        }
        function _av_opt_set_int(...e) {
            return wasmImports.av_opt_set_int(...e)
        }
        function _av_opt_set_sample_fmt(...e) {
            return wasmImports.av_opt_set_sample_fmt(...e)
        }
        function _av_packet_add_side_data(...e) {
            return wasmImports.av_packet_add_side_data(...e)
        }
        function _av_packet_alloc(...e) {
            return wasmImports.av_packet_alloc(...e)
        }
        function _av_packet_clone(...e) {
            return wasmImports.av_packet_clone(...e)
        }
        function _av_packet_free(...e) {
            return wasmImports.av_packet_free(...e)
        }
        function _av_packet_get_side_data(...e) {
            return wasmImports.av_packet_get_side_data(...e)
        }
        function _av_packet_move_ref(...e) {
            return wasmImports.av_packet_move_ref(...e)
        }
        function _av_packet_new_side_data(...e) {
            return wasmImports.av_packet_new_side_data(...e)
        }
        function _av_packet_ref(...e) {
            return wasmImports.av_packet_ref(...e)
        }
        function _av_packet_unref(...e) {
            return wasmImports.av_packet_unref(...e)
        }
        function _av_pix_fmt_desc_get(...e) {
            return wasmImports.av_pix_fmt_desc_get(...e)
        }
        function _av_read_frame(...e) {
            return wasmImports.av_read_frame(...e)
        }
        function _av_reduce(...e) {
            return wasmImports.av_reduce(...e)
        }
        function _av_register_all(...e) {
            return wasmImports.av_register_all(...e)
        }
        function _av_rescale(...e) {
            return wasmImports.av_rescale(...e)
        }
        function _av_rescale_q(...e) {
            return wasmImports.av_rescale_q(...e)
        }
        function _av_rescale_q_rnd(...e) {
            return wasmImports.av_rescale_q_rnd(...e)
        }
        function _av_rescale_rnd(...e) {
            return wasmImports.av_rescale_rnd(...e)
        }
        function _av_sample_fmt_is_planar(...e) {
            return wasmImports.av_sample_fmt_is_planar(...e)
        }
        function _av_samples_alloc(...e) {
            return wasmImports.av_samples_alloc(...e)
        }
        function _av_samples_alloc_array_and_samples(...e) {
            return wasmImports.av_samples_alloc_array_and_samples(...e)
        }
        function _av_samples_copy(...e) {
            return wasmImports.av_samples_copy(...e)
        }
        function _av_samples_get_buffer_size(...e) {
            return wasmImports.av_samples_get_buffer_size(...e)
        }
        function _av_seek_frame(...e) {
            return wasmImports.av_seek_frame(...e)
        }
        function _av_strdup(...e) {
            return wasmImports.av_strdup(...e)
        }
        function _av_stream_get_side_data(...e) {
            return wasmImports.av_stream_get_side_data(...e)
        }
        function _av_strerror(...e) {
            return wasmImports.av_strerror(...e)
        }
        function _av_strtod(...e) {
            return wasmImports.av_strtod(...e)
        }
        function _av_timecode_init_from_string(...e) {
            return wasmImports.av_timecode_init_from_string(...e)
        }
        function _av_usleep(...e) {
            return wasmImports.av_usleep(...e)
        }
        function _av_write_frame(...e) {
            return wasmImports.av_write_frame(...e)
        }
        function _av_write_trailer(...e) {
            return wasmImports.av_write_trailer(...e)
        }
        function _avcodec_alloc_context3(...e) {
            return wasmImports.avcodec_alloc_context3(...e)
        }
        function _avcodec_close(...e) {
            return wasmImports.avcodec_close(...e)
        }
        function _avcodec_descriptor_get_by_name(...e) {
            return wasmImports.avcodec_descriptor_get_by_name(...e)
        }
        function _avcodec_fill_audio_frame(...e) {
            return wasmImports.avcodec_fill_audio_frame(...e)
        }
        function _avcodec_find_decoder(...e) {
            return wasmImports.avcodec_find_decoder(...e)
        }
        function _avcodec_find_decoder_by_name(...e) {
            return wasmImports.avcodec_find_decoder_by_name(...e)
        }
        function _avcodec_find_encoder(...e) {
            return wasmImports.avcodec_find_encoder(...e)
        }
        function _avcodec_find_encoder_by_name(...e) {
            return wasmImports.avcodec_find_encoder_by_name(...e)
        }
        function _avcodec_flush_buffers(...e) {
            return wasmImports.avcodec_flush_buffers(...e)
        }
        function _avcodec_free_context(...e) {
            return wasmImports.avcodec_free_context(...e)
        }
        function _avcodec_get_name(...e) {
            return wasmImports.avcodec_get_name(...e)
        }
        function _avcodec_is_open(...e) {
            return wasmImports.avcodec_is_open(...e)
        }
        function _avcodec_open2(...e) {
            return wasmImports.avcodec_open2(...e)
        }
        function _avcodec_parameters_alloc(...e) {
            return wasmImports.avcodec_parameters_alloc(...e)
        }
        function _avcodec_parameters_copy(...e) {
            return wasmImports.avcodec_parameters_copy(...e)
        }
        function _avcodec_parameters_free(...e) {
            return wasmImports.avcodec_parameters_free(...e)
        }
        function _avcodec_parameters_from_context(...e) {
            return wasmImports.avcodec_parameters_from_context(...e)
        }
        function _avcodec_parameters_to_context(...e) {
            return wasmImports.avcodec_parameters_to_context(...e)
        }
        function _avcodec_receive_frame(...e) {
            return wasmImports.avcodec_receive_frame(...e)
        }
        function _avcodec_receive_packet(...e) {
            return wasmImports.avcodec_receive_packet(...e)
        }
        function _avcodec_register(...e) {
            return wasmImports.avcodec_register(...e)
        }
        function _avcodec_register_all(...e) {
            return wasmImports.avcodec_register_all(...e)
        }
        function _avcodec_send_frame(...e) {
            return wasmImports.avcodec_send_frame(...e)
        }
        function _avcodec_send_packet(...e) {
            return wasmImports.avcodec_send_packet(...e)
        }
        function _avfilter_get_by_name(...e) {
            return wasmImports.avfilter_get_by_name(...e)
        }
        function _avfilter_graph_alloc(...e) {
            return wasmImports.avfilter_graph_alloc(...e)
        }
        function _avfilter_graph_alloc_filter(...e) {
            return wasmImports.avfilter_graph_alloc_filter(...e)
        }
        function _avfilter_graph_config(...e) {
            return wasmImports.avfilter_graph_config(...e)
        }
        function _avfilter_graph_create_filter(...e) {
            return wasmImports.avfilter_graph_create_filter(...e)
        }
        function _avfilter_graph_free(...e) {
            return wasmImports.avfilter_graph_free(...e)
        }
        function _avfilter_graph_parse_ptr(...e) {
            return wasmImports.avfilter_graph_parse_ptr(...e)
        }
        function _avfilter_init_str(...e) {
            return wasmImports.avfilter_init_str(...e)
        }
        function _avfilter_inout_alloc(...e) {
            return wasmImports.avfilter_inout_alloc(...e)
        }
        function _avfilter_inout_free(...e) {
            return wasmImports.avfilter_inout_free(...e)
        }
        function _avfilter_link(...e) {
            return wasmImports.avfilter_link(...e)
        }
        function _avfilter_register_all(...e) {
            return wasmImports.avfilter_register_all(...e)
        }
        function _avformat_alloc_context(...e) {
            return wasmImports.avformat_alloc_context(...e)
        }
        function _avformat_alloc_output_context2(...e) {
            return wasmImports.avformat_alloc_output_context2(...e)
        }
        function _avformat_close_input(...e) {
            return wasmImports.avformat_close_input(...e)
        }
        function _avformat_find_stream_info(...e) {
            return wasmImports.avformat_find_stream_info(...e)
        }
        function _avformat_flush(...e) {
            return wasmImports.avformat_flush(...e)
        }
        function _avformat_free_context(...e) {
            return wasmImports.avformat_free_context(...e)
        }
        function _avformat_network_init(...e) {
            return wasmImports.avformat_network_init(...e)
        }
        function _avformat_new_stream(...e) {
            return wasmImports.avformat_new_stream(...e)
        }
        function _avformat_open_input(...e) {
            return wasmImports.avformat_open_input(...e)
        }
        function _avformat_seek_file(...e) {
            return wasmImports.avformat_seek_file(...e)
        }
        function _avformat_write_header(...e) {
            return wasmImports.avformat_write_header(...e)
        }
        function _avio_alloc_context(...e) {
            return wasmImports.avio_alloc_context(...e)
        }
        function _avio_close(...e) {
            return wasmImports.avio_close(...e)
        }
        function _avio_closep(...e) {
            return wasmImports.avio_closep(...e)
        }
        function _avio_feof(...e) {
            return wasmImports.avio_feof(...e)
        }
        function _avio_open(...e) {
            return wasmImports.avio_open(...e)
        }
        function _avio_rb32(...e) {
            return wasmImports.avio_rb32(...e)
        }
        function _avio_rb64(...e) {
            return wasmImports.avio_rb64(...e)
        }
        function _avio_rl32(...e) {
            return wasmImports.avio_rl32(...e)
        }
        function _avio_seek(...e) {
            return wasmImports.avio_seek(...e)
        }
        function _avio_size(...e) {
            return wasmImports.avio_size(...e)
        }
        function _avio_skip(...e) {
            return wasmImports.avio_skip(...e)
        }
        function _avpicture_fill(...e) {
            return wasmImports.avpicture_fill(...e)
        }
        _abort.sig = "v",
        _av_add_index_entry.stub = !0,
        _av_audio_fifo_alloc.stub = !0,
        _av_audio_fifo_drain.stub = !0,
        _av_audio_fifo_free.stub = !0,
        _av_audio_fifo_peek_at.stub = !0,
        _av_audio_fifo_read.stub = !0,
        _av_audio_fifo_reset.stub = !0,
        _av_audio_fifo_size.stub = !0,
        _av_audio_fifo_space.stub = !0,
        _av_audio_fifo_write.stub = !0,
        _av_bsf_alloc.stub = !0,
        _av_bsf_free.stub = !0,
        _av_bsf_get_by_name.stub = !0,
        _av_bsf_init.stub = !0,
        _av_bsf_receive_packet.stub = !0,
        _av_bsf_send_packet.stub = !0,
        _av_buffer_create.stub = !0,
        _av_buffer_default_free.stub = !0,
        _av_buffer_unref.stub = !0,
        _av_buffersink_get_frame.stub = !0,
        _av_buffersink_get_frame_flags.stub = !0,
        _av_buffersrc_add_frame_flags.stub = !0,
        _av_calloc.stub = !0,
        _av_codec_is_decoder.stub = !0,
        _av_codec_is_encoder.stub = !0,
        _av_copy_packet.stub = !0,
        _av_cpu_count.stub = !0,
        _av_default_item_name.stub = !0,
        _av_dict_copy.stub = !0,
        _av_dict_free.stub = !0,
        _av_dict_get.stub = !0,
        _av_dict_set.stub = !0,
        _av_dict_set_int.stub = !0,
        _av_display_rotation_get.stub = !0,
        _av_dump_format.stub = !0,
        _av_fifo_alloc.stub = !0,
        _av_fifo_free.stub = !0,
        _av_fifo_generic_read.stub = !0,
        _av_fifo_reset.stub = !0,
        _av_fifo_size.stub = !0,
        _av_find_best_stream.stub = !0,
        _av_format_inject_global_side_data.stub = !0,
        _av_frame_alloc.stub = !0,
        _av_frame_copy_props.stub = !0,
        _av_frame_free.stub = !0,
        _av_frame_get_best_effort_timestamp.stub = !0,
        _av_frame_get_buffer.stub = !0,
        _av_frame_make_writable.stub = !0,
        _av_frame_move_ref.stub = !0,
        _av_frame_ref.stub = !0,
        _av_frame_set_best_effort_timestamp.stub = !0,
        _av_frame_unref.stub = !0,
        _av_free.stub = !0,
        _av_freep.stub = !0,
        _av_get_bytes_per_sample.stub = !0,
        _av_get_channel_layout_nb_channels.stub = !0,
        _av_get_default_channel_layout.stub = !0,
        _av_get_pix_fmt.stub = !0,
        _av_get_pix_fmt_name.stub = !0,
        _av_get_sample_fmt.stub = !0,
        _av_get_sample_fmt_name.stub = !0,
        _av_get_time_base_q.stub = !0,
        _av_guess_format.stub = !0,
        _av_guess_sample_aspect_ratio.stub = !0,
        _av_index_search_timestamp.stub = !0,
        _av_init_packet.stub = !0,
        _av_int_list_length_for_size.stub = !0,
        _av_interleaved_write_frame.stub = !0,
        _av_log.stub = !0,
        _av_log_default_callback.stub = !0,
        _av_log_format_line.stub = !0,
        _av_log_get_level.stub = !0,
        _av_log_set_callback.stub = !0,
        _av_log_set_level.stub = !0,
        _av_malloc.stub = !0,
        _av_mallocz.stub = !0,
        _av_md5_alloc.stub = !0,
        _av_md5_final.stub = !0,
        _av_md5_init.stub = !0,
        _av_md5_update.stub = !0,
        _av_opt_get.stub = !0,
        _av_opt_set.stub = !0,
        _av_opt_set_bin.stub = !0,
        _av_opt_set_channel_layout.stub = !0,
        _av_opt_set_int.stub = !0,
        _av_opt_set_sample_fmt.stub = !0,
        _av_packet_add_side_data.stub = !0,
        _av_packet_alloc.stub = !0,
        _av_packet_clone.stub = !0,
        _av_packet_free.stub = !0,
        _av_packet_get_side_data.stub = !0,
        _av_packet_move_ref.stub = !0,
        _av_packet_new_side_data.stub = !0,
        _av_packet_ref.stub = !0,
        _av_packet_unref.stub = !0,
        _av_pix_fmt_desc_get.stub = !0,
        _av_read_frame.stub = !0,
        _av_reduce.stub = !0,
        _av_register_all.stub = !0,
        _av_rescale.stub = !0,
        _av_rescale_q.stub = !0,
        _av_rescale_q_rnd.stub = !0,
        _av_rescale_rnd.stub = !0,
        _av_sample_fmt_is_planar.stub = !0,
        _av_samples_alloc.stub = !0,
        _av_samples_alloc_array_and_samples.stub = !0,
        _av_samples_copy.stub = !0,
        _av_samples_get_buffer_size.stub = !0,
        _av_seek_frame.stub = !0,
        _av_strdup.stub = !0,
        _av_stream_get_side_data.stub = !0,
        _av_strerror.stub = !0,
        _av_strtod.stub = !0,
        _av_timecode_init_from_string.stub = !0,
        _av_usleep.stub = !0,
        _av_write_frame.stub = !0,
        _av_write_trailer.stub = !0,
        _avcodec_alloc_context3.stub = !0,
        _avcodec_close.stub = !0,
        _avcodec_descriptor_get_by_name.stub = !0,
        _avcodec_fill_audio_frame.stub = !0,
        _avcodec_find_decoder.stub = !0,
        _avcodec_find_decoder_by_name.stub = !0,
        _avcodec_find_encoder.stub = !0,
        _avcodec_find_encoder_by_name.stub = !0,
        _avcodec_flush_buffers.stub = !0,
        _avcodec_free_context.stub = !0,
        _avcodec_get_name.stub = !0,
        _avcodec_is_open.stub = !0,
        _avcodec_open2.stub = !0,
        _avcodec_parameters_alloc.stub = !0,
        _avcodec_parameters_copy.stub = !0,
        _avcodec_parameters_free.stub = !0,
        _avcodec_parameters_from_context.stub = !0,
        _avcodec_parameters_to_context.stub = !0,
        _avcodec_receive_frame.stub = !0,
        _avcodec_receive_packet.stub = !0,
        _avcodec_register.stub = !0,
        _avcodec_register_all.stub = !0,
        _avcodec_send_frame.stub = !0,
        _avcodec_send_packet.stub = !0,
        _avfilter_get_by_name.stub = !0,
        _avfilter_graph_alloc.stub = !0,
        _avfilter_graph_alloc_filter.stub = !0,
        _avfilter_graph_config.stub = !0,
        _avfilter_graph_create_filter.stub = !0,
        _avfilter_graph_free.stub = !0,
        _avfilter_graph_parse_ptr.stub = !0,
        _avfilter_init_str.stub = !0,
        _avfilter_inout_alloc.stub = !0,
        _avfilter_inout_free.stub = !0,
        _avfilter_link.stub = !0,
        _avfilter_register_all.stub = !0,
        _avformat_alloc_context.stub = !0,
        _avformat_alloc_output_context2.stub = !0,
        _avformat_close_input.stub = !0,
        _avformat_find_stream_info.stub = !0,
        _avformat_flush.stub = !0,
        _avformat_free_context.stub = !0,
        _avformat_network_init.stub = !0,
        _avformat_new_stream.stub = !0,
        _avformat_open_input.stub = !0,
        _avformat_seek_file.stub = !0,
        _avformat_write_header.stub = !0,
        _avio_alloc_context.stub = !0,
        _avio_close.stub = !0,
        _avio_closep.stub = !0,
        _avio_feof.stub = !0,
        _avio_open.stub = !0,
        _avio_rb32.stub = !0,
        _avio_rb64.stub = !0,
        _avio_rl32.stub = !0,
        _avio_seek.stub = !0,
        _avio_size.stub = !0,
        _avio_skip.stub = !0,
        _avpicture_fill.stub = !0;
        var _emscripten_set_main_loop_timing = (e, t) => {
            if (Browser.mainLoop.timingMode = e,
            Browser.mainLoop.timingValue = t,
            !Browser.mainLoop.func)
                return 1;
            if (!Browser.mainLoop.running && (runtimeKeepalivePush(),
            Browser.mainLoop.running = !0),
            0 == e)
                Browser.mainLoop.scheduler = function() {
                    var e = 0 | Math.max(0, Browser.mainLoop.tickStartTime + t - _emscripten_get_now());
                    setTimeout(Browser.mainLoop.runner, e)
                }
                ,
                Browser.mainLoop.method = "timeout";
            else if (1 == e)
                Browser.mainLoop.scheduler = function() {
                    Browser.requestAnimationFrame(Browser.mainLoop.runner)
                }
                ,
                Browser.mainLoop.method = "rAF";
            else if (2 == e) {
                if (void 0 === Browser.setImmediate) {
                    if ("undefined" == typeof setImmediate) {
                        var r = []
                          , i = "setimmediate";
                        addEventListener("message", e => {
                            (e.data === i || e.data.target === i) && (e.stopPropagation(),
                            r.shift()())
                        }
                        , !0),
                        Browser.setImmediate = function(e) {
                            r.push(e),
                            ENVIRONMENT_IS_WORKER ? (void 0 === Module.setImmediates && (Module.setImmediates = []),
                            Module.setImmediates.push(e),
                            postMessage({
                                target: i
                            })) : postMessage(i, "*")
                        }
                    } else
                        Browser.setImmediate = setImmediate
                }
                Browser.mainLoop.scheduler = function() {
                    Browser.setImmediate(Browser.mainLoop.runner)
                }
                ,
                Browser.mainLoop.method = "immediate"
            }
            return 0
        }
        ;
        _emscripten_set_main_loop_timing.sig = "iii",
        _emscripten_get_now = () => performance.timeOrigin + performance.now(),
        _emscripten_get_now.sig = "d";
        var setMainLoop = (e, t, r, i, n) => {
            assert(!Browser.mainLoop.func, "emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."),
            Browser.mainLoop.func = e,
            Browser.mainLoop.arg = i;
            var o = Browser.mainLoop.currentlyRunningMainloop;
            function a() {
                return !(o < Browser.mainLoop.currentlyRunningMainloop) || (runtimeKeepalivePop(),
                !1)
            }
            if (Browser.mainLoop.running = !1,
            Browser.mainLoop.runner = function() {
                if (ABORT)
                    return;
                if (Browser.mainLoop.queue.length > 0) {
                    Date.now();
                    var t = Browser.mainLoop.queue.shift();
                    if (t.func(t.arg),
                    Browser.mainLoop.remainingBlockers) {
                        var r = Browser.mainLoop.remainingBlockers
                          , i = r % 1 == 0 ? r - 1 : Math.floor(r);
                        t.counted ? Browser.mainLoop.remainingBlockers = i : (i += .5,
                        Browser.mainLoop.remainingBlockers = (8 * r + i) / 9)
                    }
                    if (Browser.mainLoop.updateStatus(),
                    !a())
                        return;
                    setTimeout(Browser.mainLoop.runner, 0);
                    return
                }
                if (!!a()) {
                    if (Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0,
                    1 == Browser.mainLoop.timingMode && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
                        Browser.mainLoop.scheduler();
                        return
                    }
                    0 == Browser.mainLoop.timingMode && (Browser.mainLoop.tickStartTime = _emscripten_get_now());
                    GL.newRenderingFrameStarted(),
                    void 0 !== GL && GL.currentContext && !GL.currentContextIsProxied && !GL.currentContext.attributes.explicitSwapControl && GL.currentContext.GLctx.commit && GL.currentContext.GLctx.commit(),
                    Browser.mainLoop.runIter(e),
                    a() && ("object" == typeof SDL && SDL.audio?.queueNewAudioData?.(),
                    Browser.mainLoop.scheduler())
                }
            }
            ,
            !n && (t && t > 0 ? _emscripten_set_main_loop_timing(0, 1e3 / t) : _emscripten_set_main_loop_timing(1, 1),
            Browser.mainLoop.scheduler()),
            r)
                throw "unwind"
        }
          , safeSetTimeout = (e, t) => (runtimeKeepalivePush(),
        setTimeout( () => {
            runtimeKeepalivePop(),
            callUserCallback(e)
        }
        , t))
          , warnOnce = e => {
            warnOnce.shown ||= {},
            !warnOnce.shown[e] && (warnOnce.shown[e] = 1,
            err(e))
        }
          , Browser = {
            mainLoop: {
                running: !1,
                scheduler: null,
                method: "",
                currentlyRunningMainloop: 0,
                func: null,
                arg: 0,
                timingMode: 0,
                timingValue: 0,
                currentFrameNumber: 0,
                queue: [],
                pause() {
                    Browser.mainLoop.scheduler = null,
                    Browser.mainLoop.currentlyRunningMainloop++
                },
                resume() {
                    Browser.mainLoop.currentlyRunningMainloop++;
                    var e = Browser.mainLoop.timingMode
                      , t = Browser.mainLoop.timingValue
                      , r = Browser.mainLoop.func;
                    Browser.mainLoop.func = null,
                    setMainLoop(r, 0, !1, Browser.mainLoop.arg, !0),
                    _emscripten_set_main_loop_timing(e, t),
                    Browser.mainLoop.scheduler()
                },
                updateStatus() {
                    if (Module.setStatus) {
                        var e = Module.statusMessage || "Please wait..."
                          , t = Browser.mainLoop.remainingBlockers
                          , r = Browser.mainLoop.expectedBlockers;
                        t ? t < r ? Module.setStatus("{message} ({expected - remaining}/{expected})") : Module.setStatus(e) : Module.setStatus("")
                    }
                },
                runIter(e) {
                    if (!ABORT) {
                        if (!Module.preMainLoop || !1 !== Module.preMainLoop())
                            callUserCallback(e),
                            Module.postMainLoop?.()
                    }
                }
            },
            isFullscreen: !1,
            pointerLock: !1,
            moduleContextCreatedCallbacks: [],
            workers: [],
            init() {
                if (!Browser.initted) {
                    Browser.initted = !0;
                    var e = {};
                    e.canHandle = function(e) {
                        return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(e)
                    }
                    ,
                    e.handle = function(e, t, r, i) {
                        var n = new Blob([e],{
                            type: Browser.getMimetype(t)
                        });
                        n.size !== e.length && (n = new Blob([new Uint8Array(e).buffer],{
                            type: Browser.getMimetype(t)
                        }));
                        var o = URL.createObjectURL(n)
                          , a = new Image;
                        a.onload = () => {
                            assert(a.complete, `Image ${t} could not be decoded`);
                            var i = document.createElement("canvas");
                            i.width = a.width,
                            i.height = a.height,
                            i.getContext("2d").drawImage(a, 0, 0),
                            preloadedImages[t] = i,
                            URL.revokeObjectURL(o),
                            r?.(e)
                        }
                        ,
                        a.onerror = e => {
                            err(`Image ${o} could not be decoded`),
                            i?.()
                        }
                        ,
                        a.src = o
                    }
                    ,
                    preloadPlugins.push(e);
                    var t = {};
                    t.canHandle = function(e) {
                        return !Module.noAudioDecoding && e.substr(-4)in {
                            ".ogg": 1,
                            ".wav": 1,
                            ".mp3": 1
                        }
                    }
                    ,
                    t.handle = function(e, t, r, i) {
                        var n = !1;
                        function o(i) {
                            !n && (n = !0,
                            preloadedAudios[t] = i,
                            r?.(e))
                        }
                        var a = new Blob([e],{
                            type: Browser.getMimetype(t)
                        })
                          , s = URL.createObjectURL(a)
                          , u = new Audio;
                        u.addEventListener("canplaythrough", () => o(u), !1),
                        u.onerror = function(r) {
                            !n && (err(`warning: browser could not fully decode audio ${t}, trying slower base64 approach`),
                            u.src = "data:audio/x-" + t.substr(-3) + ";base64," + i(e),
                            o(u));
                            function i(e) {
                                for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = "=", i = "", n = 0, o = 0, a = 0; a < e.length; a++)
                                    for (n = n << 8 | e[a],
                                    o += 8; o >= 6; ) {
                                        var s = n >> o - 6 & 63;
                                        o -= 6,
                                        i += t[s]
                                    }
                                return 2 == o ? (i += t[(3 & n) << 4],
                                i += r + r) : 4 == o && (i += t[(15 & n) << 2],
                                i += r),
                                i
                            }
                        }
                        ,
                        u.src = s,
                        safeSetTimeout( () => {
                            o(u)
                        }
                        , 1e4)
                    }
                    ,
                    preloadPlugins.push(t);
                    var r = Module.canvas;
                    r && (r.requestPointerLock = r.requestPointerLock || r.mozRequestPointerLock || r.webkitRequestPointerLock || r.msRequestPointerLock || ( () => {}
                    ),
                    r.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock || document.msExitPointerLock || ( () => {}
                    ),
                    r.exitPointerLock = r.exitPointerLock.bind(document),
                    document.addEventListener("pointerlockchange", i, !1),
                    document.addEventListener("mozpointerlockchange", i, !1),
                    document.addEventListener("webkitpointerlockchange", i, !1),
                    document.addEventListener("mspointerlockchange", i, !1),
                    Module.elementPointerLock && r.addEventListener("click", e => {
                        !Browser.pointerLock && Module.canvas.requestPointerLock && (Module.canvas.requestPointerLock(),
                        e.preventDefault())
                    }
                    , !1))
                }
                function i() {
                    Browser.pointerLock = document.pointerLockElement === Module.canvas || document.mozPointerLockElement === Module.canvas || document.webkitPointerLockElement === Module.canvas || document.msPointerLockElement === Module.canvas
                }
            },
            createContext(e, t, r, i) {
                if (t && Module.ctx && e == Module.canvas)
                    return Module.ctx;
                if (t) {
                    var n, o, a = {
                        antialias: !1,
                        alpha: !1,
                        majorVersion: "undefined" != typeof WebGL2RenderingContext ? 2 : 1
                    };
                    if (i)
                        for (var s in i)
                            a[s] = i[s];
                    void 0 !== GL && (o = GL.createContext(e, a)) && (n = GL.getContext(o).GLctx)
                } else
                    n = e.getContext("2d");
                return n ? (r && (!t && assert(void 0 === GLctx, "cannot set in module if GLctx is used, but we are a non-GL context that would replace it"),
                Module.ctx = n,
                t && GL.makeContextCurrent(o),
                Module.useWebGL = t,
                Browser.moduleContextCreatedCallbacks.forEach(e => e()),
                Browser.init()),
                n) : null
            },
            destroyContext(e, t, r) {},
            fullscreenHandlersInstalled: !1,
            lockPointer: void 0,
            resizeCanvas: void 0,
            requestFullscreen(e, t) {
                Browser.lockPointer = e,
                Browser.resizeCanvas = t,
                void 0 === Browser.lockPointer && (Browser.lockPointer = !0),
                void 0 === Browser.resizeCanvas && (Browser.resizeCanvas = !1);
                var r = Module.canvas;
                function i() {
                    Browser.isFullscreen = !1;
                    var e = r.parentNode;
                    (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === e ? (r.exitFullscreen = Browser.exitFullscreen,
                    Browser.lockPointer && r.requestPointerLock(),
                    Browser.isFullscreen = !0,
                    Browser.resizeCanvas ? Browser.setFullscreenCanvasSize() : Browser.updateCanvasDimensions(r)) : (e.parentNode.insertBefore(r, e),
                    e.parentNode.removeChild(e),
                    Browser.resizeCanvas ? Browser.setWindowedCanvasSize() : Browser.updateCanvasDimensions(r)),
                    Module.onFullScreen?.(Browser.isFullscreen),
                    Module.onFullscreen?.(Browser.isFullscreen)
                }
                !Browser.fullscreenHandlersInstalled && (Browser.fullscreenHandlersInstalled = !0,
                document.addEventListener("fullscreenchange", i, !1),
                document.addEventListener("mozfullscreenchange", i, !1),
                document.addEventListener("webkitfullscreenchange", i, !1),
                document.addEventListener("MSFullscreenChange", i, !1));
                var n = document.createElement("div");
                r.parentNode.insertBefore(n, r),
                n.appendChild(r),
                n.requestFullscreen = n.requestFullscreen || n.mozRequestFullScreen || n.msRequestFullscreen || (n.webkitRequestFullscreen ? () => n.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : null) || (n.webkitRequestFullScreen ? () => n.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) : null),
                n.requestFullscreen()
            },
            exitFullscreen: () => !!Browser.isFullscreen && ((document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen || document.webkitCancelFullScreen || ( () => {}
            )).apply(document, []),
            !0),
            nextRAF: 0,
            fakeRequestAnimationFrame(e) {
                var t = Date.now();
                if (0 === Browser.nextRAF)
                    Browser.nextRAF = t + 1e3 / 60;
                else
                    for (; t + 2 >= Browser.nextRAF; )
                        Browser.nextRAF += 1e3 / 60;
                setTimeout(e, Math.max(Browser.nextRAF - t, 0))
            },
            requestAnimationFrame(e) {
                if ("function" == typeof requestAnimationFrame) {
                    requestAnimationFrame(e);
                    return
                }
                (0,
                Browser.fakeRequestAnimationFrame)(e)
            },
            safeSetTimeout: (e, t) => safeSetTimeout(e, t),
            safeRequestAnimationFrame: e => (runtimeKeepalivePush(),
            Browser.requestAnimationFrame( () => {
                runtimeKeepalivePop(),
                callUserCallback(e)
            }
            )),
            getMimetype: e => ({
                jpg: "image/jpeg",
                jpeg: "image/jpeg",
                png: "image/png",
                bmp: "image/bmp",
                ogg: "audio/ogg",
                wav: "audio/wav",
                mp3: "audio/mpeg"
            })[e.substr(e.lastIndexOf(".") + 1)],
            getUserMedia(e) {
                window.getUserMedia ||= navigator.getUserMedia || navigator.mozGetUserMedia,
                window.getUserMedia(e)
            },
            getMovementX: e => e.movementX || e.mozMovementX || e.webkitMovementX || 0,
            getMovementY: e => e.movementY || e.mozMovementY || e.webkitMovementY || 0,
            getMouseWheelDelta(e) {
                var t = 0;
                switch (e.type) {
                case "DOMMouseScroll":
                    t = e.detail / 3;
                    break;
                case "mousewheel":
                    t = e.wheelDelta / 120;
                    break;
                case "wheel":
                    switch (t = e.deltaY,
                    e.deltaMode) {
                    case 0:
                        t /= 100;
                        break;
                    case 1:
                        t /= 3;
                        break;
                    case 2:
                        t *= 80;
                        break;
                    default:
                        throw "unrecognized mouse wheel delta mode: " + e.deltaMode
                    }
                    break;
                default:
                    throw "unrecognized mouse wheel event: " + e.type
                }
                return t
            },
            mouseX: 0,
            mouseY: 0,
            mouseMovementX: 0,
            mouseMovementY: 0,
            touches: {},
            lastTouches: {},
            calculateMouseCoords(e, t) {
                var r = Module.canvas.getBoundingClientRect()
                  , i = Module.canvas.width
                  , n = Module.canvas.height
                  , o = void 0 !== window.scrollX ? window.scrollX : window.pageXOffset
                  , a = void 0 !== window.scrollY ? window.scrollY : window.pageYOffset
                  , s = e - (o + r.left)
                  , u = t - (a + r.top);
                return s *= i / r.width,
                {
                    x: s,
                    y: u *= n / r.height
                }
            },
            setMouseCoords(e, t) {
                let {x: r, y: i} = Browser.calculateMouseCoords(e, t);
                Browser.mouseMovementX = r - Browser.mouseX,
                Browser.mouseMovementY = i - Browser.mouseY,
                Browser.mouseX = r,
                Browser.mouseY = i
            },
            calculateMouseEvent(e) {
                if (Browser.pointerLock)
                    "mousemove" != e.type && "mozMovementX"in e ? Browser.mouseMovementX = Browser.mouseMovementY = 0 : (Browser.mouseMovementX = Browser.getMovementX(e),
                    Browser.mouseMovementY = Browser.getMovementY(e)),
                    "undefined" != typeof SDL ? (Browser.mouseX = SDL.mouseX + Browser.mouseMovementX,
                    Browser.mouseY = SDL.mouseY + Browser.mouseMovementY) : (Browser.mouseX += Browser.mouseMovementX,
                    Browser.mouseY += Browser.mouseMovementY);
                else {
                    if ("touchstart" === e.type || "touchend" === e.type || "touchmove" === e.type) {
                        var t = e.touch;
                        if (void 0 === t)
                            return;
                        var r = Browser.calculateMouseCoords(t.pageX, t.pageY);
                        if ("touchstart" === e.type)
                            Browser.lastTouches[t.identifier] = r,
                            Browser.touches[t.identifier] = r;
                        else if ("touchend" === e.type || "touchmove" === e.type) {
                            var i = Browser.touches[t.identifier];
                            i ||= r,
                            Browser.lastTouches[t.identifier] = i,
                            Browser.touches[t.identifier] = r
                        }
                        return
                    }
                    Browser.setMouseCoords(e.pageX, e.pageY)
                }
            },
            resizeListeners: [],
            updateResizeListeners() {
                var e = Module.canvas;
                Browser.resizeListeners.forEach(t => t(e.width, e.height))
            },
            setCanvasSize(e, t, r) {
                var i = Module.canvas;
                Browser.updateCanvasDimensions(i, e, t),
                !r && Browser.updateResizeListeners()
            },
            windowedWidth: 0,
            windowedHeight: 0,
            setFullscreenCanvasSize() {
                if ("undefined" != typeof SDL) {
                    var e = GROWABLE_HEAP_U32()[SDL.screen >> 2];
                    e |= 8388608,
                    GROWABLE_HEAP_I32()[SDL.screen >> 2] = e
                }
                Browser.updateCanvasDimensions(Module.canvas),
                Browser.updateResizeListeners()
            },
            setWindowedCanvasSize() {
                if ("undefined" != typeof SDL) {
                    var e = GROWABLE_HEAP_U32()[SDL.screen >> 2];
                    e &= -8388609,
                    GROWABLE_HEAP_I32()[SDL.screen >> 2] = e
                }
                Browser.updateCanvasDimensions(Module.canvas),
                Browser.updateResizeListeners()
            },
            updateCanvasDimensions(e, t, r) {
                t && r ? (e.widthNative = t,
                e.heightNative = r) : (t = e.widthNative,
                r = e.heightNative);
                var i = t
                  , n = r;
                if (Module.forcedAspectRatio && Module.forcedAspectRatio > 0 && (i / n < Module.forcedAspectRatio ? i = Math.round(n * Module.forcedAspectRatio) : n = Math.round(i / Module.forcedAspectRatio)),
                (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === e.parentNode && "undefined" != typeof screen) {
                    var o = Math.min(screen.width / i, screen.height / n);
                    i = Math.round(i * o),
                    n = Math.round(n * o)
                }
                Browser.resizeCanvas ? (e.width != i && (e.width = i),
                e.height != n && (e.height = n),
                void 0 !== e.style && (e.style.removeProperty("width"),
                e.style.removeProperty("height"))) : (e.width != t && (e.width = t),
                e.height != r && (e.height = r),
                void 0 !== e.style && (i != t || n != r ? (e.style.setProperty("width", i + "px", "important"),
                e.style.setProperty("height", n + "px", "important")) : (e.style.removeProperty("width"),
                e.style.removeProperty("height"))))
            }
        }
          , EGL = {
            errorCode: 12288,
            defaultDisplayInitialized: !1,
            currentContext: 0,
            currentReadSurface: 0,
            currentDrawSurface: 0,
            contextAttributes: {
                alpha: !1,
                depth: !1,
                stencil: !1,
                antialias: !1
            },
            stringCache: {},
            setErrorCode(e) {
                EGL.errorCode = e
            },
            chooseConfig(e, t, r, i, n) {
                if (62e3 != e)
                    return EGL.setErrorCode(12296),
                    0;
                if (t)
                    for (; ; ) {
                        var o = GROWABLE_HEAP_I32()[t >> 2];
                        if (12321 == o) {
                            var a = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.alpha = a > 0
                        } else if (12325 == o) {
                            var s = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.depth = s > 0
                        } else if (12326 == o) {
                            var u = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.stencil = u > 0
                        } else if (12337 == o) {
                            var l = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.antialias = l > 0
                        } else if (12338 == o) {
                            var l = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.antialias = 1 == l
                        } else if (12544 == o) {
                            var c = GROWABLE_HEAP_I32()[t + 4 >> 2];
                            EGL.contextAttributes.lowLatency = 12547 != c
                        } else if (12344 == o)
                            break;
                        t += 8
                    }
                return r && i || n ? (n && (GROWABLE_HEAP_I32()[n >> 2] = 1),
                r && i > 0 && (GROWABLE_HEAP_U32()[r >> 2] = 62002),
                EGL.setErrorCode(12288),
                1) : (EGL.setErrorCode(12300),
                0)
            }
        };
        function _eglChooseConfig(e, t, r, i, n) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(4, 0, 1, e, t, r, i, n) : EGL.chooseConfig(e, t, r, i, n)
        }
        function _eglCreateContext(e, t, r, i) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(5, 0, 1, e, t, r, i);
            if (62e3 != e)
                return EGL.setErrorCode(12296),
                0;
            for (var n = 1; ; ) {
                var o = GROWABLE_HEAP_I32()[i >> 2];
                if (12440 == o)
                    n = GROWABLE_HEAP_I32()[i + 4 >> 2];
                else if (12344 != o)
                    return EGL.setErrorCode(12292),
                    0;
                else
                    break;
                i += 8
            }
            return n < 2 || n > 3 ? (EGL.setErrorCode(12293),
            0) : (EGL.contextAttributes.majorVersion = n - 1,
            EGL.contextAttributes.minorVersion = 0,
            EGL.context = GL.createContext(Module.canvas, EGL.contextAttributes),
            0 != EGL.context) ? (EGL.setErrorCode(12288),
            GL.makeContextCurrent(EGL.context),
            Module.useWebGL = !0,
            Browser.moduleContextCreatedCallbacks.forEach(function(e) {
                e()
            }),
            GL.makeContextCurrent(null),
            62004) : (EGL.setErrorCode(12297),
            0)
        }
        function _eglCreateWindowSurface(e, t, r, i) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(6, 0, 1, e, t, r, i) : 62e3 != e ? (EGL.setErrorCode(12296),
            0) : 62002 != t ? (EGL.setErrorCode(12293),
            0) : (EGL.setErrorCode(12288),
            62006)
        }
        function _eglDestroyContext(e, t) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(7, 0, 1, e, t) : 62e3 != e ? (EGL.setErrorCode(12296),
            0) : 62004 != t ? (EGL.setErrorCode(12294),
            0) : (GL.deleteContext(EGL.context),
            EGL.setErrorCode(12288),
            EGL.currentContext == t && (EGL.currentContext = 0),
            1)
        }
        function _eglDestroySurface(e, t) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(8, 0, 1, e, t) : 62e3 != e ? (EGL.setErrorCode(12296),
            0) : 62006 != t ? (EGL.setErrorCode(12301),
            1) : (EGL.currentReadSurface == t && (EGL.currentReadSurface = 0),
            EGL.currentDrawSurface == t && (EGL.currentDrawSurface = 0),
            EGL.setErrorCode(12288),
            1)
        }
        function _eglGetCurrentContext() {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(9, 0, 1) : EGL.currentContext
        }
        function _eglGetCurrentDisplay() {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(10, 0, 1) : EGL.currentContext ? 62e3 : 0
        }
        function _eglGetDisplay(e) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(11, 0, 1, e) : (EGL.setErrorCode(12288),
            0 != e && 1 != e) ? 0 : 62e3
        }
        function _eglGetError() {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(12, 0, 1) : EGL.errorCode
        }
        function _eglMakeCurrent(e, t, r, i) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(13, 0, 1, e, t, r, i) : 62e3 != e ? (EGL.setErrorCode(12296),
            0) : 0 != i && 62004 != i ? (EGL.setErrorCode(12294),
            0) : 0 != r && 62006 != r || 0 != t && 62006 != t ? (EGL.setErrorCode(12301),
            0) : (GL.makeContextCurrent(i ? EGL.context : null),
            EGL.currentContext = i,
            EGL.currentDrawSurface = t,
            EGL.currentReadSurface = r,
            EGL.setErrorCode(12288),
            1)
        }
        function _eglQueryContext(e, t, r, i) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(14, 0, 1, e, t, r, i);
            if (62e3 != e)
                return EGL.setErrorCode(12296),
                0;
            if (62004 != t)
                return EGL.setErrorCode(12294),
                0;
            if (!i)
                return EGL.setErrorCode(12300),
                0;
            switch (EGL.setErrorCode(12288),
            r) {
            case 12328:
                return GROWABLE_HEAP_I32()[i >> 2] = 62002,
                1;
            case 12439:
                return GROWABLE_HEAP_I32()[i >> 2] = 12448,
                1;
            case 12440:
                return GROWABLE_HEAP_I32()[i >> 2] = EGL.contextAttributes.majorVersion + 1,
                1;
            case 12422:
                return GROWABLE_HEAP_I32()[i >> 2] = 12420,
                1;
            default:
                return EGL.setErrorCode(12292),
                0
            }
        }
        _eglChooseConfig.sig = "ipppip",
        _eglCreateContext.sig = "ppppp",
        _eglCreateWindowSurface.sig = "pppip",
        _eglDestroyContext.sig = "ipp",
        _eglDestroySurface.sig = "ipp",
        _eglGetCurrentContext.sig = "p",
        _eglGetCurrentDisplay.sig = "p",
        _eglGetDisplay.sig = "pp",
        _eglGetError.sig = "i",
        _eglMakeCurrent.sig = "ipppp",
        _eglQueryContext.sig = "ippip";
        var readEmAsmArgsArray = []
          , readEmAsmArgs = (e, t) => {
            for (readEmAsmArgsArray.length = 0; r = GROWABLE_HEAP_U8()[e++]; ) {
                var r, i = 105 != r;
                i &= 112 != r,
                t += i && t % 8 ? 4 : 0,
                readEmAsmArgsArray.push(112 == r ? GROWABLE_HEAP_U32()[t >> 2] : 106 == r ? HEAP64[t >> 3] : 105 == r ? GROWABLE_HEAP_I32()[t >> 2] : GROWABLE_HEAP_F64()[t >> 3]),
                t += i ? 8 : 4
            }
            return readEmAsmArgsArray
        }
          , runEmAsmFunction = (e, t, r) => {
            var i = readEmAsmArgs(t, r);
            return ASM_CONSTS[e](...i)
        }
          , _emscripten_asm_const_int = (e, t, r) => runEmAsmFunction(e, t, r);
        _emscripten_asm_const_int.sig = "ippp";
        var runMainThreadEmAsm = (e, t, r, i) => {
            var n = readEmAsmArgs(t, r);
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(0, e, i, ...n) : ASM_CONSTS[e](...n)
        }
          , _emscripten_asm_const_int_sync_on_main_thread = (e, t, r) => runMainThreadEmAsm(e, t, r, 1);
        _emscripten_asm_const_int_sync_on_main_thread.sig = "ippp";
        var _emscripten_cancel_main_loop = () => {
            Browser.mainLoop.pause(),
            Browser.mainLoop.func = null
        }
        ;
        _emscripten_cancel_main_loop.sig = "v";
        var _emscripten_check_blocking_allowed = () => {}
        ;
        _emscripten_check_blocking_allowed.sig = "v";
        var _emscripten_date_now = () => Date.now();
        _emscripten_date_now.sig = "d";
        var _emscripten_err = e => err(UTF8ToString(e));
        _emscripten_err.sig = "vp";
        var _emscripten_exit_with_live_runtime = () => {
            throw runtimeKeepalivePush(),
            "unwind"
        }
        ;
        _emscripten_exit_with_live_runtime.sig = "v";
        var getCanvasSizeCallingThread = (e, t, r) => {
            var i = findCanvasEventTarget(e);
            if (!i)
                return -4;
            if (i.canvasSharedPtr) {
                var n = GROWABLE_HEAP_I32()[i.canvasSharedPtr >> 2]
                  , o = GROWABLE_HEAP_I32()[i.canvasSharedPtr + 4 >> 2];
                GROWABLE_HEAP_I32()[t >> 2] = n,
                GROWABLE_HEAP_I32()[r >> 2] = o
            } else if (i.offscreenCanvas)
                GROWABLE_HEAP_I32()[t >> 2] = i.offscreenCanvas.width,
                GROWABLE_HEAP_I32()[r >> 2] = i.offscreenCanvas.height;
            else {
                if (i.controlTransferredOffscreen)
                    return -4;
                GROWABLE_HEAP_I32()[t >> 2] = i.width,
                GROWABLE_HEAP_I32()[r >> 2] = i.height
            }
            return 0
        }
        ;
        function getCanvasSizeMainThread(e, t, r) {
            return ENVIRONMENT_IS_PTHREAD ? proxyToMainThread(15, 0, 1, e, t, r) : getCanvasSizeCallingThread(e, t, r)
        }
        var _emscripten_get_canvas_element_size = (e, t, r) => findCanvasEventTarget(e) ? getCanvasSizeCallingThread(e, t, r) : getCanvasSizeMainThread(e, t, r);
        _emscripten_get_canvas_element_size.sig = "ippp";
        var getHeapMax = () => 0x40000000
          , _emscripten_get_heap_max = () => getHeapMax();
        _emscripten_get_heap_max.sig = "p";
        var _glActiveTexture = e => GLctx.activeTexture(e);
        _glActiveTexture.sig = "vi";
        var _emscripten_glActiveTexture = _glActiveTexture;
        _emscripten_glActiveTexture.sig = "vi";
        var _glAttachShader = (e, t) => {
            GLctx.attachShader(GL.programs[e], GL.shaders[t])
        }
        ;
        _glAttachShader.sig = "vii";
        var _emscripten_glAttachShader = _glAttachShader;
        _emscripten_glAttachShader.sig = "vii";
        var _glBeginQuery = (e, t) => {
            GLctx.beginQuery(e, GL.queries[t])
        }
        ;
        _glBeginQuery.sig = "vii";
        var _emscripten_glBeginQuery = _glBeginQuery;
        _emscripten_glBeginQuery.sig = "vii";
        var _glBeginQueryEXT = (e, t) => {
            GLctx.disjointTimerQueryExt.beginQueryEXT(e, GL.queries[t])
        }
        ;
        _glBeginQueryEXT.sig = "vii";
        var _emscripten_glBeginQueryEXT = _glBeginQueryEXT
          , _glBeginTransformFeedback = e => GLctx.beginTransformFeedback(e);
        _glBeginTransformFeedback.sig = "vi";
        var _emscripten_glBeginTransformFeedback = _glBeginTransformFeedback;
        _emscripten_glBeginTransformFeedback.sig = "vi";
        var _glBindAttribLocation = (e, t, r) => {
            GLctx.bindAttribLocation(GL.programs[e], t, UTF8ToString(r))
        }
        ;
        _glBindAttribLocation.sig = "viip";
        var _emscripten_glBindAttribLocation = _glBindAttribLocation;
        _emscripten_glBindAttribLocation.sig = "viip";
        var _glBindBuffer = (e, t) => {
            34962 == e ? GLctx.currentArrayBufferBinding = t : 34963 == e && (GLctx.currentElementArrayBufferBinding = t),
            35051 == e ? GLctx.currentPixelPackBufferBinding = t : 35052 == e && (GLctx.currentPixelUnpackBufferBinding = t),
            GLctx.bindBuffer(e, GL.buffers[t])
        }
        ;
        _glBindBuffer.sig = "vii";
        var _emscripten_glBindBuffer = _glBindBuffer;
        _emscripten_glBindBuffer.sig = "vii";
        var _glBindBufferBase = (e, t, r) => {
            GLctx.bindBufferBase(e, t, GL.buffers[r])
        }
        ;
        _glBindBufferBase.sig = "viii";
        var _emscripten_glBindBufferBase = _glBindBufferBase;
        _emscripten_glBindBufferBase.sig = "viii";
        var _glBindBufferRange = (e, t, r, i, n) => {
            GLctx.bindBufferRange(e, t, GL.buffers[r], i, n)
        }
        ;
        _glBindBufferRange.sig = "viiipp";
        var _emscripten_glBindBufferRange = _glBindBufferRange;
        _emscripten_glBindBufferRange.sig = "viiipp";
        var _glBindFramebuffer = (e, t) => {
            GLctx.bindFramebuffer(e, GL.framebuffers[t])
        }
        ;
        _glBindFramebuffer.sig = "vii";
        var _emscripten_glBindFramebuffer = _glBindFramebuffer;
        _emscripten_glBindFramebuffer.sig = "vii";
        var _glBindRenderbuffer = (e, t) => {
            GLctx.bindRenderbuffer(e, GL.renderbuffers[t])
        }
        ;
        _glBindRenderbuffer.sig = "vii";
        var _emscripten_glBindRenderbuffer = _glBindRenderbuffer;
        _emscripten_glBindRenderbuffer.sig = "vii";
        var _glBindSampler = (e, t) => {
            GLctx.bindSampler(e, GL.samplers[t])
        }
        ;
        _glBindSampler.sig = "vii";
        var _emscripten_glBindSampler = _glBindSampler;
        _emscripten_glBindSampler.sig = "vii";
        var _glBindTexture = (e, t) => {
            GLctx.bindTexture(e, GL.textures[t])
        }
        ;
        _glBindTexture.sig = "vii";
        var _emscripten_glBindTexture = _glBindTexture;
        _emscripten_glBindTexture.sig = "vii";
        var _glBindTransformFeedback = (e, t) => {
            GLctx.bindTransformFeedback(e, GL.transformFeedbacks[t])
        }
        ;
        _glBindTransformFeedback.sig = "vii";
        var _emscripten_glBindTransformFeedback = _glBindTransformFeedback;
        _emscripten_glBindTransformFeedback.sig = "vii";
        var _glBindVertexArray = e => {
            GLctx.bindVertexArray(GL.vaos[e]);
            var t = GLctx.getParameter(34965);
            GLctx.currentElementArrayBufferBinding = t ? 0 | t.name : 0
        }
        ;
        _glBindVertexArray.sig = "vi";
        var _emscripten_glBindVertexArray = _glBindVertexArray;
        _emscripten_glBindVertexArray.sig = "vi";
        var _glBindVertexArrayOES = _glBindVertexArray;
        _glBindVertexArrayOES.sig = "vi";
        var _emscripten_glBindVertexArrayOES = _glBindVertexArrayOES;
        _emscripten_glBindVertexArrayOES.sig = "vi";
        var _glBlendColor = (e, t, r, i) => GLctx.blendColor(e, t, r, i);
        _glBlendColor.sig = "vffff";
        var _emscripten_glBlendColor = _glBlendColor;
        _emscripten_glBlendColor.sig = "vffff";
        var _glBlendEquation = e => GLctx.blendEquation(e);
        _glBlendEquation.sig = "vi";
        var _emscripten_glBlendEquation = _glBlendEquation;
        _emscripten_glBlendEquation.sig = "vi";
        var _glBlendEquationSeparate = (e, t) => GLctx.blendEquationSeparate(e, t);
        _glBlendEquationSeparate.sig = "vii";
        var _emscripten_glBlendEquationSeparate = _glBlendEquationSeparate;
        _emscripten_glBlendEquationSeparate.sig = "vii";
        var _glBlendFunc = (e, t) => GLctx.blendFunc(e, t);
        _glBlendFunc.sig = "vii";
        var _emscripten_glBlendFunc = _glBlendFunc;
        _emscripten_glBlendFunc.sig = "vii";
        var _glBlendFuncSeparate = (e, t, r, i) => GLctx.blendFuncSeparate(e, t, r, i);
        _glBlendFuncSeparate.sig = "viiii";
        var _emscripten_glBlendFuncSeparate = _glBlendFuncSeparate;
        _emscripten_glBlendFuncSeparate.sig = "viiii";
        var _glBlitFramebuffer = (e, t, r, i, n, o, a, s, u, l) => GLctx.blitFramebuffer(e, t, r, i, n, o, a, s, u, l);
        _glBlitFramebuffer.sig = "viiiiiiiiii";
        var _emscripten_glBlitFramebuffer = _glBlitFramebuffer;
        _emscripten_glBlitFramebuffer.sig = "viiiiiiiiii";
        var _glBufferData = (e, t, r, i) => {
            GL.currentContext.version >= 2 ? r && t ? GLctx.bufferData(e, GROWABLE_HEAP_U8(), i, r, t) : GLctx.bufferData(e, t, i) : GLctx.bufferData(e, r ? GROWABLE_HEAP_U8().subarray(r, r + t) : t, i)
        }
        ;
        _glBufferData.sig = "vippi";
        var _emscripten_glBufferData = _glBufferData;
        _emscripten_glBufferData.sig = "vippi";
        var _glBufferSubData = (e, t, r, i) => {
            if (GL.currentContext.version >= 2) {
                r && GLctx.bufferSubData(e, t, GROWABLE_HEAP_U8(), i, r);
                return
            }
            GLctx.bufferSubData(e, t, GROWABLE_HEAP_U8().subarray(i, i + r))
        }
        ;
        _glBufferSubData.sig = "vippp";
        var _emscripten_glBufferSubData = _glBufferSubData;
        _emscripten_glBufferSubData.sig = "vippp";
        var _glCheckFramebufferStatus = e => GLctx.checkFramebufferStatus(e);
        _glCheckFramebufferStatus.sig = "ii";
        var _emscripten_glCheckFramebufferStatus = _glCheckFramebufferStatus;
        _emscripten_glCheckFramebufferStatus.sig = "ii";
        var _glClear = e => GLctx.clear(e);
        _glClear.sig = "vi";
        var _emscripten_glClear = _glClear;
        _emscripten_glClear.sig = "vi";
        var _glClearBufferfi = (e, t, r, i) => GLctx.clearBufferfi(e, t, r, i);
        _glClearBufferfi.sig = "viifi";
        var _emscripten_glClearBufferfi = _glClearBufferfi;
        _emscripten_glClearBufferfi.sig = "viifi";
        var _glClearBufferfv = (e, t, r) => {
            GLctx.clearBufferfv(e, t, GROWABLE_HEAP_F32(), r >> 2)
        }
        ;
        _glClearBufferfv.sig = "viip";
        var _emscripten_glClearBufferfv = _glClearBufferfv;
        _emscripten_glClearBufferfv.sig = "viip";
        var _glClearBufferiv = (e, t, r) => {
            GLctx.clearBufferiv(e, t, GROWABLE_HEAP_I32(), r >> 2)
        }
        ;
        _glClearBufferiv.sig = "viip";
        var _emscripten_glClearBufferiv = _glClearBufferiv;
        _emscripten_glClearBufferiv.sig = "viip";
        var _glClearBufferuiv = (e, t, r) => {
            GLctx.clearBufferuiv(e, t, GROWABLE_HEAP_U32(), r >> 2)
        }
        ;
        _glClearBufferuiv.sig = "viip";
        var _emscripten_glClearBufferuiv = _glClearBufferuiv;
        _emscripten_glClearBufferuiv.sig = "viip";
        var _glClearColor = (e, t, r, i) => GLctx.clearColor(e, t, r, i);
        _glClearColor.sig = "vffff";
        var _emscripten_glClearColor = _glClearColor;
        _emscripten_glClearColor.sig = "vffff";
        var _glClearDepthf = e => GLctx.clearDepth(e);
        _glClearDepthf.sig = "vf";
        var _emscripten_glClearDepthf = _glClearDepthf;
        _emscripten_glClearDepthf.sig = "vf";
        var _glClearStencil = e => GLctx.clearStencil(e);
        _glClearStencil.sig = "vi";
        var _emscripten_glClearStencil = _glClearStencil;
        _emscripten_glClearStencil.sig = "vi";
        var _glClientWaitSync = (e, t, r) => (r = Number(r),
        GLctx.clientWaitSync(GL.syncs[e], t, r));
        _glClientWaitSync.sig = "ipij";
        var _emscripten_glClientWaitSync = _glClientWaitSync;
        _emscripten_glClientWaitSync.sig = "ipij";
        var _glColorMask = (e, t, r, i) => {
            GLctx.colorMask(!!e, !!t, !!r, !!i)
        }
        ;
        _glColorMask.sig = "viiii";
        var _emscripten_glColorMask = _glColorMask;
        _emscripten_glColorMask.sig = "viiii";
        var _glCompileShader = e => {
            GLctx.compileShader(GL.shaders[e])
        }
        ;
        _glCompileShader.sig = "vi";
        var _emscripten_glCompileShader = _glCompileShader;
        _emscripten_glCompileShader.sig = "vi";
        var _glCompressedTexImage2D = (e, t, r, i, n, o, a, s) => {
            if (GL.currentContext.version >= 2) {
                GLctx.currentPixelUnpackBufferBinding || !a ? GLctx.compressedTexImage2D(e, t, r, i, n, o, a, s) : GLctx.compressedTexImage2D(e, t, r, i, n, o, GROWABLE_HEAP_U8(), s, a);
                return
            }
            GLctx.compressedTexImage2D(e, t, r, i, n, o, s ? GROWABLE_HEAP_U8().subarray(s, s + a) : null)
        }
        ;
        _glCompressedTexImage2D.sig = "viiiiiiip";
        var _emscripten_glCompressedTexImage2D = _glCompressedTexImage2D;
        _emscripten_glCompressedTexImage2D.sig = "viiiiiiip";
        var _glCompressedTexImage3D = (e, t, r, i, n, o, a, s, u) => {
            GLctx.currentPixelUnpackBufferBinding ? GLctx.compressedTexImage3D(e, t, r, i, n, o, a, s, u) : GLctx.compressedTexImage3D(e, t, r, i, n, o, a, GROWABLE_HEAP_U8(), u, s)
        }
        ;
        _glCompressedTexImage3D.sig = "viiiiiiiip";
        var _emscripten_glCompressedTexImage3D = _glCompressedTexImage3D;
        _emscripten_glCompressedTexImage3D.sig = "viiiiiiiip";
        var _glCompressedTexSubImage2D = (e, t, r, i, n, o, a, s, u) => {
            if (GL.currentContext.version >= 2) {
                GLctx.currentPixelUnpackBufferBinding || !s ? GLctx.compressedTexSubImage2D(e, t, r, i, n, o, a, s, u) : GLctx.compressedTexSubImage2D(e, t, r, i, n, o, a, GROWABLE_HEAP_U8(), u, s);
                return
            }
            GLctx.compressedTexSubImage2D(e, t, r, i, n, o, a, u ? GROWABLE_HEAP_U8().subarray(u, u + s) : null)
        }
        ;
        _glCompressedTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glCompressedTexSubImage2D = _glCompressedTexSubImage2D;
        _emscripten_glCompressedTexSubImage2D.sig = "viiiiiiiip";
        var _glCompressedTexSubImage3D = (e, t, r, i, n, o, a, s, u, l, c) => {
            GLctx.currentPixelUnpackBufferBinding ? GLctx.compressedTexSubImage3D(e, t, r, i, n, o, a, s, u, l, c) : GLctx.compressedTexSubImage3D(e, t, r, i, n, o, a, s, u, GROWABLE_HEAP_U8(), c, l)
        }
        ;
        _glCompressedTexSubImage3D.sig = "viiiiiiiiiip";
        var _emscripten_glCompressedTexSubImage3D = _glCompressedTexSubImage3D;
        _emscripten_glCompressedTexSubImage3D.sig = "viiiiiiiiiip";
        var _glCopyBufferSubData = (e, t, r, i, n) => GLctx.copyBufferSubData(e, t, r, i, n);
        _glCopyBufferSubData.sig = "viippp";
        var _emscripten_glCopyBufferSubData = _glCopyBufferSubData;
        _emscripten_glCopyBufferSubData.sig = "viippp";
        var _glCopyTexImage2D = (e, t, r, i, n, o, a, s) => GLctx.copyTexImage2D(e, t, r, i, n, o, a, s);
        _glCopyTexImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexImage2D = _glCopyTexImage2D;
        _emscripten_glCopyTexImage2D.sig = "viiiiiiii";
        var _glCopyTexSubImage2D = (e, t, r, i, n, o, a, s) => GLctx.copyTexSubImage2D(e, t, r, i, n, o, a, s);
        _glCopyTexSubImage2D.sig = "viiiiiiii";
        var _emscripten_glCopyTexSubImage2D = _glCopyTexSubImage2D;
        _emscripten_glCopyTexSubImage2D.sig = "viiiiiiii";
        var _glCopyTexSubImage3D = (e, t, r, i, n, o, a, s, u) => GLctx.copyTexSubImage3D(e, t, r, i, n, o, a, s, u);
        _glCopyTexSubImage3D.sig = "viiiiiiiii";
        var _emscripten_glCopyTexSubImage3D = _glCopyTexSubImage3D;
        _emscripten_glCopyTexSubImage3D.sig = "viiiiiiiii";
        var _glCreateProgram = () => {
            var e = GL.getNewId(GL.programs)
              , t = GLctx.createProgram();
            return t.name = e,
            t.maxUniformLength = t.maxAttributeLength = t.maxUniformBlockNameLength = 0,
            t.uniformIdCounter = 1,
            GL.programs[e] = t,
            e
        }
        ;
        _glCreateProgram.sig = "i";
        var _emscripten_glCreateProgram = _glCreateProgram;
        _emscripten_glCreateProgram.sig = "i";
        var _glCreateShader = e => {
            var t = GL.getNewId(GL.shaders);
            return GL.shaders[t] = GLctx.createShader(e),
            t
        }
        ;
        _glCreateShader.sig = "ii";
        var _emscripten_glCreateShader = _glCreateShader;
        _emscripten_glCreateShader.sig = "ii";
        var _glCullFace = e => GLctx.cullFace(e);
        _glCullFace.sig = "vi";
        var _emscripten_glCullFace = _glCullFace;
        _emscripten_glCullFace.sig = "vi";
        var _glDeleteBuffers = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.buffers[i];
                n && (GLctx.deleteBuffer(n),
                n.name = 0,
                GL.buffers[i] = null,
                i == GLctx.currentArrayBufferBinding && (GLctx.currentArrayBufferBinding = 0),
                i == GLctx.currentElementArrayBufferBinding && (GLctx.currentElementArrayBufferBinding = 0),
                i == GLctx.currentPixelPackBufferBinding && (GLctx.currentPixelPackBufferBinding = 0),
                i == GLctx.currentPixelUnpackBufferBinding && (GLctx.currentPixelUnpackBufferBinding = 0))
            }
        }
        ;
        _glDeleteBuffers.sig = "vip";
        var _emscripten_glDeleteBuffers = _glDeleteBuffers;
        _emscripten_glDeleteBuffers.sig = "vip";
        var _glDeleteFramebuffers = (e, t) => {
            for (var r = 0; r < e; ++r) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.framebuffers[i];
                n && (GLctx.deleteFramebuffer(n),
                n.name = 0,
                GL.framebuffers[i] = null)
            }
        }
        ;
        _glDeleteFramebuffers.sig = "vip";
        var _emscripten_glDeleteFramebuffers = _glDeleteFramebuffers;
        _emscripten_glDeleteFramebuffers.sig = "vip";
        var _glDeleteProgram = e => {
            if (e) {
                var t = GL.programs[e];
                if (!t) {
                    GL.recordError(1281);
                    return
                }
                GLctx.deleteProgram(t),
                t.name = 0,
                GL.programs[e] = null
            }
        }
        ;
        _glDeleteProgram.sig = "vi";
        var _emscripten_glDeleteProgram = _glDeleteProgram;
        _emscripten_glDeleteProgram.sig = "vi";
        var _glDeleteQueries = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.queries[i];
                n && (GLctx.deleteQuery(n),
                GL.queries[i] = null)
            }
        }
        ;
        _glDeleteQueries.sig = "vip";
        var _emscripten_glDeleteQueries = _glDeleteQueries;
        _emscripten_glDeleteQueries.sig = "vip";
        var _glDeleteQueriesEXT = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.queries[i];
                n && (GLctx.disjointTimerQueryExt.deleteQueryEXT(n),
                GL.queries[i] = null)
            }
        }
        ;
        _glDeleteQueriesEXT.sig = "vip";
        var _emscripten_glDeleteQueriesEXT = _glDeleteQueriesEXT
          , _glDeleteRenderbuffers = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.renderbuffers[i];
                n && (GLctx.deleteRenderbuffer(n),
                n.name = 0,
                GL.renderbuffers[i] = null)
            }
        }
        ;
        _glDeleteRenderbuffers.sig = "vip";
        var _emscripten_glDeleteRenderbuffers = _glDeleteRenderbuffers;
        _emscripten_glDeleteRenderbuffers.sig = "vip";
        var _glDeleteSamplers = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.samplers[i];
                n && (GLctx.deleteSampler(n),
                n.name = 0,
                GL.samplers[i] = null)
            }
        }
        ;
        _glDeleteSamplers.sig = "vip";
        var _emscripten_glDeleteSamplers = _glDeleteSamplers;
        _emscripten_glDeleteSamplers.sig = "vip";
        var _glDeleteShader = e => {
            if (e) {
                var t = GL.shaders[e];
                if (!t) {
                    GL.recordError(1281);
                    return
                }
                GLctx.deleteShader(t),
                GL.shaders[e] = null
            }
        }
        ;
        _glDeleteShader.sig = "vi";
        var _emscripten_glDeleteShader = _glDeleteShader;
        _emscripten_glDeleteShader.sig = "vi";
        var _glDeleteSync = e => {
            if (e) {
                var t = GL.syncs[e];
                if (!t) {
                    GL.recordError(1281);
                    return
                }
                GLctx.deleteSync(t),
                t.name = 0,
                GL.syncs[e] = null
            }
        }
        ;
        _glDeleteSync.sig = "vp";
        var _emscripten_glDeleteSync = _glDeleteSync;
        _emscripten_glDeleteSync.sig = "vp";
        var _glDeleteTextures = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.textures[i];
                n && (GLctx.deleteTexture(n),
                n.name = 0,
                GL.textures[i] = null)
            }
        }
        ;
        _glDeleteTextures.sig = "vip";
        var _emscripten_glDeleteTextures = _glDeleteTextures;
        _emscripten_glDeleteTextures.sig = "vip";
        var _glDeleteTransformFeedbacks = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2]
                  , n = GL.transformFeedbacks[i];
                n && (GLctx.deleteTransformFeedback(n),
                n.name = 0,
                GL.transformFeedbacks[i] = null)
            }
        }
        ;
        _glDeleteTransformFeedbacks.sig = "vip";
        var _emscripten_glDeleteTransformFeedbacks = _glDeleteTransformFeedbacks;
        _emscripten_glDeleteTransformFeedbacks.sig = "vip";
        var _glDeleteVertexArrays = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GROWABLE_HEAP_I32()[t + 4 * r >> 2];
                GLctx.deleteVertexArray(GL.vaos[i]),
                GL.vaos[i] = null
            }
        }
        ;
        _glDeleteVertexArrays.sig = "vip";
        var _emscripten_glDeleteVertexArrays = _glDeleteVertexArrays;
        _emscripten_glDeleteVertexArrays.sig = "vip";
        var _glDeleteVertexArraysOES = _glDeleteVertexArrays;
        _glDeleteVertexArraysOES.sig = "vip";
        var _emscripten_glDeleteVertexArraysOES = _glDeleteVertexArraysOES;
        _emscripten_glDeleteVertexArraysOES.sig = "vip";
        var _glDepthFunc = e => GLctx.depthFunc(e);
        _glDepthFunc.sig = "vi";
        var _emscripten_glDepthFunc = _glDepthFunc;
        _emscripten_glDepthFunc.sig = "vi";
        var _glDepthMask = e => {
            GLctx.depthMask(!!e)
        }
        ;
        _glDepthMask.sig = "vi";
        var _emscripten_glDepthMask = _glDepthMask;
        _emscripten_glDepthMask.sig = "vi";
        var _glDepthRangef = (e, t) => GLctx.depthRange(e, t);
        _glDepthRangef.sig = "vff";
        var _emscripten_glDepthRangef = _glDepthRangef;
        _emscripten_glDepthRangef.sig = "vff";
        var _glDetachShader = (e, t) => {
            GLctx.detachShader(GL.programs[e], GL.shaders[t])
        }
        ;
        _glDetachShader.sig = "vii";
        var _emscripten_glDetachShader = _glDetachShader;
        _emscripten_glDetachShader.sig = "vii";
        var _glDisable = e => GLctx.disable(e);
        _glDisable.sig = "vi";
        var _emscripten_glDisable = _glDisable;
        _emscripten_glDisable.sig = "vi";
        var _glDisableVertexAttribArray = e => {
            GL.currentContext.clientBuffers[e].enabled = !1,
            GLctx.disableVertexAttribArray(e)
        }
        ;
        _glDisableVertexAttribArray.sig = "vi";
        var _emscripten_glDisableVertexAttribArray = _glDisableVertexAttribArray;
        _emscripten_glDisableVertexAttribArray.sig = "vi";
        var _glDrawArrays = (e, t, r) => {
            GL.preDrawHandleClientVertexAttribBindings(t + r),
            GLctx.drawArrays(e, t, r),
            GL.postDrawHandleClientVertexAttribBindings()
        }
        ;
        _glDrawArrays.sig = "viii";
        var _emscripten_glDrawArrays = _glDrawArrays;
        _emscripten_glDrawArrays.sig = "viii";
        var _glDrawArraysInstanced = (e, t, r, i) => {
            GLctx.drawArraysInstanced(e, t, r, i)
        }
        ;
        _glDrawArraysInstanced.sig = "viiii";
        var _emscripten_glDrawArraysInstanced = _glDrawArraysInstanced;
        _emscripten_glDrawArraysInstanced.sig = "viiii";
        var _glDrawArraysInstancedANGLE = _glDrawArraysInstanced
          , _emscripten_glDrawArraysInstancedANGLE = _glDrawArraysInstancedANGLE
          , _glDrawArraysInstancedARB = _glDrawArraysInstanced
          , _emscripten_glDrawArraysInstancedARB = _glDrawArraysInstancedARB
          , _glDrawArraysInstancedEXT = _glDrawArraysInstanced
          , _emscripten_glDrawArraysInstancedEXT = _glDrawArraysInstancedEXT
          , _glDrawArraysInstancedNV = _glDrawArraysInstanced
          , _emscripten_glDrawArraysInstancedNV = _glDrawArraysInstancedNV
          , tempFixedLengthArray = []
          , _glDrawBuffers = (e, t) => {
            for (var r = tempFixedLengthArray[e], i = 0; i < e; i++)
                r[i] = GROWABLE_HEAP_I32()[t + 4 * i >> 2];
            GLctx.drawBuffers(r)
        }
        ;
        _glDrawBuffers.sig = "vip";
        var _emscripten_glDrawBuffers = _glDrawBuffers;
        _emscripten_glDrawBuffers.sig = "vip";
        var _glDrawBuffersEXT = _glDrawBuffers
          , _emscripten_glDrawBuffersEXT = _glDrawBuffersEXT
          , _glDrawBuffersWEBGL = _glDrawBuffers
          , _emscripten_glDrawBuffersWEBGL = _glDrawBuffersWEBGL
          , _glDrawElements = (e, t, r, i) => {
            var n;
            if (!GLctx.currentElementArrayBufferBinding) {
                var o = GL.calcBufLength(1, r, 0, t);
                n = GL.getTempIndexBuffer(o),
                GLctx.bindBuffer(34963, n),
                GLctx.bufferSubData(34963, 0, GROWABLE_HEAP_U8().subarray(i, i + o)),
                i = 0
            }
            GL.preDrawHandleClientVertexAttribBindings(t),
            GLctx.drawElements(e, t, r, i),
            GL.postDrawHandleClientVertexAttribBindings(t),
            !GLctx.currentElementArrayBufferBinding && GLctx.bindBuffer(34963, null)
        }
        ;
        _glDrawElements.sig = "viiip";
        var _emscripten_glDrawElements = _glDrawElements;
        _emscripten_glDrawElements.sig = "viiip";
        var _glDrawElementsInstanced = (e, t, r, i, n) => {
            GLctx.drawElementsInstanced(e, t, r, i, n)
        }
        ;
        _glDrawElementsInstanced.sig = "viiipi";
        var _emscripten_glDrawElementsInstanced = _glDrawElementsInstanced;
        _emscripten_glDrawElementsInstanced.sig = "viiipi";
        var _glDrawElementsInstancedANGLE = _glDrawElementsInstanced
          , _emscripten_glDrawElementsInstancedANGLE = _glDrawElementsInstancedANGLE
          , _glDrawElementsInstancedARB = _glDrawElementsInstanced
          , _emscripten_glDrawElementsInstancedARB = _glDrawElementsInstancedARB
          , _glDrawElementsInstancedEXT = _glDrawElementsInstanced
          , _emscripten_glDrawElementsInstancedEXT = _glDrawElementsInstancedEXT
          , _glDrawElementsInstancedNV = _glDrawElementsInstanced
          , _emscripten_glDrawElementsInstancedNV = _glDrawElementsInstancedNV
          , _glDrawRangeElements = (e, t, r, i, n, o) => {
            _glDrawElements(e, i, n, o)
        }
        ;
        _glDrawRangeElements.sig = "viiiiip";
        var _emscripten_glDrawRangeElements = _glDrawRangeElements;
        _emscripten_glDrawRangeElements.sig = "viiiiip";
        var _glEnable = e => GLctx.enable(e);
        _glEnable.sig = "vi";
        var _emscripten_glEnable = _glEnable;
        _emscripten_glEnable.sig = "vi";
        var _glEnableVertexAttribArray = e => {
            GL.currentContext.clientBuffers[e].enabled = !0,
            GLctx.enableVertexAttribArray(e)
        }
        ;
        _glEnableVertexAttribArray.sig = "vi";
        var _emscripten_glEnableVertexAttribArray = _glEnableVertexAttribArray;
        _emscripten_glEnableVertexAttribArray.sig = "vi";
        var _glEndQuery = e => GLctx.endQuery(e);
        _glEndQuery.sig = "vi";
        var _emscripten_glEndQuery = _glEndQuery;
        _emscripten_glEndQuery.sig = "vi";
        var _glEndQueryEXT = e => {
            GLctx.disjointTimerQueryExt.endQueryEXT(e)
        }
        ;
        _glEndQueryEXT.sig = "vi";
        var _emscripten_glEndQueryEXT = _glEndQueryEXT
          , _glEndTransformFeedback = () => GLctx.endTransformFeedback();
        _glEndTransformFeedback.sig = "v";
        var _emscripten_glEndTransformFeedback = _glEndTransformFeedback;
        _emscripten_glEndTransformFeedback.sig = "v";
        var _glFenceSync = (e, t) => {
            var r = GLctx.fenceSync(e, t);
            if (r) {
                var i = GL.getNewId(GL.syncs);
                return r.name = i,
                GL.syncs[i] = r,
                i
            }
            return 0
        }
        ;
        _glFenceSync.sig = "pii";
        var _emscripten_glFenceSync = _glFenceSync;
        _emscripten_glFenceSync.sig = "pii";
        var _glFinish = () => GLctx.finish();
        _glFinish.sig = "v";
        var _emscripten_glFinish = _glFinish;
        _emscripten_glFinish.sig = "v";
        var _glFlush = () => GLctx.flush();
        _glFlush.sig = "v";
        var _emscripten_glFlush = _glFlush;
        _emscripten_glFlush.sig = "v";
        var emscriptenWebGLGetBufferBinding = e => {
            switch (e) {
            case 34962:
                e = 34964;
                break;
            case 34963:
                e = 34965;
                break;
            case 35051:
                e = 35053;
                break;
            case 35052:
                e = 35055;
                break;
            case 35982:
                e = 35983;
                break;
            case 36662:
                e = 36662;
                break;
            case 36663:
                e = 36663;
                break;
            case 35345:
                e = 35368
            }
            var t = GLctx.getParameter(e);
            return t ? 0 | t.name : 0
        }
          , emscriptenWebGLValidateMapBufferTarget = e => {
            switch (e) {
            case 34962:
            case 34963:
            case 36662:
            case 36663:
            case 35051:
            case 35052:
            case 35882:
            case 35982:
            case 35345:
                return !0;
            default:
                return !1
            }
        }
          , _glFlushMappedBufferRange = (e, t, r) => {
            if (!emscriptenWebGLValidateMapBufferTarget(e)) {
                GL.recordError(1280),
                err("GL_INVALID_ENUM in glFlushMappedBufferRange");
                return
            }
            var i = GL.mappedBuffers[emscriptenWebGLGetBufferBinding(e)];
            if (!i) {
                GL.recordError(1282),
                err("buffer was never mapped in glFlushMappedBufferRange");
                return
            }
            if (!(16 & i.access)) {
                GL.recordError(1282),
                err("buffer was not mapped with GL_MAP_FLUSH_EXPLICIT_BIT in glFlushMappedBufferRange");
                return
            }
            if (t < 0 || r < 0 || t + r > i.length) {
                GL.recordError(1281),
                err("invalid range in glFlushMappedBufferRange");
                return
            }
            GLctx.bufferSubData(e, i.offset, GROWABLE_HEAP_U8().subarray(i.mem + t, i.mem + t + r))
        }
        ;
        _glFlushMappedBufferRange.sig = "vipp";
        var _emscripten_glFlushMappedBufferRange = _glFlushMappedBufferRange;
        _emscripten_glFlushMappedBufferRange.sig = "vipp";
        var _glFramebufferRenderbuffer = (e, t, r, i) => {
            GLctx.framebufferRenderbuffer(e, t, r, GL.renderbuffers[i])
        }
        ;
        _glFramebufferRenderbuffer.sig = "viiii";
        var _emscripten_glFramebufferRenderbuffer = _glFramebufferRenderbuffer;
        _emscripten_glFramebufferRenderbuffer.sig = "viiii";
        var _glFramebufferTexture2D = (e, t, r, i, n) => {
            GLctx.framebufferTexture2D(e, t, r, GL.textures[i], n)
        }
        ;
        _glFramebufferTexture2D.sig = "viiiii";
        var _emscripten_glFramebufferTexture2D = _glFramebufferTexture2D;
        _emscripten_glFramebufferTexture2D.sig = "viiiii";
        var _glFramebufferTextureLayer = (e, t, r, i, n) => {
            GLctx.framebufferTextureLayer(e, t, GL.textures[r], i, n)
        }
        ;
        _glFramebufferTextureLayer.sig = "viiiii";
        var _emscripten_glFramebufferTextureLayer = _glFramebufferTextureLayer;
        _emscripten_glFramebufferTextureLayer.sig = "viiiii";
        var _glFrontFace = e => GLctx.frontFace(e);
        _glFrontFace.sig = "vi";
        var _emscripten_glFrontFace = _glFrontFace;
        _emscripten_glFrontFace.sig = "vi";
        var _glGenBuffers = (e, t) => {
            GL.genObject(e, t, "createBuffer", GL.buffers)
        }
        ;
        _glGenBuffers.sig = "vip";
        var _emscripten_glGenBuffers = _glGenBuffers;
        _emscripten_glGenBuffers.sig = "vip";
        var _glGenFramebuffers = (e, t) => {
            GL.genObject(e, t, "createFramebuffer", GL.framebuffers)
        }
        ;
        _glGenFramebuffers.sig = "vip";
        var _emscripten_glGenFramebuffers = _glGenFramebuffers;
        _emscripten_glGenFramebuffers.sig = "vip";
        var _glGenQueries = (e, t) => {
            GL.genObject(e, t, "createQuery", GL.queries)
        }
        ;
        _glGenQueries.sig = "vip";
        var _emscripten_glGenQueries = _glGenQueries;
        _emscripten_glGenQueries.sig = "vip";
        var _glGenQueriesEXT = (e, t) => {
            for (var r = 0; r < e; r++) {
                var i = GLctx.disjointTimerQueryExt.createQueryEXT();
                if (!i) {
                    for (GL.recordError(1282); r < e; )
                        GROWABLE_HEAP_I32()[t + 4 * r++ >> 2] = 0;
                    return
                }
                var n = GL.getNewId(GL.queries);
                i.name = n,
                GL.queries[n] = i,
                GROWABLE_HEAP_I32()[t + 4 * r >> 2] = n
            }
        }
        ;
        _glGenQueriesEXT.sig = "vip";
        var _emscripten_glGenQueriesEXT = _glGenQueriesEXT
          , _glGenRenderbuffers = (e, t) => {
            GL.genObject(e, t, "createRenderbuffer", GL.renderbuffers)
        }
        ;
        _glGenRenderbuffers.sig = "vip";
        var _emscripten_glGenRenderbuffers = _glGenRenderbuffers;
        _emscripten_glGenRenderbuffers.sig = "vip";
        var _glGenSamplers = (e, t) => {
            GL.genObject(e, t, "createSampler", GL.samplers)
        }
        ;
        _glGenSamplers.sig = "vip";
        var _emscripten_glGenSamplers = _glGenSamplers;
        _emscripten_glGenSamplers.sig = "vip";
        var _glGenTextures = (e, t) => {
            GL.genObject(e, t, "createTexture", GL.textures)
        }
        ;
        _glGenTextures.sig = "vip";
        var _emscripten_glGenTextures = _glGenTextures;
        _emscripten_glGenTextures.sig = "vip";
        var _glGenTransformFeedbacks = (e, t) => {
            GL.genObject(e, t, "createTransformFeedback", GL.transformFeedbacks)
        }
        ;
        _glGenTransformFeedbacks.sig = "vip";
        var _emscripten_glGenTransformFeedbacks = _glGenTransformFeedbacks;
        _emscripten_glGenTransformFeedbacks.sig = "vip";
        var _glGenVertexArrays = (e, t) => {
            GL.genObject(e, t, "createVertexArray", GL.vaos)
        }
        ;
        _glGenVertexArrays.sig = "vip";
        var _emscripten_glGenVertexArrays = _glGenVertexArrays;
        _emscripten_glGenVertexArrays.sig = "vip";
        var _glGenVertexArraysOES = _glGenVertexArrays;
        _glGenVertexArraysOES.sig = "vip";
        var _emscripten_glGenVertexArraysOES = _glGenVertexArraysOES;
        _emscripten_glGenVertexArraysOES.sig = "vip";
        var _glGenerateMipmap = e => GLctx.generateMipmap(e);
        _glGenerateMipmap.sig = "vi";
        var _emscripten_glGenerateMipmap = _glGenerateMipmap;
        _emscripten_glGenerateMipmap.sig = "vi";
        var __glGetActiveAttribOrUniform = (e, t, r, i, n, o, a, s) => {
            t = GL.programs[t];
            var u = GLctx[e](t, r);
            if (u) {
                var l = s && stringToUTF8(u.name, s, i);
                n && (GROWABLE_HEAP_I32()[n >> 2] = l),
                o && (GROWABLE_HEAP_I32()[o >> 2] = u.size),
                a && (GROWABLE_HEAP_I32()[a >> 2] = u.type)
            }
        }
          , _glGetActiveAttrib = (e, t, r, i, n, o, a) => {
            __glGetActiveAttribOrUniform("getActiveAttrib", e, t, r, i, n, o, a)
        }
        ;
        _glGetActiveAttrib.sig = "viiipppp";
        var _emscripten_glGetActiveAttrib = _glGetActiveAttrib;
        _emscripten_glGetActiveAttrib.sig = "viiipppp";
        var _glGetActiveUniform = (e, t, r, i, n, o, a) => {
            __glGetActiveAttribOrUniform("getActiveUniform", e, t, r, i, n, o, a)
        }
        ;
        _glGetActiveUniform.sig = "viiipppp";
        var _emscripten_glGetActiveUniform = _glGetActiveUniform;
        _emscripten_glGetActiveUniform.sig = "viiipppp";
        var _glGetActiveUniformBlockName = (e, t, r, i, n) => {
            e = GL.programs[e];
            var o = GLctx.getActiveUniformBlockName(e, t);
            if (o) {
                if (n && r > 0) {
                    var a = stringToUTF8(o, n, r);
                    i && (GROWABLE_HEAP_I32()[i >> 2] = a)
                } else
                    i && (GROWABLE_HEAP_I32()[i >> 2] = 0)
            }
        }
        ;
        _glGetActiveUniformBlockName.sig = "viiipp";
        var _emscripten_glGetActiveUniformBlockName = _glGetActiveUniformBlockName;
        _emscripten_glGetActiveUniformBlockName.sig = "viiipp";
        var _glGetActiveUniformBlockiv = (e, t, r, i) => {
            if (!i) {
                GL.recordError(1281);
                return
            }
            if (e = GL.programs[e],
            35393 == r) {
                var n = GLctx.getActiveUniformBlockName(e, t);
                GROWABLE_HEAP_I32()[i >> 2] = n.length + 1;
                return
            }
            var o = GLctx.getActiveUniformBlockParameter(e, t, r);
            if (null !== o) {
                if (35395 == r)
                    for (var a = 0; a < o.length; a++)
                        GROWABLE_HEAP_I32()[i + 4 * a >> 2] = o[a];
                else
                    GROWABLE_HEAP_I32()[i >> 2] = o
            }
        }
        ;
        _glGetActiveUniformBlockiv.sig = "viiip";
        var _emscripten_glGetActiveUniformBlockiv = _glGetActiveUniformBlockiv;
        _emscripten_glGetActiveUniformBlockiv.sig = "viiip";
        var _glGetActiveUniformsiv = (e, t, r, i, n) => {
            if (!n || t > 0 && 0 == r) {
                GL.recordError(1281);
                return
            }
            e = GL.programs[e];
            for (var o = [], a = 0; a < t; a++)
                o.push(GROWABLE_HEAP_I32()[r + 4 * a >> 2]);
            var s = GLctx.getActiveUniforms(e, o, i);
            if (s) {
                for (var u = s.length, a = 0; a < u; a++)
                    GROWABLE_HEAP_I32()[n + 4 * a >> 2] = s[a]
            }
        }
        ;
        _glGetActiveUniformsiv.sig = "viipip";
        var _emscripten_glGetActiveUniformsiv = _glGetActiveUniformsiv;
        _emscripten_glGetActiveUniformsiv.sig = "viipip";
        var _glGetAttachedShaders = (e, t, r, i) => {
            var n = GLctx.getAttachedShaders(GL.programs[e])
              , o = n.length;
            o > t && (o = t),
            GROWABLE_HEAP_I32()[r >> 2] = o;
            for (var a = 0; a < o; ++a) {
                var s = GL.shaders.indexOf(n[a]);
                GROWABLE_HEAP_I32()[i + 4 * a >> 2] = s
            }
        }
        ;
        _glGetAttachedShaders.sig = "viipp";
        var _emscripten_glGetAttachedShaders = _glGetAttachedShaders;
        _emscripten_glGetAttachedShaders.sig = "viipp";
        var _glGetAttribLocation = (e, t) => GLctx.getAttribLocation(GL.programs[e], UTF8ToString(t));
        _glGetAttribLocation.sig = "iip";
        var _emscripten_glGetAttribLocation = _glGetAttribLocation;
        _emscripten_glGetAttribLocation.sig = "iip";
        var writeI53ToI64 = (e, t) => {
            GROWABLE_HEAP_U32()[e >> 2] = t;
            var r = GROWABLE_HEAP_U32()[e >> 2];
            GROWABLE_HEAP_U32()[e + 4 >> 2] = (t - r) / 0x100000000
        }
          , webglGetExtensions = function() {
            var e = getEmscriptenSupportedExtensions(GLctx);
            return e = e.concat(e.map(e => "GL_" + e))
        }
          , emscriptenWebGLGet = (e, t, r) => {
            if (!t) {
                GL.recordError(1281);
                return
            }
            var i = void 0;
            switch (e) {
            case 36346:
                i = 1;
                break;
            case 36344:
                0 != r && 1 != r && GL.recordError(1280);
                return;
            case 34814:
            case 36345:
                i = 0;
                break;
            case 34466:
                var n = GLctx.getParameter(34467);
                i = n ? n.length : 0;
                break;
            case 33309:
                if (GL.currentContext.version < 2) {
                    GL.recordError(1282);
                    return
                }
                i = webglGetExtensions().length;
                break;
            case 33307:
            case 33308:
                if (GL.currentContext.version < 2) {
                    GL.recordError(1280);
                    return
                }
                i = 33307 == e ? 3 : 0
            }
            if (void 0 === i) {
                var o = GLctx.getParameter(e);
                switch (typeof o) {
                case "number":
                    i = o;
                    break;
                case "boolean":
                    i = o ? 1 : 0;
                    break;
                case "string":
                    GL.recordError(1280);
                    return;
                case "object":
                    if (null === o)
                        switch (e) {
                        case 34964:
                        case 35725:
                        case 34965:
                        case 36006:
                        case 36007:
                        case 32873:
                        case 34229:
                        case 36662:
                        case 36663:
                        case 35053:
                        case 35055:
                        case 36010:
                        case 35097:
                        case 35869:
                        case 32874:
                        case 36389:
                        case 35983:
                        case 35368:
                        case 34068:
                            i = 0;
                            break;
                        default:
                            GL.recordError(1280);
                            return
                        }
                    else if (o instanceof Float32Array || o instanceof Uint32Array || o instanceof Int32Array || o instanceof Array) {
                        for (var a = 0; a < o.length; ++a)
                            switch (r) {
                            case 0:
                                GROWABLE_HEAP_I32()[t + 4 * a >> 2] = o[a];
                                break;
                            case 2:
                                GROWABLE_HEAP_F32()[t + 4 * a >> 2] = o[a];
                                break;
                            case 4:
                                GROWABLE_HEAP_I8()[t + a] = o[a] ? 1 : 0
                            }
                        return
                    } else
                        try {
                            i = 0 | o.name
                        } catch (t) {
                            GL.recordError(1280),
                            err(`GL_INVALID_ENUM in glGet${r}v: Unknown object returned from WebGL getParameter(${e})! (error: ${t})`);
                            return
                        }
                    break;
                default:
                    GL.recordError(1280),
                    err(`GL_INVALID_ENUM in glGet${r}v: Native code calling glGet${r}v(${e}) and it returns ${o} of type ${typeof o}!`);
                    return
                }
            }
            switch (r) {
            case 1:
                writeI53ToI64(t, i);
                break;
            case 0:
                GROWABLE_HEAP_I32()[t >> 2] = i;
                break;
            case 2:
                GROWABLE_HEAP_F32()[t >> 2] = i;
                break;
            case 4:
                GROWABLE_HEAP_I8()[t] = i ? 1 : 0
            }
        }
          , _glGetBooleanv = (e, t) => emscriptenWebGLGet(e, t, 4);
        _glGetBooleanv.sig = "vip";
        var _emscripten_glGetBooleanv = _glGetBooleanv;
        _emscripten_glGetBooleanv.sig = "vip";
        var _glGetBufferParameteri64v = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            writeI53ToI64(r, GLctx.getBufferParameter(e, t))
        }
        ;
        _glGetBufferParameteri64v.sig = "viip";
        var _emscripten_glGetBufferParameteri64v = _glGetBufferParameteri64v;
        _emscripten_glGetBufferParameteri64v.sig = "viip";
        var _glGetBufferParameteriv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getBufferParameter(e, t)
        }
        ;
        _glGetBufferParameteriv.sig = "viip";
        var _emscripten_glGetBufferParameteriv = _glGetBufferParameteriv;
        _emscripten_glGetBufferParameteriv.sig = "viip";
        var _glGetBufferPointerv = (e, t, r) => {
            if (35005 == t) {
                var i = 0
                  , n = GL.mappedBuffers[emscriptenWebGLGetBufferBinding(e)];
                n && (i = n.mem),
                GROWABLE_HEAP_I32()[r >> 2] = i
            } else
                GL.recordError(1280),
                err("GL_INVALID_ENUM in glGetBufferPointerv")
        }
        ;
        _glGetBufferPointerv.sig = "viip";
        var _emscripten_glGetBufferPointerv = _glGetBufferPointerv;
        _emscripten_glGetBufferPointerv.sig = "viip";
        var _glGetError = () => {
            var e = GLctx.getError() || GL.lastError;
            return GL.lastError = 0,
            e
        }
        ;
        _glGetError.sig = "i";
        var _emscripten_glGetError = _glGetError;
        _emscripten_glGetError.sig = "i";
        var _glGetFloatv = (e, t) => emscriptenWebGLGet(e, t, 2);
        _glGetFloatv.sig = "vip";
        var _emscripten_glGetFloatv = _glGetFloatv;
        _emscripten_glGetFloatv.sig = "vip";
        var _glGetFragDataLocation = (e, t) => GLctx.getFragDataLocation(GL.programs[e], UTF8ToString(t));
        _glGetFragDataLocation.sig = "iip";
        var _emscripten_glGetFragDataLocation = _glGetFragDataLocation;
        _emscripten_glGetFragDataLocation.sig = "iip";
        var _glGetFramebufferAttachmentParameteriv = (e, t, r, i) => {
            var n = GLctx.getFramebufferAttachmentParameter(e, t, r);
            (n instanceof WebGLRenderbuffer || n instanceof WebGLTexture) && (n = 0 | n.name),
            GROWABLE_HEAP_I32()[i >> 2] = n
        }
        ;
        _glGetFramebufferAttachmentParameteriv.sig = "viiip";
        var _emscripten_glGetFramebufferAttachmentParameteriv = _glGetFramebufferAttachmentParameteriv;
        _emscripten_glGetFramebufferAttachmentParameteriv.sig = "viiip";
        var emscriptenWebGLGetIndexed = (e, t, r, i) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            var n, o = GLctx.getIndexedParameter(e, t);
            switch (typeof o) {
            case "boolean":
                n = o ? 1 : 0;
                break;
            case "number":
                n = o;
                break;
            case "object":
                if (null === o)
                    switch (e) {
                    case 35983:
                    case 35368:
                        n = 0;
                        break;
                    default:
                        GL.recordError(1280);
                        return
                    }
                else if (o instanceof WebGLBuffer)
                    n = 0 | o.name;
                else {
                    GL.recordError(1280);
                    return
                }
                break;
            default:
                GL.recordError(1280);
                return
            }
            switch (i) {
            case 1:
                writeI53ToI64(r, n);
                break;
            case 0:
                GROWABLE_HEAP_I32()[r >> 2] = n;
                break;
            case 2:
                GROWABLE_HEAP_F32()[r >> 2] = n;
                break;
            case 4:
                GROWABLE_HEAP_I8()[r] = n ? 1 : 0;
                break;
            default:
                throw "internal emscriptenWebGLGetIndexed() error, bad type: " + i
            }
        }
          , _glGetInteger64i_v = (e, t, r) => emscriptenWebGLGetIndexed(e, t, r, 1);
        _glGetInteger64i_v.sig = "viip";
        var _emscripten_glGetInteger64i_v = _glGetInteger64i_v;
        _emscripten_glGetInteger64i_v.sig = "viip";
        var _glGetInteger64v = (e, t) => {
            emscriptenWebGLGet(e, t, 1)
        }
        ;
        _glGetInteger64v.sig = "vip";
        var _emscripten_glGetInteger64v = _glGetInteger64v;
        _emscripten_glGetInteger64v.sig = "vip";
        var _glGetIntegeri_v = (e, t, r) => emscriptenWebGLGetIndexed(e, t, r, 0);
        _glGetIntegeri_v.sig = "viip";
        var _emscripten_glGetIntegeri_v = _glGetIntegeri_v;
        _emscripten_glGetIntegeri_v.sig = "viip";
        var _glGetIntegerv = (e, t) => emscriptenWebGLGet(e, t, 0);
        _glGetIntegerv.sig = "vip";
        var _emscripten_glGetIntegerv = _glGetIntegerv;
        _emscripten_glGetIntegerv.sig = "vip";
        var _glGetInternalformativ = (e, t, r, i, n) => {
            if (i < 0 || !n) {
                GL.recordError(1281);
                return
            }
            var o = GLctx.getInternalformatParameter(e, t, r);
            if (null !== o)
                for (var a = 0; a < o.length && a < i; ++a)
                    GROWABLE_HEAP_I32()[n + 4 * a >> 2] = o[a]
        }
        ;
        _glGetInternalformativ.sig = "viiiip";
        var _emscripten_glGetInternalformativ = _glGetInternalformativ;
        _emscripten_glGetInternalformativ.sig = "viiiip";
        var _glGetProgramBinary = (e, t, r, i, n) => {
            GL.recordError(1282)
        }
        ;
        _glGetProgramBinary.sig = "viippp";
        var _emscripten_glGetProgramBinary = _glGetProgramBinary;
        _emscripten_glGetProgramBinary.sig = "viippp";
        var _glGetProgramInfoLog = (e, t, r, i) => {
            var n = GLctx.getProgramInfoLog(GL.programs[e]);
            null === n && (n = "(unknown error)");
            var o = t > 0 && i ? stringToUTF8(n, i, t) : 0;
            r && (GROWABLE_HEAP_I32()[r >> 2] = o)
        }
        ;
        _glGetProgramInfoLog.sig = "viipp";
        var _emscripten_glGetProgramInfoLog = _glGetProgramInfoLog;
        _emscripten_glGetProgramInfoLog.sig = "viipp";
        var _glGetProgramiv = (e, t, r) => {
            if (!r || e >= GL.counter) {
                GL.recordError(1281);
                return
            }
            if (e = GL.programs[e],
            35716 == t) {
                var i = GLctx.getProgramInfoLog(e);
                null === i && (i = "(unknown error)"),
                GROWABLE_HEAP_I32()[r >> 2] = i.length + 1
            } else if (35719 == t) {
                if (!e.maxUniformLength)
                    for (var n = 0; n < GLctx.getProgramParameter(e, 35718); ++n)
                        e.maxUniformLength = Math.max(e.maxUniformLength, GLctx.getActiveUniform(e, n).name.length + 1);
                GROWABLE_HEAP_I32()[r >> 2] = e.maxUniformLength
            } else if (35722 == t) {
                if (!e.maxAttributeLength)
                    for (var n = 0; n < GLctx.getProgramParameter(e, 35721); ++n)
                        e.maxAttributeLength = Math.max(e.maxAttributeLength, GLctx.getActiveAttrib(e, n).name.length + 1);
                GROWABLE_HEAP_I32()[r >> 2] = e.maxAttributeLength
            } else if (35381 == t) {
                if (!e.maxUniformBlockNameLength)
                    for (var n = 0; n < GLctx.getProgramParameter(e, 35382); ++n)
                        e.maxUniformBlockNameLength = Math.max(e.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(e, n).length + 1);
                GROWABLE_HEAP_I32()[r >> 2] = e.maxUniformBlockNameLength
            } else
                GROWABLE_HEAP_I32()[r >> 2] = GLctx.getProgramParameter(e, t)
        }
        ;
        _glGetProgramiv.sig = "viip";
        var _emscripten_glGetProgramiv = _glGetProgramiv;
        _emscripten_glGetProgramiv.sig = "viip";
        var _glGetQueryObjecti64vEXT = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            var i, n, o = GL.queries[e];
            writeI53ToI64(r, n = "boolean" == typeof (i = GL.currentContext.version < 2 ? GLctx.disjointTimerQueryExt.getQueryObjectEXT(o, t) : GLctx.getQueryParameter(o, t)) ? i ? 1 : 0 : i)
        }
        ;
        _glGetQueryObjecti64vEXT.sig = "viip";
        var _emscripten_glGetQueryObjecti64vEXT = _glGetQueryObjecti64vEXT
          , _glGetQueryObjectivEXT = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            var i, n = GL.queries[e], o = GLctx.disjointTimerQueryExt.getQueryObjectEXT(n, t);
            i = "boolean" == typeof o ? o ? 1 : 0 : o,
            GROWABLE_HEAP_I32()[r >> 2] = i
        }
        ;
        _glGetQueryObjectivEXT.sig = "viip";
        var _emscripten_glGetQueryObjectivEXT = _glGetQueryObjectivEXT
          , _glGetQueryObjectui64vEXT = _glGetQueryObjecti64vEXT
          , _emscripten_glGetQueryObjectui64vEXT = _glGetQueryObjectui64vEXT
          , _glGetQueryObjectuiv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            var i, n = GL.queries[e], o = GLctx.getQueryParameter(n, t);
            i = "boolean" == typeof o ? o ? 1 : 0 : o,
            GROWABLE_HEAP_I32()[r >> 2] = i
        }
        ;
        _glGetQueryObjectuiv.sig = "viip";
        var _emscripten_glGetQueryObjectuiv = _glGetQueryObjectuiv;
        _emscripten_glGetQueryObjectuiv.sig = "viip";
        var _glGetQueryObjectuivEXT = _glGetQueryObjectivEXT
          , _emscripten_glGetQueryObjectuivEXT = _glGetQueryObjectuivEXT
          , _glGetQueryiv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getQuery(e, t)
        }
        ;
        _glGetQueryiv.sig = "viip";
        var _emscripten_glGetQueryiv = _glGetQueryiv;
        _emscripten_glGetQueryiv.sig = "viip";
        var _glGetQueryivEXT = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.disjointTimerQueryExt.getQueryEXT(e, t)
        }
        ;
        _glGetQueryivEXT.sig = "viip";
        var _emscripten_glGetQueryivEXT = _glGetQueryivEXT
          , _glGetRenderbufferParameteriv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getRenderbufferParameter(e, t)
        }
        ;
        _glGetRenderbufferParameteriv.sig = "viip";
        var _emscripten_glGetRenderbufferParameteriv = _glGetRenderbufferParameteriv;
        _emscripten_glGetRenderbufferParameteriv.sig = "viip";
        var _glGetSamplerParameterfv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_F32()[r >> 2] = GLctx.getSamplerParameter(GL.samplers[e], t)
        }
        ;
        _glGetSamplerParameterfv.sig = "viip";
        var _emscripten_glGetSamplerParameterfv = _glGetSamplerParameterfv;
        _emscripten_glGetSamplerParameterfv.sig = "viip";
        var _glGetSamplerParameteriv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getSamplerParameter(GL.samplers[e], t)
        }
        ;
        _glGetSamplerParameteriv.sig = "viip";
        var _emscripten_glGetSamplerParameteriv = _glGetSamplerParameteriv;
        _emscripten_glGetSamplerParameteriv.sig = "viip";
        var _glGetShaderInfoLog = (e, t, r, i) => {
            var n = GLctx.getShaderInfoLog(GL.shaders[e]);
            null === n && (n = "(unknown error)");
            var o = t > 0 && i ? stringToUTF8(n, i, t) : 0;
            r && (GROWABLE_HEAP_I32()[r >> 2] = o)
        }
        ;
        _glGetShaderInfoLog.sig = "viipp";
        var _emscripten_glGetShaderInfoLog = _glGetShaderInfoLog;
        _emscripten_glGetShaderInfoLog.sig = "viipp";
        var _glGetShaderPrecisionFormat = (e, t, r, i) => {
            var n = GLctx.getShaderPrecisionFormat(e, t);
            GROWABLE_HEAP_I32()[r >> 2] = n.rangeMin,
            GROWABLE_HEAP_I32()[r + 4 >> 2] = n.rangeMax,
            GROWABLE_HEAP_I32()[i >> 2] = n.precision
        }
        ;
        _glGetShaderPrecisionFormat.sig = "viipp";
        var _emscripten_glGetShaderPrecisionFormat = _glGetShaderPrecisionFormat;
        _emscripten_glGetShaderPrecisionFormat.sig = "viipp";
        var _glGetShaderSource = (e, t, r, i) => {
            var n = GLctx.getShaderSource(GL.shaders[e]);
            if (n) {
                var o = t > 0 && i ? stringToUTF8(n, i, t) : 0;
                r && (GROWABLE_HEAP_I32()[r >> 2] = o)
            }
        }
        ;
        _glGetShaderSource.sig = "viipp";
        var _emscripten_glGetShaderSource = _glGetShaderSource;
        _emscripten_glGetShaderSource.sig = "viipp";
        var _glGetShaderiv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            if (35716 == t) {
                var i = GLctx.getShaderInfoLog(GL.shaders[e]);
                null === i && (i = "(unknown error)");
                var n = i ? i.length + 1 : 0;
                GROWABLE_HEAP_I32()[r >> 2] = n
            } else if (35720 == t) {
                var o = GLctx.getShaderSource(GL.shaders[e])
                  , a = o ? o.length + 1 : 0;
                GROWABLE_HEAP_I32()[r >> 2] = a
            } else
                GROWABLE_HEAP_I32()[r >> 2] = GLctx.getShaderParameter(GL.shaders[e], t)
        }
        ;
        _glGetShaderiv.sig = "viip";
        var _emscripten_glGetShaderiv = _glGetShaderiv;
        _emscripten_glGetShaderiv.sig = "viip";
        var _glGetString = e => {
            var t = GL.stringCache[e];
            if (!t) {
                switch (e) {
                case 7939:
                    t = stringToNewUTF8(webglGetExtensions().join(" "));
                    break;
                case 7936:
                case 7937:
                case 37445:
                case 37446:
                    var r = GLctx.getParameter(e);
                    !r && GL.recordError(1280),
                    t = r ? stringToNewUTF8(r) : 0;
                    break;
                case 7938:
                    var i = GLctx.getParameter(7938);
                    t = stringToNewUTF8(i = GL.currentContext.version >= 2 ? `OpenGL ES 3.0 (${i})` : `OpenGL ES 2.0 (${i})`);
                    break;
                case 35724:
                    var n = GLctx.getParameter(35724)
                      , o = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/
                      , a = n.match(o);
                    null !== a && (3 == a[1].length && (a[1] = a[1] + "0"),
                    n = `OpenGL ES GLSL ES ${a[1]} (${n})`),
                    t = stringToNewUTF8(n);
                    break;
                default:
                    GL.recordError(1280)
                }
                GL.stringCache[e] = t
            }
            return t
        }
        ;
        _glGetString.sig = "pi";
        var _emscripten_glGetString = _glGetString;
        _emscripten_glGetString.sig = "pi";
        var _glGetStringi = (e, t) => {
            if (GL.currentContext.version < 2)
                return GL.recordError(1282),
                0;
            var r = GL.stringiCache[e];
            if (r)
                return t < 0 || t >= r.length ? (GL.recordError(1281),
                0) : r[t];
            if (7939 === e) {
                var i = webglGetExtensions().map(stringToNewUTF8);
                return (r = GL.stringiCache[e] = i,
                t < 0 || t >= r.length) ? (GL.recordError(1281),
                0) : r[t]
            }
            return GL.recordError(1280),
            0
        }
        ;
        _glGetStringi.sig = "pii";
        var _emscripten_glGetStringi = _glGetStringi;
        _emscripten_glGetStringi.sig = "pii";
        var _glGetSynciv = (e, t, r, i, n) => {
            if (r < 0 || !n) {
                GL.recordError(1281);
                return
            }
            var o = GLctx.getSyncParameter(GL.syncs[e], t);
            null !== o && (GROWABLE_HEAP_I32()[n >> 2] = o,
            i && (GROWABLE_HEAP_I32()[i >> 2] = 1))
        }
        ;
        _glGetSynciv.sig = "vpiipp";
        var _emscripten_glGetSynciv = _glGetSynciv;
        _emscripten_glGetSynciv.sig = "vpiipp";
        var _glGetTexParameterfv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_F32()[r >> 2] = GLctx.getTexParameter(e, t)
        }
        ;
        _glGetTexParameterfv.sig = "viip";
        var _emscripten_glGetTexParameterfv = _glGetTexParameterfv;
        _emscripten_glGetTexParameterfv.sig = "viip";
        var _glGetTexParameteriv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getTexParameter(e, t)
        }
        ;
        _glGetTexParameteriv.sig = "viip";
        var _emscripten_glGetTexParameteriv = _glGetTexParameteriv;
        _emscripten_glGetTexParameteriv.sig = "viip";
        var _glGetTransformFeedbackVarying = (e, t, r, i, n, o, a) => {
            e = GL.programs[e];
            var s = GLctx.getTransformFeedbackVarying(e, t);
            if (s) {
                if (a && r > 0) {
                    var u = stringToUTF8(s.name, a, r);
                    i && (GROWABLE_HEAP_I32()[i >> 2] = u)
                } else
                    i && (GROWABLE_HEAP_I32()[i >> 2] = 0);
                n && (GROWABLE_HEAP_I32()[n >> 2] = s.size),
                o && (GROWABLE_HEAP_I32()[o >> 2] = s.type)
            }
        }
        ;
        _glGetTransformFeedbackVarying.sig = "viiipppp";
        var _emscripten_glGetTransformFeedbackVarying = _glGetTransformFeedbackVarying;
        _emscripten_glGetTransformFeedbackVarying.sig = "viiipppp";
        var _glGetUniformBlockIndex = (e, t) => GLctx.getUniformBlockIndex(GL.programs[e], UTF8ToString(t));
        _glGetUniformBlockIndex.sig = "iip";
        var _emscripten_glGetUniformBlockIndex = _glGetUniformBlockIndex;
        _emscripten_glGetUniformBlockIndex.sig = "iip";
        var _glGetUniformIndices = (e, t, r, i) => {
            if (!i || t > 0 && (0 == r || 0 == i)) {
                GL.recordError(1281);
                return
            }
            e = GL.programs[e];
            for (var n = [], o = 0; o < t; o++)
                n.push(UTF8ToString(GROWABLE_HEAP_I32()[r + 4 * o >> 2]));
            var a = GLctx.getUniformIndices(e, n);
            if (a) {
                for (var s = a.length, o = 0; o < s; o++)
                    GROWABLE_HEAP_I32()[i + 4 * o >> 2] = a[o]
            }
        }
        ;
        _glGetUniformIndices.sig = "viipp";
        var _emscripten_glGetUniformIndices = _glGetUniformIndices;
        _emscripten_glGetUniformIndices.sig = "viipp";
        var jstoi_q = e => parseInt(e)
          , webglGetLeftBracePos = e => "]" == e.slice(-1) && e.lastIndexOf("[")
          , webglPrepareUniformLocationsBeforeFirstUse = e => {
            var t, r, i = e.uniformLocsById, n = e.uniformSizeAndIdsByName;
            if (!i)
                for (t = 0,
                e.uniformLocsById = i = {},
                e.uniformArrayNamesById = {}; t < GLctx.getProgramParameter(e, 35718); ++t) {
                    var o = GLctx.getActiveUniform(e, t)
                      , a = o.name
                      , s = o.size
                      , u = webglGetLeftBracePos(a)
                      , l = u > 0 ? a.slice(0, u) : a
                      , c = e.uniformIdCounter;
                    for (e.uniformIdCounter += s,
                    n[l] = [s, c],
                    r = 0; r < s; ++r)
                        i[c] = r,
                        e.uniformArrayNamesById[c++] = l
                }
        }
          , _glGetUniformLocation = (e, t) => {
            if (t = UTF8ToString(t),
            e = GL.programs[e]) {
                webglPrepareUniformLocationsBeforeFirstUse(e);
                var r = e.uniformLocsById
                  , i = 0
                  , n = t
                  , o = webglGetLeftBracePos(t);
                o > 0 && (i = jstoi_q(t.slice(o + 1)) >>> 0,
                n = t.slice(0, o));
                var a = e.uniformSizeAndIdsByName[n];
                if (a && i < a[0] && (r[i += a[1]] = r[i] || GLctx.getUniformLocation(e, t)))
                    return i
            } else
                GL.recordError(1281);
            return -1
        }
        ;
        _glGetUniformLocation.sig = "iip";
        var _emscripten_glGetUniformLocation = _glGetUniformLocation;
        _emscripten_glGetUniformLocation.sig = "iip";
        var webglGetUniformLocation = e => {
            var t = GLctx.currentProgram;
            if (t) {
                var r = t.uniformLocsById[e];
                return "number" == typeof r && (t.uniformLocsById[e] = r = GLctx.getUniformLocation(t, t.uniformArrayNamesById[e] + (r > 0 ? `[${r}]` : ""))),
                r
            }
            GL.recordError(1282)
        }
          , emscriptenWebGLGetUniform = (e, t, r, i) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            webglPrepareUniformLocationsBeforeFirstUse(e = GL.programs[e]);
            var n = GLctx.getUniform(e, webglGetUniformLocation(t));
            if ("number" == typeof n || "boolean" == typeof n)
                switch (i) {
                case 0:
                    GROWABLE_HEAP_I32()[r >> 2] = n;
                    break;
                case 2:
                    GROWABLE_HEAP_F32()[r >> 2] = n
                }
            else
                for (var o = 0; o < n.length; o++)
                    switch (i) {
                    case 0:
                        GROWABLE_HEAP_I32()[r + 4 * o >> 2] = n[o];
                        break;
                    case 2:
                        GROWABLE_HEAP_F32()[r + 4 * o >> 2] = n[o]
                    }
        }
          , _glGetUniformfv = (e, t, r) => {
            emscriptenWebGLGetUniform(e, t, r, 2)
        }
        ;
        _glGetUniformfv.sig = "viip";
        var _emscripten_glGetUniformfv = _glGetUniformfv;
        _emscripten_glGetUniformfv.sig = "viip";
        var _glGetUniformiv = (e, t, r) => {
            emscriptenWebGLGetUniform(e, t, r, 0)
        }
        ;
        _glGetUniformiv.sig = "viip";
        var _emscripten_glGetUniformiv = _glGetUniformiv;
        _emscripten_glGetUniformiv.sig = "viip";
        var _glGetUniformuiv = (e, t, r) => emscriptenWebGLGetUniform(e, t, r, 0);
        _glGetUniformuiv.sig = "viip";
        var _emscripten_glGetUniformuiv = _glGetUniformuiv;
        _emscripten_glGetUniformuiv.sig = "viip";
        var emscriptenWebGLGetVertexAttrib = (e, t, r, i) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GL.currentContext.clientBuffers[e].enabled && err("glGetVertexAttrib*v on client-side array: not supported, bad data returned");
            var n = GLctx.getVertexAttrib(e, t);
            if (34975 == t)
                GROWABLE_HEAP_I32()[r >> 2] = n && n.name;
            else if ("number" == typeof n || "boolean" == typeof n)
                switch (i) {
                case 0:
                    GROWABLE_HEAP_I32()[r >> 2] = n;
                    break;
                case 2:
                    GROWABLE_HEAP_F32()[r >> 2] = n;
                    break;
                case 5:
                    GROWABLE_HEAP_I32()[r >> 2] = Math.fround(n)
                }
            else
                for (var o = 0; o < n.length; o++)
                    switch (i) {
                    case 0:
                        GROWABLE_HEAP_I32()[r + 4 * o >> 2] = n[o];
                        break;
                    case 2:
                        GROWABLE_HEAP_F32()[r + 4 * o >> 2] = n[o];
                        break;
                    case 5:
                        GROWABLE_HEAP_I32()[r + 4 * o >> 2] = Math.fround(n[o])
                    }
        }
          , _glGetVertexAttribIiv = (e, t, r) => {
            emscriptenWebGLGetVertexAttrib(e, t, r, 0)
        }
        ;
        _glGetVertexAttribIiv.sig = "viip";
        var _emscripten_glGetVertexAttribIiv = _glGetVertexAttribIiv;
        _emscripten_glGetVertexAttribIiv.sig = "viip";
        var _glGetVertexAttribIuiv = _glGetVertexAttribIiv;
        _glGetVertexAttribIuiv.sig = "viip";
        var _emscripten_glGetVertexAttribIuiv = _glGetVertexAttribIuiv;
        _emscripten_glGetVertexAttribIuiv.sig = "viip";
        var _glGetVertexAttribPointerv = (e, t, r) => {
            if (!r) {
                GL.recordError(1281);
                return
            }
            GL.currentContext.clientBuffers[e].enabled && err("glGetVertexAttribPointer on client-side array: not supported, bad data returned"),
            GROWABLE_HEAP_I32()[r >> 2] = GLctx.getVertexAttribOffset(e, t)
        }
        ;
        _glGetVertexAttribPointerv.sig = "viip";
        var _emscripten_glGetVertexAttribPointerv = _glGetVertexAttribPointerv;
        _emscripten_glGetVertexAttribPointerv.sig = "viip";
        var _glGetVertexAttribfv = (e, t, r) => {
            emscriptenWebGLGetVertexAttrib(e, t, r, 2)
        }
        ;
        _glGetVertexAttribfv.sig = "viip";
        var _emscripten_glGetVertexAttribfv = _glGetVertexAttribfv;
        _emscripten_glGetVertexAttribfv.sig = "viip";
        var _glGetVertexAttribiv = (e, t, r) => {
            emscriptenWebGLGetVertexAttrib(e, t, r, 5)
        }
        ;
        _glGetVertexAttribiv.sig = "viip";
        var _emscripten_glGetVertexAttribiv = _glGetVertexAttribiv;
        _emscripten_glGetVertexAttribiv.sig = "viip";
        var _glHint = (e, t) => GLctx.hint(e, t);
        _glHint.sig = "vii";
        var _emscripten_glHint = _glHint;
        _emscripten_glHint.sig = "vii";
        var _glInvalidateFramebuffer = (e, t, r) => {
            for (var i = tempFixedLengthArray[t], n = 0; n < t; n++)
                i[n] = GROWABLE_HEAP_I32()[r + 4 * n >> 2];
            GLctx.invalidateFramebuffer(e, i)
        }
        ;
        _glInvalidateFramebuffer.sig = "viip";
        var _emscripten_glInvalidateFramebuffer = _glInvalidateFramebuffer;
        _emscripten_glInvalidateFramebuffer.sig = "viip";
        var _glInvalidateSubFramebuffer = (e, t, r, i, n, o, a) => {
            for (var s = tempFixedLengthArray[t], u = 0; u < t; u++)
                s[u] = GROWABLE_HEAP_I32()[r + 4 * u >> 2];
            GLctx.invalidateSubFramebuffer(e, s, i, n, o, a)
        }
        ;
        _glInvalidateSubFramebuffer.sig = "viipiiii";
        var _emscripten_glInvalidateSubFramebuffer = _glInvalidateSubFramebuffer;
        _emscripten_glInvalidateSubFramebuffer.sig = "viipiiii";
        var _glIsBuffer = e => {
            var t = GL.buffers[e];
            return t ? GLctx.isBuffer(t) : 0
        }
        ;
        _glIsBuffer.sig = "ii";
        var _emscripten_glIsBuffer = _glIsBuffer;
        _emscripten_glIsBuffer.sig = "ii";
        var _glIsEnabled = e => GLctx.isEnabled(e);
        _glIsEnabled.sig = "ii";
        var _emscripten_glIsEnabled = _glIsEnabled;
        _emscripten_glIsEnabled.sig = "ii";
        var _glIsFramebuffer = e => {
            var t = GL.framebuffers[e];
            return t ? GLctx.isFramebuffer(t) : 0
        }
        ;
        _glIsFramebuffer.sig = "ii";
        var _emscripten_glIsFramebuffer = _glIsFramebuffer;
        _emscripten_glIsFramebuffer.sig = "ii";
        var _glIsProgram = e => (e = GL.programs[e]) ? GLctx.isProgram(e) : 0;
        _glIsProgram.sig = "ii";
        var _emscripten_glIsProgram = _glIsProgram;
        _emscripten_glIsProgram.sig = "ii";
        var _glIsQuery = e => {
            var t = GL.queries[e];
            return t ? GLctx.isQuery(t) : 0
        }
        ;
        _glIsQuery.sig = "ii";
        var _emscripten_glIsQuery = _glIsQuery;
        _emscripten_glIsQuery.sig = "ii";
        var _glIsQueryEXT = e => {
            var t = GL.queries[e];
            return t ? GLctx.disjointTimerQueryExt.isQueryEXT(t) : 0
        }
        ;
        _glIsQueryEXT.sig = "ii";
        var _emscripten_glIsQueryEXT = _glIsQueryEXT
          , _glIsRenderbuffer = e => {
            var t = GL.renderbuffers[e];
            return t ? GLctx.isRenderbuffer(t) : 0
        }
        ;
        _glIsRenderbuffer.sig = "ii";
        var _emscripten_glIsRenderbuffer = _glIsRenderbuffer;
        _emscripten_glIsRenderbuffer.sig = "ii";
        var _glIsSampler = e => {
            var t = GL.samplers[e];
            return t ? GLctx.isSampler(t) : 0
        }
        ;
        _glIsSampler.sig = "ii";
        var _emscripten_glIsSampler = _glIsSampler;
        _emscripten_glIsSampler.sig = "ii";
        var _glIsShader = e => {
            var t = GL.shaders[e];
            return t ? GLctx.isShader(t) : 0
        }
        ;
        _glIsShader.sig = "ii";
        var _emscripten_glIsShader = _glIsShader;
        _emscripten_glIsShader.sig = "ii";
        var _glIsSync = e => GLctx.isSync(GL.syncs[e]);
        _glIsSync.sig = "ip";
        var _emscripten_glIsSync = _glIsSync;
        _emscripten_glIsSync.sig = "ip";
        var _glIsTexture = e => {
            var t = GL.textures[e];
            return t ? GLctx.isTexture(t) : 0
        }
        ;
        _glIsTexture.sig = "ii";
        var _emscripten_glIsTexture = _glIsTexture;
        _emscripten_glIsTexture.sig = "ii";
        var _glIsTransformFeedback = e => GLctx.isTransformFeedback(GL.transformFeedbacks[e]);
        _glIsTransformFeedback.sig = "ii";
        var _emscripten_glIsTransformFeedback = _glIsTransformFeedback;
        _emscripten_glIsTransformFeedback.sig = "ii";
        var _glIsVertexArray = e => {
            var t = GL.vaos[e];
            return t ? GLctx.isVertexArray(t) : 0
        }
        ;
        _glIsVertexArray.sig = "ii";
        var _emscripten_glIsVertexArray = _glIsVertexArray;
        _emscripten_glIsVertexArray.sig = "ii";
        var _glIsVertexArrayOES = _glIsVertexArray;
        _glIsVertexArrayOES.sig = "ii";
        var _emscripten_glIsVertexArrayOES = _glIsVertexArrayOES;
        _emscripten_glIsVertexArrayOES.sig = "ii";
        var _glLineWidth = e => GLctx.lineWidth(e);
        _glLineWidth.sig = "vf";
        var _emscripten_glLineWidth = _glLineWidth;
        _emscripten_glLineWidth.sig = "vf";
        var _glLinkProgram = e => {
            e = GL.programs[e],
            GLctx.linkProgram(e),
            e.uniformLocsById = 0,
            e.uniformSizeAndIdsByName = {}
        }
        ;
        _glLinkProgram.sig = "vi";
        var _emscripten_glLinkProgram = _glLinkProgram;
        _emscripten_glLinkProgram.sig = "vi";
        var _glMapBufferRange = (e, t, r, i) => {
            if ((33 & i) != 0)
                return err("glMapBufferRange access does not support MAP_READ or MAP_UNSYNCHRONIZED"),
                0;
            if ((2 & i) == 0)
                return err("glMapBufferRange access must include MAP_WRITE"),
                0;
            if ((12 & i) == 0)
                return err("glMapBufferRange access must include INVALIDATE_BUFFER or INVALIDATE_RANGE"),
                0;
            if (!emscriptenWebGLValidateMapBufferTarget(e))
                return GL.recordError(1280),
                err("GL_INVALID_ENUM in glMapBufferRange"),
                0;
            var n = _malloc(r)
              , o = emscriptenWebGLGetBufferBinding(e);
            return n ? (!GL.mappedBuffers[o] && (GL.mappedBuffers[o] = {}),
            (o = GL.mappedBuffers[o]).offset = t,
            o.length = r,
            o.mem = n,
            o.access = i,
            n) : 0
        }
        ;
        _glMapBufferRange.sig = "pippi";
        var _emscripten_glMapBufferRange = _glMapBufferRange;
        _emscripten_glMapBufferRange.sig = "pippi";
        var _glPauseTransformFeedback = () => GLctx.pauseTransformFeedback();
        _glPauseTransformFeedback.sig = "v";
        var _emscripten_glPauseTransformFeedback = _glPauseTransformFeedback;
        _emscripten_glPauseTransformFeedback.sig = "v";
        var _glPixelStorei = (e, t) => {
            3317 == e && (GL.unpackAlignment = t),
            GLctx.pixelStorei(e, t)
        }
        ;
        _glPixelStorei.sig = "vii";
        var _emscripten_glPixelStorei = _glPixelStorei;
        _emscripten_glPixelStorei.sig = "vii";
        var _glPolygonOffset = (e, t) => GLctx.polygonOffset(e, t);
        _glPolygonOffset.sig = "vff";
        var _emscripten_glPolygonOffset = _glPolygonOffset;
        _emscripten_glPolygonOffset.sig = "vff";
        var _glProgramBinary = (e, t, r, i) => {
            GL.recordError(1280)
        }
        ;
        _glProgramBinary.sig = "viipi";
        var _emscripten_glProgramBinary = _glProgramBinary;
        _emscripten_glProgramBinary.sig = "viipi";
        var _glProgramParameteri = (e, t, r) => {
            GL.recordError(1280)
        }
        ;
        _glProgramParameteri.sig = "viii";
        var _emscripten_glProgramParameteri = _glProgramParameteri;
        _emscripten_glProgramParameteri.sig = "viii";
        var _glQueryCounterEXT = (e, t) => {
            GLctx.disjointTimerQueryExt.queryCounterEXT(GL.queries[e], t)
        }
        ;
        _glQueryCounterEXT.sig = "vii";
        var _emscripten_glQueryCounterEXT = _glQueryCounterEXT
          , _glReadBuffer = e => GLctx.readBuffer(e);
        _glReadBuffer.sig = "vi";
        var _emscripten_glReadBuffer = _glReadBuffer;
        _emscripten_glReadBuffer.sig = "vi";
        var computeUnpackAlignedImageSize = (e, t, r, i) => t * function e(e, t) {
            return e + t - 1 & -t
        }(e * r, i)
          , colorChannelsInGlTextureFormat = e => ({
            5: 3,
            6: 4,
            8: 2,
            29502: 3,
            29504: 4,
            26917: 2,
            26918: 2,
            29846: 3,
            29847: 4
        })[e - 6402] || 1
          , heapObjectForWebGLType = e => 0 == (e -= 5120) ? GROWABLE_HEAP_I8() : 1 == e ? GROWABLE_HEAP_U8() : 2 == e ? GROWABLE_HEAP_I16() : 4 == e ? GROWABLE_HEAP_I32() : 6 == e ? GROWABLE_HEAP_F32() : 5 == e || 28922 == e || 28520 == e || 30779 == e || 30782 == e ? GROWABLE_HEAP_U32() : GROWABLE_HEAP_U16()
          , toTypedArrayIndex = (e, t) => e >>> 31 - Math.clz32(t.BYTES_PER_ELEMENT)
          , emscriptenWebGLGetTexPixelData = (e, t, r, i, n, o) => {
            var a = heapObjectForWebGLType(e)
              , s = computeUnpackAlignedImageSize(r, i, colorChannelsInGlTextureFormat(t) * a.BYTES_PER_ELEMENT, GL.unpackAlignment);
            return a.subarray(toTypedArrayIndex(n, a), toTypedArrayIndex(n + s, a))
        }
          , _glReadPixels = (e, t, r, i, n, o, a) => {
            if (GL.currentContext.version >= 2) {
                if (GLctx.currentPixelPackBufferBinding)
                    GLctx.readPixels(e, t, r, i, n, o, a);
                else {
                    var s = heapObjectForWebGLType(o)
                      , u = toTypedArrayIndex(a, s);
                    GLctx.readPixels(e, t, r, i, n, o, s, u)
                }
                return
            }
            var l = emscriptenWebGLGetTexPixelData(o, n, r, i, a, n);
            if (!l) {
                GL.recordError(1280);
                return
            }
            GLctx.readPixels(e, t, r, i, n, o, l)
        }
        ;
        _glReadPixels.sig = "viiiiiip";
        var _emscripten_glReadPixels = _glReadPixels;
        _emscripten_glReadPixels.sig = "viiiiiip";
        var _glReleaseShaderCompiler = () => {}
        ;
        _glReleaseShaderCompiler.sig = "v";
        var _emscripten_glReleaseShaderCompiler = _glReleaseShaderCompiler;
        _emscripten_glReleaseShaderCompiler.sig = "v";
        var _glRenderbufferStorage = (e, t, r, i) => GLctx.renderbufferStorage(e, t, r, i);
        _glRenderbufferStorage.sig = "viiii";
        var _emscripten_glRenderbufferStorage = _glRenderbufferStorage;
        _emscripten_glRenderbufferStorage.sig = "viiii";
        var _glRenderbufferStorageMultisample = (e, t, r, i, n) => GLctx.renderbufferStorageMultisample(e, t, r, i, n);
        _glRenderbufferStorageMultisample.sig = "viiiii";
        var _emscripten_glRenderbufferStorageMultisample = _glRenderbufferStorageMultisample;
        _emscripten_glRenderbufferStorageMultisample.sig = "viiiii";
        var _glResumeTransformFeedback = () => GLctx.resumeTransformFeedback();
        _glResumeTransformFeedback.sig = "v";
        var _emscripten_glResumeTransformFeedback = _glResumeTransformFeedback;
        _emscripten_glResumeTransformFeedback.sig = "v";
        var _glSampleCoverage = (e, t) => {
            GLctx.sampleCoverage(e, !!t)
        }
        ;
        _glSampleCoverage.sig = "vfi";
        var _emscripten_glSampleCoverage = _glSampleCoverage;
        _emscripten_glSampleCoverage.sig = "vfi";
        var _glSamplerParameterf = (e, t, r) => {
            GLctx.samplerParameterf(GL.samplers[e], t, r)
        }
        ;
        _glSamplerParameterf.sig = "viif";
        var _emscripten_glSamplerParameterf = _glSamplerParameterf;
        _emscripten_glSamplerParameterf.sig = "viif";
        var _glSamplerParameterfv = (e, t, r) => {
            var i = GROWABLE_HEAP_F32()[r >> 2];
            GLctx.samplerParameterf(GL.samplers[e], t, i)
        }
        ;
        _glSamplerParameterfv.sig = "viip";
        var _emscripten_glSamplerParameterfv = _glSamplerParameterfv;
        _emscripten_glSamplerParameterfv.sig = "viip";
        var _glSamplerParameteri = (e, t, r) => {
            GLctx.samplerParameteri(GL.samplers[e], t, r)
        }
        ;
        _glSamplerParameteri.sig = "viii";
        var _emscripten_glSamplerParameteri = _glSamplerParameteri;
        _emscripten_glSamplerParameteri.sig = "viii";
        var _glSamplerParameteriv = (e, t, r) => {
            var i = GROWABLE_HEAP_I32()[r >> 2];
            GLctx.samplerParameteri(GL.samplers[e], t, i)
        }
        ;
        _glSamplerParameteriv.sig = "viip";
        var _emscripten_glSamplerParameteriv = _glSamplerParameteriv;
        _emscripten_glSamplerParameteriv.sig = "viip";
        var _glScissor = (e, t, r, i) => GLctx.scissor(e, t, r, i);
        _glScissor.sig = "viiii";
        var _emscripten_glScissor = _glScissor;
        _emscripten_glScissor.sig = "viiii";
        var _glShaderBinary = (e, t, r, i, n) => {
            GL.recordError(1280)
        }
        ;
        _glShaderBinary.sig = "vipipi";
        var _emscripten_glShaderBinary = _glShaderBinary;
        _emscripten_glShaderBinary.sig = "vipipi";
        var _glShaderSource = (e, t, r, i) => {
            var n = GL.getSource(e, t, r, i);
            GLctx.shaderSource(GL.shaders[e], n)
        }
        ;
        _glShaderSource.sig = "viipp";
        var _emscripten_glShaderSource = _glShaderSource;
        _emscripten_glShaderSource.sig = "viipp";
        var _glStencilFunc = (e, t, r) => GLctx.stencilFunc(e, t, r);
        _glStencilFunc.sig = "viii";
        var _emscripten_glStencilFunc = _glStencilFunc;
        _emscripten_glStencilFunc.sig = "viii";
        var _glStencilFuncSeparate = (e, t, r, i) => GLctx.stencilFuncSeparate(e, t, r, i);
        _glStencilFuncSeparate.sig = "viiii";
        var _emscripten_glStencilFuncSeparate = _glStencilFuncSeparate;
        _emscripten_glStencilFuncSeparate.sig = "viiii";
        var _glStencilMask = e => GLctx.stencilMask(e);
        _glStencilMask.sig = "vi";
        var _emscripten_glStencilMask = _glStencilMask;
        _emscripten_glStencilMask.sig = "vi";
        var _glStencilMaskSeparate = (e, t) => GLctx.stencilMaskSeparate(e, t);
        _glStencilMaskSeparate.sig = "vii";
        var _emscripten_glStencilMaskSeparate = _glStencilMaskSeparate;
        _emscripten_glStencilMaskSeparate.sig = "vii";
        var _glStencilOp = (e, t, r) => GLctx.stencilOp(e, t, r);
        _glStencilOp.sig = "viii";
        var _emscripten_glStencilOp = _glStencilOp;
        _emscripten_glStencilOp.sig = "viii";
        var _glStencilOpSeparate = (e, t, r, i) => GLctx.stencilOpSeparate(e, t, r, i);
        _glStencilOpSeparate.sig = "viiii";
        var _emscripten_glStencilOpSeparate = _glStencilOpSeparate;
        _emscripten_glStencilOpSeparate.sig = "viiii";
        var _glTexImage2D = (e, t, r, i, n, o, a, s, u) => {
            if (GL.currentContext.version >= 2) {
                if (GLctx.currentPixelUnpackBufferBinding)
                    GLctx.texImage2D(e, t, r, i, n, o, a, s, u);
                else if (u) {
                    var l = heapObjectForWebGLType(s);
                    GLctx.texImage2D(e, t, r, i, n, o, a, s, l, toTypedArrayIndex(u, l))
                } else
                    GLctx.texImage2D(e, t, r, i, n, o, a, s, null);
                return
            }
            GLctx.texImage2D(e, t, r, i, n, o, a, s, u ? emscriptenWebGLGetTexPixelData(s, a, i, n, u, r) : null)
        }
        ;
        _glTexImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexImage2D = _glTexImage2D;
        _emscripten_glTexImage2D.sig = "viiiiiiiip";
        var _glTexImage3D = (e, t, r, i, n, o, a, s, u, l) => {
            if (GLctx.currentPixelUnpackBufferBinding)
                GLctx.texImage3D(e, t, r, i, n, o, a, s, u, l);
            else if (l) {
                var c = heapObjectForWebGLType(u);
                GLctx.texImage3D(e, t, r, i, n, o, a, s, u, c, toTypedArrayIndex(l, c))
            } else
                GLctx.texImage3D(e, t, r, i, n, o, a, s, u, null)
        }
        ;
        _glTexImage3D.sig = "viiiiiiiiip";
        var _emscripten_glTexImage3D = _glTexImage3D;
        _emscripten_glTexImage3D.sig = "viiiiiiiiip";
        var _glTexParameterf = (e, t, r) => GLctx.texParameterf(e, t, r);
        _glTexParameterf.sig = "viif";
        var _emscripten_glTexParameterf = _glTexParameterf;
        _emscripten_glTexParameterf.sig = "viif";
        var _glTexParameterfv = (e, t, r) => {
            var i = GROWABLE_HEAP_F32()[r >> 2];
            GLctx.texParameterf(e, t, i)
        }
        ;
        _glTexParameterfv.sig = "viip";
        var _emscripten_glTexParameterfv = _glTexParameterfv;
        _emscripten_glTexParameterfv.sig = "viip";
        var _glTexParameteri = (e, t, r) => GLctx.texParameteri(e, t, r);
        _glTexParameteri.sig = "viii";
        var _emscripten_glTexParameteri = _glTexParameteri;
        _emscripten_glTexParameteri.sig = "viii";
        var _glTexParameteriv = (e, t, r) => {
            var i = GROWABLE_HEAP_I32()[r >> 2];
            GLctx.texParameteri(e, t, i)
        }
        ;
        _glTexParameteriv.sig = "viip";
        var _emscripten_glTexParameteriv = _glTexParameteriv;
        _emscripten_glTexParameteriv.sig = "viip";
        var _glTexStorage2D = (e, t, r, i, n) => GLctx.texStorage2D(e, t, r, i, n);
        _glTexStorage2D.sig = "viiiii";
        var _emscripten_glTexStorage2D = _glTexStorage2D;
        _emscripten_glTexStorage2D.sig = "viiiii";
        var _glTexStorage3D = (e, t, r, i, n, o) => GLctx.texStorage3D(e, t, r, i, n, o);
        _glTexStorage3D.sig = "viiiiii";
        var _emscripten_glTexStorage3D = _glTexStorage3D;
        _emscripten_glTexStorage3D.sig = "viiiiii";
        var _glTexSubImage2D = (e, t, r, i, n, o, a, s, u) => {
            if (GL.currentContext.version >= 2) {
                if (GLctx.currentPixelUnpackBufferBinding)
                    GLctx.texSubImage2D(e, t, r, i, n, o, a, s, u);
                else if (u) {
                    var l = heapObjectForWebGLType(s);
                    GLctx.texSubImage2D(e, t, r, i, n, o, a, s, l, toTypedArrayIndex(u, l))
                } else
                    GLctx.texSubImage2D(e, t, r, i, n, o, a, s, null);
                return
            }
            var c = null;
            u && (c = emscriptenWebGLGetTexPixelData(s, a, n, o, u, 0)),
            GLctx.texSubImage2D(e, t, r, i, n, o, a, s, c)
        }
        ;
        _glTexSubImage2D.sig = "viiiiiiiip";
        var _emscripten_glTexSubImage2D = _glTexSubImage2D;
        _emscripten_glTexSubImage2D.sig = "viiiiiiiip";
        var _glTexSubImage3D = (e, t, r, i, n, o, a, s, u, l, c) => {
            if (GLctx.currentPixelUnpackBufferBinding)
                GLctx.texSubImage3D(e, t, r, i, n, o, a, s, u, l, c);
            else if (c) {
                var p = heapObjectForWebGLType(l);
                GLctx.texSubImage3D(e, t, r, i, n, o, a, s, u, l, p, toTypedArrayIndex(c, p))
            } else
                GLctx.texSubImage3D(e, t, r, i, n, o, a, s, u, l, null)
        }
        ;
        _glTexSubImage3D.sig = "viiiiiiiiiip";
        var _emscripten_glTexSubImage3D = _glTexSubImage3D;
        _emscripten_glTexSubImage3D.sig = "viiiiiiiiiip";
        var _glTransformFeedbackVaryings = (e, t, r, i) => {
            e = GL.programs[e];
            for (var n = [], o = 0; o < t; o++)
                n.push(UTF8ToString(GROWABLE_HEAP_I32()[r + 4 * o >> 2]));
            GLctx.transformFeedbackVaryings(e, n, i)
        }
        ;
        _glTransformFeedbackVaryings.sig = "viipi";
        var _emscripten_glTransformFeedbackVaryings = _glTransformFeedbackVaryings;
        _emscripten_glTransformFeedbackVaryings.sig = "viipi";
        var _glUniform1f = (e, t) => {
            GLctx.uniform1f(webglGetUniformLocation(e), t)
        }
        ;
        _glUniform1f.sig = "vif";
        var _emscripten_glUniform1f = _glUniform1f;
        _emscripten_glUniform1f.sig = "vif";
        var miniTempWebGLFloatBuffers = []
          , _glUniform1fv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform1fv(webglGetUniformLocation(e), GROWABLE_HEAP_F32(), r >> 2, t);
                return
            }
            if (t <= 288) {
                for (var i = miniTempWebGLFloatBuffers[t - 1], n = 0; n < t; ++n)
                    i[n] = GROWABLE_HEAP_F32()[r + 4 * n >> 2]
            } else
                var i = GROWABLE_HEAP_F32().subarray(r >> 2, r + 4 * t >> 2);
            GLctx.uniform1fv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform1fv.sig = "viip";
        var _emscripten_glUniform1fv = _glUniform1fv;
        _emscripten_glUniform1fv.sig = "viip";
        var _glUniform1i = (e, t) => {
            GLctx.uniform1i(webglGetUniformLocation(e), t)
        }
        ;
        _glUniform1i.sig = "vii";
        var _emscripten_glUniform1i = _glUniform1i;
        _emscripten_glUniform1i.sig = "vii";
        var miniTempWebGLIntBuffers = []
          , _glUniform1iv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform1iv(webglGetUniformLocation(e), GROWABLE_HEAP_I32(), r >> 2, t);
                return
            }
            if (t <= 288) {
                for (var i = miniTempWebGLIntBuffers[t - 1], n = 0; n < t; ++n)
                    i[n] = GROWABLE_HEAP_I32()[r + 4 * n >> 2]
            } else
                var i = GROWABLE_HEAP_I32().subarray(r >> 2, r + 4 * t >> 2);
            GLctx.uniform1iv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform1iv.sig = "viip";
        var _emscripten_glUniform1iv = _glUniform1iv;
        _emscripten_glUniform1iv.sig = "viip";
        var _glUniform1ui = (e, t) => {
            GLctx.uniform1ui(webglGetUniformLocation(e), t)
        }
        ;
        _glUniform1ui.sig = "vii";
        var _emscripten_glUniform1ui = _glUniform1ui;
        _emscripten_glUniform1ui.sig = "vii";
        var _glUniform1uiv = (e, t, r) => {
            t && GLctx.uniform1uiv(webglGetUniformLocation(e), GROWABLE_HEAP_U32(), r >> 2, t)
        }
        ;
        _glUniform1uiv.sig = "viip";
        var _emscripten_glUniform1uiv = _glUniform1uiv;
        _emscripten_glUniform1uiv.sig = "viip";
        var _glUniform2f = (e, t, r) => {
            GLctx.uniform2f(webglGetUniformLocation(e), t, r)
        }
        ;
        _glUniform2f.sig = "viff";
        var _emscripten_glUniform2f = _glUniform2f;
        _emscripten_glUniform2f.sig = "viff";
        var _glUniform2fv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform2fv(webglGetUniformLocation(e), GROWABLE_HEAP_F32(), r >> 2, 2 * t);
                return
            }
            if (t <= 144) {
                for (var i = miniTempWebGLFloatBuffers[2 * t - 1], n = 0; n < 2 * t; n += 2)
                    i[n] = GROWABLE_HEAP_F32()[r + 4 * n >> 2],
                    i[n + 1] = GROWABLE_HEAP_F32()[r + (4 * n + 4) >> 2]
            } else
                var i = GROWABLE_HEAP_F32().subarray(r >> 2, r + 8 * t >> 2);
            GLctx.uniform2fv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform2fv.sig = "viip";
        var _emscripten_glUniform2fv = _glUniform2fv;
        _emscripten_glUniform2fv.sig = "viip";
        var _glUniform2i = (e, t, r) => {
            GLctx.uniform2i(webglGetUniformLocation(e), t, r)
        }
        ;
        _glUniform2i.sig = "viii";
        var _emscripten_glUniform2i = _glUniform2i;
        _emscripten_glUniform2i.sig = "viii";
        var _glUniform2iv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform2iv(webglGetUniformLocation(e), GROWABLE_HEAP_I32(), r >> 2, 2 * t);
                return
            }
            if (t <= 144) {
                for (var i = miniTempWebGLIntBuffers[2 * t - 1], n = 0; n < 2 * t; n += 2)
                    i[n] = GROWABLE_HEAP_I32()[r + 4 * n >> 2],
                    i[n + 1] = GROWABLE_HEAP_I32()[r + (4 * n + 4) >> 2]
            } else
                var i = GROWABLE_HEAP_I32().subarray(r >> 2, r + 8 * t >> 2);
            GLctx.uniform2iv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform2iv.sig = "viip";
        var _emscripten_glUniform2iv = _glUniform2iv;
        _emscripten_glUniform2iv.sig = "viip";
        var _glUniform2ui = (e, t, r) => {
            GLctx.uniform2ui(webglGetUniformLocation(e), t, r)
        }
        ;
        _glUniform2ui.sig = "viii";
        var _emscripten_glUniform2ui = _glUniform2ui;
        _emscripten_glUniform2ui.sig = "viii";
        var _glUniform2uiv = (e, t, r) => {
            t && GLctx.uniform2uiv(webglGetUniformLocation(e), GROWABLE_HEAP_U32(), r >> 2, 2 * t)
        }
        ;
        _glUniform2uiv.sig = "viip";
        var _emscripten_glUniform2uiv = _glUniform2uiv;
        _emscripten_glUniform2uiv.sig = "viip";
        var _glUniform3f = (e, t, r, i) => {
            GLctx.uniform3f(webglGetUniformLocation(e), t, r, i)
        }
        ;
        _glUniform3f.sig = "vifff";
        var _emscripten_glUniform3f = _glUniform3f;
        _emscripten_glUniform3f.sig = "vifff";
        var _glUniform3fv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform3fv(webglGetUniformLocation(e), GROWABLE_HEAP_F32(), r >> 2, 3 * t);
                return
            }
            if (t <= 96) {
                for (var i = miniTempWebGLFloatBuffers[3 * t - 1], n = 0; n < 3 * t; n += 3)
                    i[n] = GROWABLE_HEAP_F32()[r + 4 * n >> 2],
                    i[n + 1] = GROWABLE_HEAP_F32()[r + (4 * n + 4) >> 2],
                    i[n + 2] = GROWABLE_HEAP_F32()[r + (4 * n + 8) >> 2]
            } else
                var i = GROWABLE_HEAP_F32().subarray(r >> 2, r + 12 * t >> 2);
            GLctx.uniform3fv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform3fv.sig = "viip";
        var _emscripten_glUniform3fv = _glUniform3fv;
        _emscripten_glUniform3fv.sig = "viip";
        var _glUniform3i = (e, t, r, i) => {
            GLctx.uniform3i(webglGetUniformLocation(e), t, r, i)
        }
        ;
        _glUniform3i.sig = "viiii";
        var _emscripten_glUniform3i = _glUniform3i;
        _emscripten_glUniform3i.sig = "viiii";
        var _glUniform3iv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform3iv(webglGetUniformLocation(e), GROWABLE_HEAP_I32(), r >> 2, 3 * t);
                return
            }
            if (t <= 96) {
                for (var i = miniTempWebGLIntBuffers[3 * t - 1], n = 0; n < 3 * t; n += 3)
                    i[n] = GROWABLE_HEAP_I32()[r + 4 * n >> 2],
                    i[n + 1] = GROWABLE_HEAP_I32()[r + (4 * n + 4) >> 2],
                    i[n + 2] = GROWABLE_HEAP_I32()[r + (4 * n + 8) >> 2]
            } else
                var i = GROWABLE_HEAP_I32().subarray(r >> 2, r + 12 * t >> 2);
            GLctx.uniform3iv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform3iv.sig = "viip";
        var _emscripten_glUniform3iv = _glUniform3iv;
        _emscripten_glUniform3iv.sig = "viip";
        var _glUniform3ui = (e, t, r, i) => {
            GLctx.uniform3ui(webglGetUniformLocation(e), t, r, i)
        }
        ;
        _glUniform3ui.sig = "viiii";
        var _emscripten_glUniform3ui = _glUniform3ui;
        _emscripten_glUniform3ui.sig = "viiii";
        var _glUniform3uiv = (e, t, r) => {
            t && GLctx.uniform3uiv(webglGetUniformLocation(e), GROWABLE_HEAP_U32(), r >> 2, 3 * t)
        }
        ;
        _glUniform3uiv.sig = "viip";
        var _emscripten_glUniform3uiv = _glUniform3uiv;
        _emscripten_glUniform3uiv.sig = "viip";
        var _glUniform4f = (e, t, r, i, n) => {
            GLctx.uniform4f(webglGetUniformLocation(e), t, r, i, n)
        }
        ;
        _glUniform4f.sig = "viffff";
        var _emscripten_glUniform4f = _glUniform4f;
        _emscripten_glUniform4f.sig = "viffff";
        var _glUniform4fv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform4fv(webglGetUniformLocation(e), GROWABLE_HEAP_F32(), r >> 2, 4 * t);
                return
            }
            if (t <= 72) {
                var i = miniTempWebGLFloatBuffers[4 * t - 1]
                  , n = GROWABLE_HEAP_F32();
                r >>= 2;
                for (var o = 0; o < 4 * t; o += 4) {
                    var a = r + o;
                    i[o] = n[a],
                    i[o + 1] = n[a + 1],
                    i[o + 2] = n[a + 2],
                    i[o + 3] = n[a + 3]
                }
            } else
                var i = GROWABLE_HEAP_F32().subarray(r >> 2, r + 16 * t >> 2);
            GLctx.uniform4fv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform4fv.sig = "viip";
        var _emscripten_glUniform4fv = _glUniform4fv;
        _emscripten_glUniform4fv.sig = "viip";
        var _glUniform4i = (e, t, r, i, n) => {
            GLctx.uniform4i(webglGetUniformLocation(e), t, r, i, n)
        }
        ;
        _glUniform4i.sig = "viiiii";
        var _emscripten_glUniform4i = _glUniform4i;
        _emscripten_glUniform4i.sig = "viiiii";
        var _glUniform4iv = (e, t, r) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniform4iv(webglGetUniformLocation(e), GROWABLE_HEAP_I32(), r >> 2, 4 * t);
                return
            }
            if (t <= 72) {
                for (var i = miniTempWebGLIntBuffers[4 * t - 1], n = 0; n < 4 * t; n += 4)
                    i[n] = GROWABLE_HEAP_I32()[r + 4 * n >> 2],
                    i[n + 1] = GROWABLE_HEAP_I32()[r + (4 * n + 4) >> 2],
                    i[n + 2] = GROWABLE_HEAP_I32()[r + (4 * n + 8) >> 2],
                    i[n + 3] = GROWABLE_HEAP_I32()[r + (4 * n + 12) >> 2]
            } else
                var i = GROWABLE_HEAP_I32().subarray(r >> 2, r + 16 * t >> 2);
            GLctx.uniform4iv(webglGetUniformLocation(e), i)
        }
        ;
        _glUniform4iv.sig = "viip";
        var _emscripten_glUniform4iv = _glUniform4iv;
        _emscripten_glUniform4iv.sig = "viip";
        var _glUniform4ui = (e, t, r, i, n) => {
            GLctx.uniform4ui(webglGetUniformLocation(e), t, r, i, n)
        }
        ;
        _glUniform4ui.sig = "viiiii";
        var _emscripten_glUniform4ui = _glUniform4ui;
        _emscripten_glUniform4ui.sig = "viiiii";
        var _glUniform4uiv = (e, t, r) => {
            t && GLctx.uniform4uiv(webglGetUniformLocation(e), GROWABLE_HEAP_U32(), r >> 2, 4 * t)
        }
        ;
        _glUniform4uiv.sig = "viip";
        var _emscripten_glUniform4uiv = _glUniform4uiv;
        _emscripten_glUniform4uiv.sig = "viip";
        var _glUniformBlockBinding = (e, t, r) => {
            e = GL.programs[e],
            GLctx.uniformBlockBinding(e, t, r)
        }
        ;
        _glUniformBlockBinding.sig = "viii";
        var _emscripten_glUniformBlockBinding = _glUniformBlockBinding;
        _emscripten_glUniformBlockBinding.sig = "viii";
        var _glUniformMatrix2fv = (e, t, r, i) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniformMatrix2fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 4 * t);
                return
            }
            if (t <= 72) {
                for (var n = miniTempWebGLFloatBuffers[4 * t - 1], o = 0; o < 4 * t; o += 4)
                    n[o] = GROWABLE_HEAP_F32()[i + 4 * o >> 2],
                    n[o + 1] = GROWABLE_HEAP_F32()[i + (4 * o + 4) >> 2],
                    n[o + 2] = GROWABLE_HEAP_F32()[i + (4 * o + 8) >> 2],
                    n[o + 3] = GROWABLE_HEAP_F32()[i + (4 * o + 12) >> 2]
            } else
                var n = GROWABLE_HEAP_F32().subarray(i >> 2, i + 16 * t >> 2);
            GLctx.uniformMatrix2fv(webglGetUniformLocation(e), !!r, n)
        }
        ;
        _glUniformMatrix2fv.sig = "viiip";
        var _emscripten_glUniformMatrix2fv = _glUniformMatrix2fv;
        _emscripten_glUniformMatrix2fv.sig = "viiip";
        var _glUniformMatrix2x3fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix2x3fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 6 * t)
        }
        ;
        _glUniformMatrix2x3fv.sig = "viiip";
        var _emscripten_glUniformMatrix2x3fv = _glUniformMatrix2x3fv;
        _emscripten_glUniformMatrix2x3fv.sig = "viiip";
        var _glUniformMatrix2x4fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix2x4fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 8 * t)
        }
        ;
        _glUniformMatrix2x4fv.sig = "viiip";
        var _emscripten_glUniformMatrix2x4fv = _glUniformMatrix2x4fv;
        _emscripten_glUniformMatrix2x4fv.sig = "viiip";
        var _glUniformMatrix3fv = (e, t, r, i) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniformMatrix3fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 9 * t);
                return
            }
            if (t <= 32) {
                for (var n = miniTempWebGLFloatBuffers[9 * t - 1], o = 0; o < 9 * t; o += 9)
                    n[o] = GROWABLE_HEAP_F32()[i + 4 * o >> 2],
                    n[o + 1] = GROWABLE_HEAP_F32()[i + (4 * o + 4) >> 2],
                    n[o + 2] = GROWABLE_HEAP_F32()[i + (4 * o + 8) >> 2],
                    n[o + 3] = GROWABLE_HEAP_F32()[i + (4 * o + 12) >> 2],
                    n[o + 4] = GROWABLE_HEAP_F32()[i + (4 * o + 16) >> 2],
                    n[o + 5] = GROWABLE_HEAP_F32()[i + (4 * o + 20) >> 2],
                    n[o + 6] = GROWABLE_HEAP_F32()[i + (4 * o + 24) >> 2],
                    n[o + 7] = GROWABLE_HEAP_F32()[i + (4 * o + 28) >> 2],
                    n[o + 8] = GROWABLE_HEAP_F32()[i + (4 * o + 32) >> 2]
            } else
                var n = GROWABLE_HEAP_F32().subarray(i >> 2, i + 36 * t >> 2);
            GLctx.uniformMatrix3fv(webglGetUniformLocation(e), !!r, n)
        }
        ;
        _glUniformMatrix3fv.sig = "viiip";
        var _emscripten_glUniformMatrix3fv = _glUniformMatrix3fv;
        _emscripten_glUniformMatrix3fv.sig = "viiip";
        var _glUniformMatrix3x2fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix3x2fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 6 * t)
        }
        ;
        _glUniformMatrix3x2fv.sig = "viiip";
        var _emscripten_glUniformMatrix3x2fv = _glUniformMatrix3x2fv;
        _emscripten_glUniformMatrix3x2fv.sig = "viiip";
        var _glUniformMatrix3x4fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix3x4fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 12 * t)
        }
        ;
        _glUniformMatrix3x4fv.sig = "viiip";
        var _emscripten_glUniformMatrix3x4fv = _glUniformMatrix3x4fv;
        _emscripten_glUniformMatrix3x4fv.sig = "viiip";
        var _glUniformMatrix4fv = (e, t, r, i) => {
            if (GL.currentContext.version >= 2) {
                t && GLctx.uniformMatrix4fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 16 * t);
                return
            }
            if (t <= 18) {
                var n = miniTempWebGLFloatBuffers[16 * t - 1]
                  , o = GROWABLE_HEAP_F32();
                i >>= 2;
                for (var a = 0; a < 16 * t; a += 16) {
                    var s = i + a;
                    n[a] = o[s],
                    n[a + 1] = o[s + 1],
                    n[a + 2] = o[s + 2],
                    n[a + 3] = o[s + 3],
                    n[a + 4] = o[s + 4],
                    n[a + 5] = o[s + 5],
                    n[a + 6] = o[s + 6],
                    n[a + 7] = o[s + 7],
                    n[a + 8] = o[s + 8],
                    n[a + 9] = o[s + 9],
                    n[a + 10] = o[s + 10],
                    n[a + 11] = o[s + 11],
                    n[a + 12] = o[s + 12],
                    n[a + 13] = o[s + 13],
                    n[a + 14] = o[s + 14],
                    n[a + 15] = o[s + 15]
                }
            } else
                var n = GROWABLE_HEAP_F32().subarray(i >> 2, i + 64 * t >> 2);
            GLctx.uniformMatrix4fv(webglGetUniformLocation(e), !!r, n)
        }
        ;
        _glUniformMatrix4fv.sig = "viiip";
        var _emscripten_glUniformMatrix4fv = _glUniformMatrix4fv;
        _emscripten_glUniformMatrix4fv.sig = "viiip";
        var _glUniformMatrix4x2fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix4x2fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 8 * t)
        }
        ;
        _glUniformMatrix4x2fv.sig = "viiip";
        var _emscripten_glUniformMatrix4x2fv = _glUniformMatrix4x2fv;
        _emscripten_glUniformMatrix4x2fv.sig = "viiip";
        var _glUniformMatrix4x3fv = (e, t, r, i) => {
            t && GLctx.uniformMatrix4x3fv(webglGetUniformLocation(e), !!r, GROWABLE_HEAP_F32(), i >> 2, 12 * t)
        }
        ;
        _glUniformMatrix4x3fv.sig = "viiip";
        var _emscripten_glUniformMatrix4x3fv = _glUniformMatrix4x3fv;
        _emscripten_glUniformMatrix4x3fv.sig = "viiip";
        var _glUnmapBuffer = e => {
            if (!emscriptenWebGLValidateMapBufferTarget(e))
                return GL.recordError(1280),
                err("GL_INVALID_ENUM in glUnmapBuffer"),
                0;
            var t = emscriptenWebGLGetBufferBinding(e)
              , r = GL.mappedBuffers[t];
            return r && r.mem ? (!(16 & r.access) && (GL.currentContext.version >= 2 ? GLctx.bufferSubData(e, r.offset, GROWABLE_HEAP_U8(), r.mem, r.length) : GLctx.bufferSubData(e, r.offset, GROWABLE_HEAP_U8().subarray(r.mem, r.mem + r.length))),
            _free(r.mem),
            r.mem = 0,
            1) : (GL.recordError(1282),
            err("buffer was never mapped in glUnmapBuffer"),
            0)
        }
        ;
        _glUnmapBuffer.sig = "ii";
        var _emscripten_glUnmapBuffer = _glUnmapBuffer;
        _emscripten_glUnmapBuffer.sig = "ii";
        var _glUseProgram = e => {
            e = GL.programs[e],
            GLctx.useProgram(e),
            GLctx.currentProgram = e
        }
        ;
        _glUseProgram.sig = "vi";
        var _emscripten_glUseProgram = _glUseProgram;
        _emscripten_glUseProgram.sig = "vi";
        var _glValidateProgram = e => {
            GLctx.validateProgram(GL.programs[e])
        }
        ;
        _glValidateProgram.sig = "vi";
        var _emscripten_glValidateProgram = _glValidateProgram;
        _emscripten_glValidateProgram.sig = "vi";
        var _glVertexAttrib1f = (e, t) => GLctx.vertexAttrib1f(e, t);
        _glVertexAttrib1f.sig = "vif";
        var _emscripten_glVertexAttrib1f = _glVertexAttrib1f;
        _emscripten_glVertexAttrib1f.sig = "vif";
        var _glVertexAttrib1fv = (e, t) => {
            GLctx.vertexAttrib1f(e, GROWABLE_HEAP_F32()[t >> 2])
        }
        ;
        _glVertexAttrib1fv.sig = "vip";
        var _emscripten_glVertexAttrib1fv = _glVertexAttrib1fv;
        _emscripten_glVertexAttrib1fv.sig = "vip";
        var _glVertexAttrib2f = (e, t, r) => GLctx.vertexAttrib2f(e, t, r);
        _glVertexAttrib2f.sig = "viff";
        var _emscripten_glVertexAttrib2f = _glVertexAttrib2f;
        _emscripten_glVertexAttrib2f.sig = "viff";
        var _glVertexAttrib2fv = (e, t) => {
            GLctx.vertexAttrib2f(e, GROWABLE_HEAP_F32()[t >> 2], GROWABLE_HEAP_F32()[t + 4 >> 2])
        }
        ;
        _glVertexAttrib2fv.sig = "vip";
        var _emscripten_glVertexAttrib2fv = _glVertexAttrib2fv;
        _emscripten_glVertexAttrib2fv.sig = "vip";
        var _glVertexAttrib3f = (e, t, r, i) => GLctx.vertexAttrib3f(e, t, r, i);
        _glVertexAttrib3f.sig = "vifff";
        var _emscripten_glVertexAttrib3f = _glVertexAttrib3f;
        _emscripten_glVertexAttrib3f.sig = "vifff";
        var _glVertexAttrib3fv = (e, t) => {
            GLctx.vertexAttrib3f(e, GROWABLE_HEAP_F32()[t >> 2], GROWABLE_HEAP_F32()[t + 4 >> 2], GROWABLE_HEAP_F32()[t + 8 >> 2])
        }
        ;
        _glVertexAttrib3fv.sig = "vip";
        var _emscripten_glVertexAttrib3fv = _glVertexAttrib3fv;
        _emscripten_glVertexAttrib3fv.sig = "vip";
        var _glVertexAttrib4f = (e, t, r, i, n) => GLctx.vertexAttrib4f(e, t, r, i, n);
        _glVertexAttrib4f.sig = "viffff";
        var _emscripten_glVertexAttrib4f = _glVertexAttrib4f;
        _emscripten_glVertexAttrib4f.sig = "viffff";
        var _glVertexAttrib4fv = (e, t) => {
            GLctx.vertexAttrib4f(e, GROWABLE_HEAP_F32()[t >> 2], GROWABLE_HEAP_F32()[t + 4 >> 2], GROWABLE_HEAP_F32()[t + 8 >> 2], GROWABLE_HEAP_F32()[t + 12 >> 2])
        }
        ;
        _glVertexAttrib4fv.sig = "vip";
        var _emscripten_glVertexAttrib4fv = _glVertexAttrib4fv;
        _emscripten_glVertexAttrib4fv.sig = "vip";
        var _glVertexAttribDivisor = (e, t) => {
            GLctx.vertexAttribDivisor(e, t)
        }
        ;
        _glVertexAttribDivisor.sig = "vii";
        var _emscripten_glVertexAttribDivisor = _glVertexAttribDivisor;
        _emscripten_glVertexAttribDivisor.sig = "vii";
        var _glVertexAttribDivisorANGLE = _glVertexAttribDivisor
          , _emscripten_glVertexAttribDivisorANGLE = _glVertexAttribDivisorANGLE
          , _glVertexAttribDivisorARB = _glVertexAttribDivisor
          , _emscripten_glVertexAttribDivisorARB = _glVertexAttribDivisorARB
          , _glVertexAttribDivisorEXT = _glVertexAttribDivisor
          , _emscripten_glVertexAttribDivisorEXT = _glVertexAttribDivisorEXT
          , _glVertexAttribDivisorNV = _glVertexAttribDivisor
          , _emscripten_glVertexAttribDivisorNV = _glVertexAttribDivisorNV
          , _glVertexAttribI4i = (e, t, r, i, n) => GLctx.vertexAttribI4i(e, t, r, i, n);
        _glVertexAttribI4i.sig = "viiiii";
        var _emscripten_glVertexAttribI4i = _glVertexAttribI4i;
        _emscripten_glVertexAttribI4i.sig = "viiiii";
        var _glVertexAttribI4iv = (e, t) => {
            GLctx.vertexAttribI4i(e, GROWABLE_HEAP_I32()[t >> 2], GROWABLE_HEAP_I32()[t + 4 >> 2], GROWABLE_HEAP_I32()[t + 8 >> 2], GROWABLE_HEAP_I32()[t + 12 >> 2])
        }
        ;
        _glVertexAttribI4iv.sig = "vip";
        var _emscripten_glVertexAttribI4iv = _glVertexAttribI4iv;
        _emscripten_glVertexAttribI4iv.sig = "vip";
        var _glVertexAttribI4ui = (e, t, r, i, n) => GLctx.vertexAttribI4ui(e, t, r, i, n);
        _glVertexAttribI4ui.sig = "viiiii";
        var _emscripten_glVertexAttribI4ui = _glVertexAttribI4ui;
        _emscripten_glVertexAttribI4ui.sig = "viiiii";
        var _glVertexAttribI4uiv = (e, t) => {
            GLctx.vertexAttribI4ui(e, GROWABLE_HEAP_U32()[t >> 2], GROWABLE_HEAP_U32()[t + 4 >> 2], GROWABLE_HEAP_U32()[t + 8 >> 2], GROWABLE_HEAP_U32()[t + 12 >> 2])
        }
        ;
        _glVertexAttribI4uiv.sig = "vip";
        var _emscripten_glVertexAttribI4uiv = _glVertexAttribI4uiv;
        _emscripten_glVertexAttribI4uiv.sig = "vip";
        var _glVertexAttribIPointer = (e, t, r, i, n) => {
            var o = GL.currentContext.clientBuffers[e];
            if (!GLctx.currentArrayBufferBinding) {
                o.size = t,
                o.type = r,
                o.normalized = !1,
                o.stride = i,
                o.ptr = n,
                o.clientside = !0,
                o.vertexAttribPointerAdaptor = function(e, t, r, i, n, o) {
                    this.vertexAttribIPointer(e, t, r, n, o)
                }
                ;
                return
            }
            o.clientside = !1,
            GLctx.vertexAttribIPointer(e, t, r, i, n)
        }
        ;
        _glVertexAttribIPointer.sig = "viiiip";
        var _emscripten_glVertexAttribIPointer = _glVertexAttribIPointer;
        _emscripten_glVertexAttribIPointer.sig = "viiiip";
        var _glVertexAttribPointer = (e, t, r, i, n, o) => {
            var a = GL.currentContext.clientBuffers[e];
            if (!GLctx.currentArrayBufferBinding) {
                a.size = t,
                a.type = r,
                a.normalized = i,
                a.stride = n,
                a.ptr = o,
                a.clientside = !0,
                a.vertexAttribPointerAdaptor = function(e, t, r, i, n, o) {
                    this.vertexAttribPointer(e, t, r, i, n, o)
                }
                ;
                return
            }
            a.clientside = !1,
            GLctx.vertexAttribPointer(e, t, r, !!i, n, o)
        }
        ;
        _glVertexAttribPointer.sig = "viiiiip";
        var _emscripten_glVertexAttribPointer = _glVertexAttribPointer;
        _emscripten_glVertexAttribPointer.sig = "viiiiip";
        var _glViewport = (e, t, r, i) => GLctx.viewport(e, t, r, i);
        _glViewport.sig = "viiii";
        var _emscripten_glViewport = _glViewport;
        _emscripten_glViewport.sig = "viiii";
        var _glWaitSync = (e, t, r) => {
            r = Number(r),
            GLctx.waitSync(GL.syncs[e], t, r)
        }
        ;
        _glWaitSync.sig = "vpij";
        var _emscripten_glWaitSync = _glWaitSync;
        _emscripten_glWaitSync.sig = "vpij";
        var _emscripten_has_threading_support = () => "undefined" != typeof SharedArrayBuffer;
        _emscripten_has_threading_support.sig = "i";
        var reallyNegative = e => e < 0 || 0 === e && 1 / e == -1 / 0
          , convertI32PairToI53 = (e, t) => (e >>> 0) + 0x100000000 * t
          , convertU32PairToI53 = (e, t) => (e >>> 0) + (t >>> 0) * 0x100000000
          , reSign = (e, t) => {
            if (e <= 0)
                return e;
            var r = t <= 32 ? Math.abs(1 << t - 1) : Math.pow(2, t - 1);
            return e >= r && (t <= 32 || e > r) && (e = -2 * r + e),
            e
        }
          , unSign = (e, t) => e >= 0 ? e : t <= 32 ? 2 * Math.abs(1 << t - 1) + e : Math.pow(2, t) + e
          , strLen = e => {
            for (var t = e; GROWABLE_HEAP_U8()[t]; )
                ++t;
            return t - e
        }
          , formatString = (e, t) => {
            var r = e
              , i = t;
            function n(e, t) {
                return ("double" === t || "i64" === t) && 7 & e && (e += 4),
                e
            }
            function o(e) {
                var t;
                return i = n(i, e),
                "double" === e ? (t = GROWABLE_HEAP_F64()[i >> 3],
                i += 8) : "i64" == e ? (t = [GROWABLE_HEAP_I32()[i >> 2], GROWABLE_HEAP_I32()[i + 4 >> 2]],
                i += 8) : (e = "i32",
                t = GROWABLE_HEAP_I32()[i >> 2],
                i += 4),
                t
            }
            for (var a = []; ; ) {
                var s = r;
                if (0 === (v = GROWABLE_HEAP_I8()[r]))
                    break;
                if (x = GROWABLE_HEAP_I8()[r + 1],
                37 == v) {
                    var u = !1
                      , l = !1
                      , c = !1
                      , p = !1
                      , d = !1;
                    e: for (; ; ) {
                        switch (x) {
                        case 43:
                            u = !0;
                            break;
                        case 45:
                            l = !0;
                            break;
                        case 35:
                            c = !0;
                            break;
                        case 48:
                            if (p)
                                break e;
                            p = !0;
                            break;
                        case 32:
                            d = !0;
                            break;
                        default:
                            break e
                        }
                        r++,
                        x = GROWABLE_HEAP_I8()[r + 1]
                    }
                    var f = 0;
                    if (42 == x)
                        f = o("i32"),
                        r++,
                        x = GROWABLE_HEAP_I8()[r + 1];
                    else
                        for (; x >= 48 && x <= 57; )
                            f = 10 * f + (x - 48),
                            r++,
                            x = GROWABLE_HEAP_I8()[r + 1];
                    var m = !1
                      , h = -1;
                    if (46 == x) {
                        if (h = 0,
                        m = !0,
                        r++,
                        42 == (x = GROWABLE_HEAP_I8()[r + 1]))
                            h = o("i32"),
                            r++;
                        else
                            for (; ; ) {
                                var g = GROWABLE_HEAP_I8()[r + 1];
                                if (g < 48 || g > 57)
                                    break;
                                h = 10 * h + (g - 48),
                                r++
                            }
                        x = GROWABLE_HEAP_I8()[r + 1]
                    }
                    switch (h < 0 && (h = 6,
                    m = !1),
                    String.fromCharCode(x)) {
                    case "h":
                        var _ = GROWABLE_HEAP_I8()[r + 2];
                        104 == _ ? (r++,
                        y = 1) : y = 2;
                        break;
                    case "l":
                        var _ = GROWABLE_HEAP_I8()[r + 2];
                        108 == _ ? (r++,
                        y = 8) : y = 4;
                        break;
                    case "L":
                    case "q":
                    case "j":
                        y = 8;
                        break;
                    case "z":
                    case "t":
                    case "I":
                        y = 4;
                        break;
                    default:
                        y = null
                    }
                    switch (y && r++,
                    String.fromCharCode(x = GROWABLE_HEAP_I8()[r + 1])) {
                    case "d":
                    case "i":
                    case "u":
                    case "o":
                    case "x":
                    case "X":
                    case "p":
                        var v, x, b, y, w, T = 100 == x || 105 == x;
                        b = o("i" + 8 * (y = y || 4)),
                        8 == y && (b = 117 == x ? convertU32PairToI53(b[0], b[1]) : convertI32PairToI53(b[0], b[1])),
                        y <= 4 && (b = (T ? reSign : unSign)(b & Math.pow(256, y) - 1, 8 * y));
                        var S = Math.abs(b)
                          , C = "";
                        if (100 == x || 105 == x)
                            w = reSign(b, 8 * y).toString(10);
                        else if (117 == x)
                            w = unSign(b, 8 * y).toString(10),
                            b = Math.abs(b);
                        else if (111 == x)
                            w = (c ? "0" : "") + S.toString(8);
                        else if (120 == x || 88 == x) {
                            if (C = c && 0 != b ? "0x" : "",
                            b < 0) {
                                b = -b,
                                w = (S - 1).toString(16);
                                for (var E = [], I = 0; I < w.length; I++)
                                    E.push((15 - parseInt(w[I], 16)).toString(16));
                                for (w = E.join(""); w.length < 2 * y; )
                                    w = "f" + w
                            } else
                                w = S.toString(16);
                            88 == x && (C = C.toUpperCase(),
                            w = w.toUpperCase())
                        } else
                            112 == x && (0 === S ? w = "(nil)" : (C = "0x",
                            w = S.toString(16)));
                        if (m)
                            for (; w.length < h; )
                                w = "0" + w;
                        for (b >= 0 && (u ? C = "+" + C : d && (C = " " + C)),
                        "-" == w.charAt(0) && (C = "-" + C,
                        w = w.substr(1)); C.length + w.length < f; )
                            l ? w += " " : p ? w = "0" + w : C = " " + C;
                        (w = C + w).split("").forEach(function(e) {
                            a.push(e.charCodeAt(0))
                        });
                        break;
                    case "f":
                    case "F":
                    case "e":
                    case "E":
                    case "g":
                    case "G":
                        if (isNaN(b = o("double")))
                            w = "nan",
                            p = !1;
                        else if (isFinite(b)) {
                            var w, F = !1, L = Math.min(h, 20);
                            if (103 == x || 71 == x) {
                                F = !0,
                                h = h || 1;
                                var P = parseInt(b.toExponential(L).split("e")[1], 10);
                                h > P && P >= -4 ? (x = (103 == x ? "f" : "F").charCodeAt(0),
                                h -= P + 1) : (x = (103 == x ? "e" : "E").charCodeAt(0),
                                h--),
                                L = Math.min(h, 20)
                            }
                            101 == x || 69 == x ? (w = b.toExponential(L),
                            /[eE][-+]\d$/.test(w) && (w = w.slice(0, -1) + "0" + w.slice(-1))) : (102 == x || 70 == x) && (w = b.toFixed(L),
                            0 === b && reallyNegative(b) && (w = "-" + w));
                            var D = w.split("e");
                            if (F && !c)
                                for (; D[0].length > 1 && D[0].includes(".") && ("0" == D[0].slice(-1) || "." == D[0].slice(-1)); )
                                    D[0] = D[0].slice(0, -1);
                            else
                                for (c && -1 == w.indexOf(".") && (D[0] += "."); h > L++; )
                                    D[0] += "0";
                            w = D[0] + (D.length > 1 ? "e" + D[1] : ""),
                            69 == x && (w = w.toUpperCase()),
                            b >= 0 && (u ? w = "+" + w : d && (w = " " + w))
                        } else
                            w = (b < 0 ? "-" : "") + "inf",
                            p = !1;
                        for (; w.length < f; )
                            l ? w += " " : w = p && ("-" == w[0] || "+" == w[0]) ? w[0] + "0" + w.slice(1) : (p ? "0" : " ") + w;
                        x < 97 && (w = w.toUpperCase()),
                        w.split("").forEach(function(e) {
                            a.push(e.charCodeAt(0))
                        });
                        break;
                    case "s":
                        var $ = o("i8*")
                          , k = $ ? strLen($) : 6;
                        if (m && (k = Math.min(k, h)),
                        !l)
                            for (; k < f--; )
                                a.push(32);
                        if ($)
                            for (var I = 0; I < k; I++)
                                a.push(GROWABLE_HEAP_U8()[$++]);
                        else
                            a = a.concat(intArrayFromString("(null)".substr(0, k), !0));
                        if (l)
                            for (; k < f--; )
                                a.push(32);
                        break;
                    case "c":
                        for (l && a.push(o("i8")); --f > 0; )
                            a.push(32);
                        !l && a.push(o("i8"));
                        break;
                    case "n":
                        var A = o("i32*");
                        GROWABLE_HEAP_I32()[A >> 2] = a.length;
                        break;
                    case "%":
                        a.push(v);
                        break;
                    default:
                        for (var I = s; I < r + 2; I++)
                            a.push(GROWABLE_HEAP_I8()[I])
                    }
                    r += 2
                } else
                    a.push(v),
                    r += 1
            }
            return a
        }
        ;
        function jsStackTrace() {
            var e = Error();
            if (!e.stack) {
                try {
                    throw Error()
                } catch (t) {
                    e = t
                }
                if (!e.stack)
                    return "(no stack trace available)"
            }
            return e.stack.toString()
        }
        function getCallstack(e) {
            var t = jsStackTrace()
              , r = t.lastIndexOf("_emscripten_log")
              , i = t.lastIndexOf("_emscripten_get_callstack")
              , n = t.indexOf("\n", Math.max(r, i)) + 1;
            t = t.slice(n),
            8 & e && "undefined" == typeof emscripten_source_map && (warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.'),
            e ^= 8,
            e |= 16);
            var o = t.split("\n");
            t = "";
            var a = RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)")
              , s = RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?")
              , u = RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");
            for (var l in o) {
                var c = o[l]
                  , p = ""
                  , d = ""
                  , f = 0
                  , m = 0
                  , h = u.exec(c);
                if (h && 5 == h.length)
                    p = h[1],
                    d = h[2],
                    f = h[3],
                    m = h[4];
                else if (!(h = a.exec(c)) && (h = s.exec(c)),
                h && h.length >= 4)
                    p = h[1],
                    d = h[2],
                    f = h[3],
                    m = 0 | h[4];
                else {
                    t += c + "\n";
                    continue
                }
                var g = !1;
                if (8 & e) {
                    var _ = emscripten_source_map.originalPositionFor({
                        line: f,
                        column: m
                    });
                    (g = _?.source) && (64 & e && (_.source = _.source.substring(_.source.replace(/\\/g, "/").lastIndexOf("/") + 1)),
                    t += `    at ${p} (${_.source}:${_.line}:${_.column})
`)
                }
                (16 & e || !g) && (64 & e && (d = d.substring(d.replace(/\\/g, "/").lastIndexOf("/") + 1)),
                t += (g ? `     = ${p}` : `    at ${p}`) + ` (${d}:${f}:${m})
`)
            }
            return t = t.replace(/\s+$/, "")
        }
        var emscriptenLog = (e, t) => {
            24 & e && (t = t.replace(/\s+$/, ""),
            t += (t.length > 0 ? "\n" : "") + getCallstack(e)),
            1 & e ? 4 & e ? console.error(t) : 2 & e ? console.warn(t) : 512 & e ? console.info(t) : 256 & e ? console.debug(t) : console.log(t) : 6 & e ? err(t) : out(t)
        }
          , _emscripten_log = (e, t, r) => {
            emscriptenLog(e, UTF8ArrayToString(formatString(t, r), 0))
        }
        ;
        _emscripten_log.sig = "vipp";
        var _emscripten_num_logical_cores = () => navigator.hardwareConcurrency;
        _emscripten_num_logical_cores.sig = "i";
        var _emscripten_out = e => out(UTF8ToString(e));
        _emscripten_out.sig = "vp";
        var _emscripten_performance_now = () => performance.now();
        _emscripten_performance_now.sig = "d";
        class HandleAllocator {
            constructor() {
                this.allocated = [void 0],
                this.freelist = []
            }
            get(e) {
                return this.allocated[e]
            }
            has(e) {
                return void 0 !== this.allocated[e]
            }
            allocate(e) {
                var t = this.freelist.pop() || this.allocated.length;
                return this.allocated[t] = e,
                t
            }
            free(e) {
                this.allocated[e] = void 0,
                this.freelist.push(e)
            }
        }
        var promiseMap = new HandleAllocator
          , _emscripten_promise_destroy = e => {
            promiseMap.free(e)
        }
        ;
        _emscripten_promise_destroy.sig = "vp";
        var getPromise = e => promiseMap.get(e).promise
          , _emscripten_promise_resolve = (e, t, r) => {
            var i = promiseMap.get(e);
            switch (t) {
            case 0:
                i.resolve(r);
                return;
            case 1:
                i.resolve(getPromise(r));
                return;
            case 2:
                i.resolve(getPromise(r)),
                _emscripten_promise_destroy(r);
                return;
            case 3:
                i.reject(r);
                return
            }
        }
        ;
        _emscripten_promise_resolve.sig = "vpip";
        var growMemory = e => {
            var t = (e - wasmMemory.buffer.byteLength + 65535) / 65536;
            try {
                return wasmMemory.grow(t),
                updateMemoryViews(),
                1
            } catch (e) {}
        }
          , _emscripten_resize_heap = e => {
            var t = GROWABLE_HEAP_U8().length;
            if ((e >>>= 0) <= t)
                return !1;
            var r = getHeapMax();
            if (e > r)
                return !1;
            for (var i = (e, t) => e + (t - e % t) % t, n = 1; n <= 4; n *= 2) {
                var o = t * (1 + .2 / n);
                if (o = Math.min(o, e + 0x6000000),
                growMemory(Math.min(r, i(Math.max(e, o), 65536))))
                    return !0
            }
            return !1
        }
        ;
        _emscripten_resize_heap.sig = "ip";
        var _emscripten_set_main_loop_arg = (e, t, r, i) => {
            setMainLoop( () => getWasmTableEntry(e)(t), r, i, t)
        }
        ;
        _emscripten_set_main_loop_arg.sig = "vppii";
        var _emscripten_supports_offscreencanvas = () => "undefined" != typeof OffscreenCanvas;
        _emscripten_supports_offscreencanvas.sig = "i";
        var webglPowerPreferences = ["default", "low-power", "high-performance"]
          , _emscripten_webgl_do_create_context = (e, t) => {
            var r = t >> 2
              , i = GROWABLE_HEAP_I32()[r + 6]
              , n = {
                alpha: !!GROWABLE_HEAP_I32()[r + 0],
                depth: !!GROWABLE_HEAP_I32()[r + 1],
                stencil: !!GROWABLE_HEAP_I32()[r + 2],
                antialias: !!GROWABLE_HEAP_I32()[r + 3],
                premultipliedAlpha: !!GROWABLE_HEAP_I32()[r + 4],
                preserveDrawingBuffer: !!GROWABLE_HEAP_I32()[r + 5],
                powerPreference: webglPowerPreferences[i],
                failIfMajorPerformanceCaveat: !!GROWABLE_HEAP_I32()[r + 7],
                majorVersion: GROWABLE_HEAP_I32()[r + 8],
                minorVersion: GROWABLE_HEAP_I32()[r + 9],
                enableExtensionsByDefault: GROWABLE_HEAP_I32()[r + 10],
                explicitSwapControl: GROWABLE_HEAP_I32()[r + 11],
                proxyContextToMainThread: GROWABLE_HEAP_I32()[r + 12],
                renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[r + 13]
            }
              , o = findCanvasEventTarget(e);
            if (!o)
                return 0;
            if (o.offscreenCanvas && (o = o.offscreenCanvas),
            n.explicitSwapControl) {
                if (!(o.transferControlToOffscreen || _emscripten_supports_offscreencanvas() && o instanceof OffscreenCanvas))
                    return 0;
                if (o.transferControlToOffscreen) {
                    if (o.controlTransferredOffscreen) {
                        if (!GL.offscreenCanvases[o.id])
                            return 0
                    } else
                        GL.offscreenCanvases[o.id] = {
                            canvas: o.transferControlToOffscreen(),
                            canvasSharedPtr: _malloc(12),
                            id: o.id
                        },
                        o.controlTransferredOffscreen = !0;
                    o = GL.offscreenCanvases[o.id]
                }
            }
            return GL.createContext(o, n)
        }
        ;
        _emscripten_webgl_do_create_context.sig = "ppp";
        var _emscripten_webgl_create_context = _emscripten_webgl_do_create_context;
        _emscripten_webgl_create_context.sig = "ppp";
        var _emscripten_webgl_destroy_context_calling_thread = e => {
            GL.currentContext == e && (GL.currentContext = 0),
            GL.deleteContext(e)
        }
          , _emscripten_webgl_destroy_context_main_thread = _emscripten_webgl_destroy_context_calling_thread;
        function _emscripten_webgl_destroy_context(e) {
            return GL.contexts[e] ? _emscripten_webgl_destroy_context_calling_thread(e) : _emscripten_webgl_destroy_context_main_thread(e)
        }
        _emscripten_webgl_destroy_context_main_thread.sig = "ip",
        _emscripten_webgl_destroy_context.sig = "ip";
        var _emscripten_webgl_get_context_attributes_calling_thread = (e, t) => {
            if (!t)
                return -5;
            if (!(e = GL.contexts[e]))
                return -3;
            var r = e.GLctx;
            if (!r)
                return -3;
            r = r.getContextAttributes(),
            GROWABLE_HEAP_I32()[t >> 2] = r.alpha,
            GROWABLE_HEAP_I32()[t + 4 >> 2] = r.depth,
            GROWABLE_HEAP_I32()[t + 8 >> 2] = r.stencil,
            GROWABLE_HEAP_I32()[t + 12 >> 2] = r.antialias,
            GROWABLE_HEAP_I32()[t + 16 >> 2] = r.premultipliedAlpha,
            GROWABLE_HEAP_I32()[t + 20 >> 2] = r.preserveDrawingBuffer;
            var i = r.powerPreference && webglPowerPreferences.indexOf(r.powerPreference);
            return GROWABLE_HEAP_I32()[t + 24 >> 2] = i,
            GROWABLE_HEAP_I32()[t + 28 >> 2] = r.failIfMajorPerformanceCaveat,
            GROWABLE_HEAP_I32()[t + 32 >> 2] = e.version,
            GROWABLE_HEAP_I32()[t + 36 >> 2] = 0,
            GROWABLE_HEAP_I32()[t + 40 >> 2] = e.attributes.enableExtensionsByDefault,
            0
        }
          , _emscripten_webgl_get_context_attributes_main_thread = _emscripten_webgl_get_context_attributes_calling_thread;
        function _emscripten_webgl_get_context_attributes(e, t) {
            return GL.contexts[e] ? _emscripten_webgl_get_context_attributes_calling_thread(e, t) : _emscripten_webgl_get_context_attributes_main_thread(e, t)
        }
        _emscripten_webgl_get_context_attributes_main_thread.sig = "ipp",
        _emscripten_webgl_get_context_attributes.sig = "ipp";
        var _emscripten_webgl_do_get_current_context = () => GL.currentContext ? GL.currentContext.handle : 0;
        _emscripten_webgl_do_get_current_context.sig = "p";
        var _emscripten_webgl_get_current_context = _emscripten_webgl_do_get_current_context;
        _emscripten_webgl_get_current_context.sig = "p";
        var _emscripten_webgl_make_context_current = e => GL.makeContextCurrent(e) ? 0 : -5;
        _emscripten_webgl_make_context_current.sig = "ip";
        var getExecutableName = () => thisProgram || "./this.program"
          , getEnvStrings = () => {
            if (!getEnvStrings.strings) {
                var e = {
                    USER: "web_user",
                    LOGNAME: "web_user",
                    PATH: "/",
                    PWD: "/",
                    HOME: "/home/web_user",
                    LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                    _: getExecutableName()
                };
                for (var t in ENV)
                    void 0 === ENV[t] ? delete e[t] : e[t] = ENV[t];
                var r = [];
                for (var t in e)
                    r.push(`${t}=${e[t]}`);
                getEnvStrings.strings = r
            }
            return getEnvStrings.strings
        }
          , stringToAscii = (e, t) => {
            for (var r = 0; r < e.length; ++r)
                GROWABLE_HEAP_I8()[t++] = e.charCodeAt(r);
            GROWABLE_HEAP_I8()[t] = 0
        }
          , _environ_get = function(e, t) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(16, 0, 1, e, t);
            var r = 0;
            return getEnvStrings().forEach( (i, n) => {
                var o = t + r;
                GROWABLE_HEAP_U32()[e + 4 * n >> 2] = o,
                stringToAscii(i, o),
                r += i.length + 1
            }
            ),
            0
        };
        _environ_get.sig = "ipp";
        var _environ_sizes_get = function(e, t) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(17, 0, 1, e, t);
            var r = getEnvStrings();
            GROWABLE_HEAP_U32()[e >> 2] = r.length;
            var i = 0;
            return r.forEach(e => i += e.length + 1),
            GROWABLE_HEAP_U32()[t >> 2] = i,
            0
        };
        function _ff_h2645_packet_split(...e) {
            return wasmImports.ff_h2645_packet_split(...e)
        }
        function _ff_h2645_packet_uninit(...e) {
            return wasmImports.ff_h2645_packet_uninit(...e)
        }
        _environ_sizes_get.sig = "ipp",
        _ff_h2645_packet_split.stub = !0,
        _ff_h2645_packet_uninit.stub = !0;
        var initRandomFill = () => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
                return e => (e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),
                e);
            abort("initRandomDevice")
        }
          , randomFill = e => (randomFill = initRandomFill())(e)
          , _getentropy = (e, t) => (randomFill(GROWABLE_HEAP_U8().subarray(e, e + t)),
        0);
        function _isSafari() {
            let e = window.chrome
              , t = navigator.userAgent.indexOf("Edg") > -1
              , r = navigator.userAgent.indexOf("Macintosh") > -1;
            return navigator.userAgent.match(/(Safari|AppleWebKit)/) && null === navigator.userAgent.match(/(Chrome|Chromium|Edg)/) && r && !e && !t
        }
        function _isWebCodecSupported() {
            return "function" == typeof VideoDecoder
        }
        _getentropy.sig = "ipp",
        _isSafari.sig = "i",
        _isWebCodecSupported.sig = "i";
        var vesdk_task_map = {};
        function _lv_api_callback_to_main_thread(e, t, r, i) {
            if (ENVIRONMENT_IS_WORKER) {
                var n = Emval.toValue(i);
                n && null != n && void 0 !== n.rc && null !== n.rc && (4101 === n.rc || 4097 === n.rc) && (n.p_origin = performance.timeOrigin,
                n.p_now = performance.now()),
                postMessage({
                    cmd: "vesdk_info_callback",
                    cbClass: UTF8ToString(e),
                    cbFunc: UTF8ToString(t),
                    listenerId: r,
                    data: Emval.toValue(i)
                })
            } else {
                var o = Module.vesdk_info_callback_hub;
                if (!o) {
                    console.warn("callback hub not set");
                    return
                }
                o(UTF8ToString(e), UTF8ToString(t), r, Emval.toValue(i))
            }
        }
        function _lv_api_ret_to_main_thread_internal(e, t, r, i) {
            var n = UTF8ToString(i);
            if (ENVIRONMENT_IS_WORKER)
                postMessage({
                    cmd: "vesdk_ret_callback",
                    cbId: e,
                    ret: Emval.toValue(t),
                    workerName: globalThis.name,
                    costTime: Date.now() - r,
                    callFunc: n
                });
            else {
                if (!vesdk_task_map[e]) {
                    console.warn("callback can not found for sequeceId" + sequenceId);
                    return
                }
                vesdk_task_map[e].resolve(Emval.toValue(t)),
                vesdk_task_map[e].promise.costTime = Date.now() - r,
                vesdk_task_map[e].promise.callFunc = n
            }
        }
        function _registerBlobIOThread(e) {
            if (ENVIRONMENT_IS_PTHREAD)
                return proxyToMainThread(18, 0, 1, e);
            if (e <= 0 || !PThread.pthreads) {
                err("Thread id is wrong, can not register blob io thread");
                return
            }
            for (let t of Object.values(PThread.pthreads))
                if (t.pthread_ptr == e) {
                    Module.blobIOWorker = t;
                    break
                }
            out("Registered blob io worker " + e)
        }
        function _register_tejs_http(...e) {
            return wasmImports.register_tejs_http(...e)
        }
        _lv_api_callback_to_main_thread.sig = "vppip",
        _lv_api_ret_to_main_thread_internal.sig = "vipfp",
        _registerBlobIOThread.sig = "vi",
        _register_tejs_http.stub = !0;
        var arraySum = (e, t) => {
            for (var r = 0, i = 0; i <= t; r += e[i++])
                ;
            return r
        }
          , MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
          , MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
          , addDays = (e, t) => {
            for (var r = new Date(e.getTime()); t > 0; ) {
                var i = isLeapYear(r.getFullYear())
                  , n = r.getMonth()
                  , o = (i ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[n];
                if (t > o - r.getDate())
                    t -= o - r.getDate() + 1,
                    r.setDate(1),
                    n < 11 ? r.setMonth(n + 1) : (r.setMonth(0),
                    r.setFullYear(r.getFullYear() + 1));
                else {
                    r.setDate(r.getDate() + t);
                    break
                }
            }
            return r
        }
          , writeArrayToMemory = (e, t) => {
            GROWABLE_HEAP_I8().set(e, t)
        }
          , _strftime = (e, t, r, i) => {
            var n = GROWABLE_HEAP_U32()[i + 40 >> 2]
              , o = {
                tm_sec: GROWABLE_HEAP_I32()[i >> 2],
                tm_min: GROWABLE_HEAP_I32()[i + 4 >> 2],
                tm_hour: GROWABLE_HEAP_I32()[i + 8 >> 2],
                tm_mday: GROWABLE_HEAP_I32()[i + 12 >> 2],
                tm_mon: GROWABLE_HEAP_I32()[i + 16 >> 2],
                tm_year: GROWABLE_HEAP_I32()[i + 20 >> 2],
                tm_wday: GROWABLE_HEAP_I32()[i + 24 >> 2],
                tm_yday: GROWABLE_HEAP_I32()[i + 28 >> 2],
                tm_isdst: GROWABLE_HEAP_I32()[i + 32 >> 2],
                tm_gmtoff: GROWABLE_HEAP_I32()[i + 36 >> 2],
                tm_zone: n ? UTF8ToString(n) : ""
            }
              , a = UTF8ToString(r)
              , s = {
                "%c": "%a %b %d %H:%M:%S %Y",
                "%D": "%m/%d/%y",
                "%F": "%Y-%m-%d",
                "%h": "%b",
                "%r": "%I:%M:%S %p",
                "%R": "%H:%M",
                "%T": "%H:%M:%S",
                "%x": "%m/%d/%y",
                "%X": "%H:%M:%S",
                "%Ec": "%c",
                "%EC": "%C",
                "%Ex": "%m/%d/%y",
                "%EX": "%H:%M:%S",
                "%Ey": "%y",
                "%EY": "%Y",
                "%Od": "%d",
                "%Oe": "%e",
                "%OH": "%H",
                "%OI": "%I",
                "%Om": "%m",
                "%OM": "%M",
                "%OS": "%S",
                "%Ou": "%u",
                "%OU": "%U",
                "%OV": "%V",
                "%Ow": "%w",
                "%OW": "%W",
                "%Oy": "%y"
            };
            for (var u in s)
                a = a.replace(RegExp(u, "g"), s[u]);
            var l = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
              , c = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function p(e, t, r) {
                for (var i = "number" == typeof e ? e.toString() : e || ""; i.length < t; )
                    i = r[0] + i;
                return i
            }
            function d(e, t) {
                return p(e, t, "0")
            }
            function f(e, t) {
                var r;
                function i(e) {
                    return e < 0 ? -1 : e > 0 ? 1 : 0
                }
                return 0 === (r = i(e.getFullYear() - t.getFullYear())) && 0 === (r = i(e.getMonth() - t.getMonth())) && (r = i(e.getDate() - t.getDate())),
                r
            }
            function m(e) {
                switch (e.getDay()) {
                case 0:
                    return new Date(e.getFullYear() - 1,11,29);
                case 1:
                    return e;
                case 2:
                    return new Date(e.getFullYear(),0,3);
                case 3:
                    return new Date(e.getFullYear(),0,2);
                case 4:
                    return new Date(e.getFullYear(),0,1);
                case 5:
                    return new Date(e.getFullYear() - 1,11,31);
                case 6:
                    return new Date(e.getFullYear() - 1,11,30)
                }
            }
            function h(e) {
                var t = addDays(new Date(e.tm_year + 1900,0,1), e.tm_yday)
                  , r = new Date(t.getFullYear(),0,4)
                  , i = new Date(t.getFullYear() + 1,0,4)
                  , n = m(r)
                  , o = m(i);
                if (0 >= f(n, t))
                    return 0 >= f(o, t) ? t.getFullYear() + 1 : t.getFullYear();
                return t.getFullYear() - 1
            }
            var g = {
                "%a": e => l[e.tm_wday].substring(0, 3),
                "%A": e => l[e.tm_wday],
                "%b": e => c[e.tm_mon].substring(0, 3),
                "%B": e => c[e.tm_mon],
                "%C": e => d((e.tm_year + 1900) / 100 | 0, 2),
                "%d": e => d(e.tm_mday, 2),
                "%e": e => p(e.tm_mday, 2, " "),
                "%g": e => h(e).toString().substring(2),
                "%G": h,
                "%H": e => d(e.tm_hour, 2),
                "%I": e => {
                    var t = e.tm_hour;
                    return 0 == t ? t = 12 : t > 12 && (t -= 12),
                    d(t, 2)
                }
                ,
                "%j": e => d(e.tm_mday + arraySum(isLeapYear(e.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, e.tm_mon - 1), 3),
                "%m": e => d(e.tm_mon + 1, 2),
                "%M": e => d(e.tm_min, 2),
                "%n": () => "\n",
                "%p": e => e.tm_hour >= 0 && e.tm_hour < 12 ? "AM" : "PM",
                "%S": e => d(e.tm_sec, 2),
                "%t": () => "	",
                "%u": e => e.tm_wday || 7,
                "%U": e => d(Math.floor((e.tm_yday + 7 - e.tm_wday) / 7), 2),
                "%V": e => {
                    var t = Math.floor((e.tm_yday + 7 - (e.tm_wday + 6) % 7) / 7);
                    if ((e.tm_wday + 371 - e.tm_yday - 2) % 7 <= 2 && t++,
                    t) {
                        if (53 == t) {
                            var r = (e.tm_wday + 371 - e.tm_yday) % 7;
                            4 != r && (3 != r || !isLeapYear(e.tm_year)) && (t = 1)
                        }
                    } else {
                        t = 52;
                        var i = (e.tm_wday + 7 - e.tm_yday - 1) % 7;
                        (4 == i || 5 == i && isLeapYear(e.tm_year % 400 - 1)) && t++
                    }
                    return d(t, 2)
                }
                ,
                "%w": e => e.tm_wday,
                "%W": e => d(Math.floor((e.tm_yday + 7 - (e.tm_wday + 6) % 7) / 7), 2),
                "%y": e => (e.tm_year + 1900).toString().substring(2),
                "%Y": e => e.tm_year + 1900,
                "%z": e => {
                    var t = e.tm_gmtoff;
                    return (t >= 0 ? "+" : "-") + String("0000" + (t = (t = Math.abs(t) / 60) / 60 * 100 + t % 60)).slice(-4)
                }
                ,
                "%Z": e => e.tm_zone,
                "%%": () => "%"
            };
            for (var u in a = a.replace(/%%/g, "\0\0"),
            g)
                a.includes(u) && (a = a.replace(RegExp(u, "g"), g[u](o)));
            var _ = intArrayFromString(a = a.replace(/\0\0/g, "%"), !1);
            return _.length > t ? 0 : (writeArrayToMemory(_, e),
            _.length - 1)
        }
        ;
        _strftime.sig = "ppppp";
        var _strftime_l = (e, t, r, i, n) => _strftime(e, t, r, i);
        function _swr_alloc(...e) {
            return wasmImports.swr_alloc(...e)
        }
        function _swr_alloc_set_opts(...e) {
            return wasmImports.swr_alloc_set_opts(...e)
        }
        function _swr_close(...e) {
            return wasmImports.swr_close(...e)
        }
        function _swr_convert(...e) {
            return wasmImports.swr_convert(...e)
        }
        function _swr_free(...e) {
            return wasmImports.swr_free(...e)
        }
        function _swr_get_delay(...e) {
            return wasmImports.swr_get_delay(...e)
        }
        function _swr_get_out_samples(...e) {
            return wasmImports.swr_get_out_samples(...e)
        }
        function _swr_init(...e) {
            return wasmImports.swr_init(...e)
        }
        function _swr_is_initialized(...e) {
            return wasmImports.swr_is_initialized(...e)
        }
        function _sws_freeContext(...e) {
            return wasmImports.sws_freeContext(...e)
        }
        function _sws_getCoefficients(...e) {
            return wasmImports.sws_getCoefficients(...e)
        }
        function _sws_getContext(...e) {
            return wasmImports.sws_getContext(...e)
        }
        function _sws_scale(...e) {
            return wasmImports.sws_scale(...e)
        }
        function _sws_setColorspaceDetails(...e) {
            return wasmImports.sws_setColorspaceDetails(...e)
        }
        function _tt_H2645NAL_freep(...e) {
            return wasmImports.tt_H2645NAL_freep(...e)
        }
        function _tt_H2645NAL_get_data(...e) {
            return wasmImports.tt_H2645NAL_get_data(...e)
        }
        function _tt_H2645NAL_get_data_size(...e) {
            return wasmImports.tt_H2645NAL_get_data_size(...e)
        }
        function _tt_H2645NAL_malloc(...e) {
            return wasmImports.tt_H2645NAL_malloc(...e)
        }
        function _tt_h2645_extract_rbsp(...e) {
            return wasmImports.tt_h2645_extract_rbsp(...e)
        }
        _strftime_l.sig = "pppppp",
        _swr_alloc.stub = !0,
        _swr_alloc_set_opts.stub = !0,
        _swr_close.stub = !0,
        _swr_convert.stub = !0,
        _swr_free.stub = !0,
        _swr_get_delay.stub = !0,
        _swr_get_out_samples.stub = !0,
        _swr_init.stub = !0,
        _swr_is_initialized.stub = !0,
        _sws_freeContext.stub = !0,
        _sws_getCoefficients.stub = !0,
        _sws_getContext.stub = !0,
        _sws_scale.stub = !0,
        _sws_setColorspaceDetails.stub = !0,
        _tt_H2645NAL_freep.stub = !0,
        _tt_H2645NAL_get_data.stub = !0,
        _tt_H2645NAL_get_data_size.stub = !0,
        _tt_H2645NAL_malloc.stub = !0,
        _tt_h2645_extract_rbsp.stub = !0;
        var _uuid_generate = e => {
            var t = null;
            if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_WEB && void 0 !== window.crypto && void 0 !== window.crypto.getRandomValues && (t = new Uint8Array(16),
            window.crypto.getRandomValues(t)),
            !t) {
                t = Array(16);
                for (var r = (new Date).getTime(), i = 0; i < 16; i++) {
                    var n = (r + 256 * Math.random()) % 256 | 0;
                    r = r / 256 | 0,
                    t[i] = n
                }
            }
            t[6] = 15 & t[6] | 64,
            t[8] = 63 & t[8] | 128,
            writeArrayToMemory(t, e)
        }
        ;
        _uuid_generate.sig = "vp";
        var _uuid_unparse = (e, t, r) => {
            var i = 0;
            stringToUTF8("xxxx-xx-xx-xx-xxxxxx".replace(/[x]/g, function(t) {
                var n = r ? GROWABLE_HEAP_U8()[e + i].toString(16).toUpperCase() : GROWABLE_HEAP_U8()[e + i].toString(16);
                return n = 1 === n.length ? "0" + n : n,
                i++,
                n
            }), t, 37)
        }
        ;
        _uuid_unparse.sig = "vpp";
        var _uuid_unparse_lower = (e, t) => {
            _uuid_unparse(e, t)
        }
        ;
        _uuid_unparse_lower.sig = "vpp";
        var veFS_rw_lock = {
            r_lock: function() {
                for (; ; ) {
                    for (; 1 === Atomics.load(veFS_local.control, 0); )
                        ;
                    if (Atomics.add(veFS_local.control, 1, 1),
                    1 === Atomics.load(veFS_local.control, 0))
                        Atomics.sub(veFS_local.control, 1, 1);
                    else
                        break
                }
                veFS_local.update_typed_arrays()
            },
            r_unlock: function() {
                Atomics.sub(veFS_local.control, 1, 1)
            },
            w_lock: function() {
                for (; Atomics.exchange(veFS_local.control, 0, 1); )
                    ;
                for (; 0 !== Atomics.load(veFS_local.control, 1); )
                    ;
                veFS_local.update_typed_arrays()
            },
            w_unlock: function() {
                Atomics.store(veFS_local.control, 0, 0)
            }
        }
          , veFS_local = {
            dataFilesU32: null,
            dataFilesU8: null,
            control: null,
            index: null,
            get_block_size: function(e) {
                return Atomics.load(veFS_local.dataFilesU32, e >>> 2)
            },
            get_next_empty_ptr: function(e) {
                return Atomics.load(veFS_local.dataFilesU32, (e >>> 2) + 1)
            },
            set_next_empty_ptr: function(e, t) {
                Atomics.store(veFS_local.dataFilesU32, (e >>> 2) + 1, t)
            },
            get_prev_empty_ptr: function(e) {
                return Atomics.load(veFS_local.dataFilesU32, (e >>> 2) + 2)
            },
            set_prev_empty_ptr: function(e, t) {
                Atomics.store(veFS_local.dataFilesU32, (e >>> 2) + 2, t)
            },
            get_adjacent_block_ptr: function(e) {
                return e + veFS_local.get_block_size(e)
            },
            is_file_block: function(e) {
                return 0xffffffff === veFS_local.get_next_empty_ptr(e)
            },
            set_block_size: function(e, t) {
                Atomics.store(veFS_local.dataFilesU32, e >>> 2, t)
            },
            init_file_block: function(e, t) {
                veFS_local.set_block_size(e, t),
                Atomics.store(veFS_local.dataFilesU32, (e >>> 2) + 1, 0xffffffff)
            },
            init_empty_block: function(e, t) {
                veFS_local.set_block_size(e, t),
                veFS_local.set_prev_empty_ptr(e, 0),
                veFS_local.set_next_empty_ptr(e, 0)
            },
            get_empty_head: function() {
                return Atomics.load(veFS_local.control, 3)
            },
            get_empty_unalloc: function() {
                return Atomics.load(veFS_local.control, 4)
            },
            set_empty_head: function(e) {
                Atomics.store(veFS_local.control, 3, e)
            },
            set_empty_unalloc: function(e) {
                Atomics.store(veFS_local.control, 4, e)
            },
            get_file_block_ptr: function(e) {
                return Atomics.load(veFS_local.index, 2 * e)
            },
            set_file_block_ptr: function(e, t) {
                Atomics.store(veFS_local.index, 2 * e, t)
            },
            get_file_size: function(e) {
                return Atomics.load(veFS_local.index, 2 * e + 1)
            },
            set_file_size: function(e, t) {
                Atomics.store(veFS_local.index, 2 * e + 1, t)
            },
            remove_block_from_empty_list: function(e) {
                var t = veFS_local.get_next_empty_ptr(e)
                  , r = veFS_local.get_prev_empty_ptr(e);
                0 === r && veFS_local.set_empty_head(t),
                0 !== t && veFS_local.set_prev_empty_ptr(t, r),
                0 !== r && veFS_local.set_next_empty_ptr(r, t),
                veFS_local.set_next_empty_ptr(e, 0),
                veFS_local.set_prev_empty_ptr(e, 0)
            },
            check_last_block_and_merge_into_unalloc: function(e) {
                return veFS_local.get_adjacent_block_ptr(e) === veFS_local.get_empty_unalloc() && (veFS_local.dataFilesU8.fill(0, e, e + 12),
                veFS_local.set_empty_unalloc(e),
                !0)
            },
            check_continuous_empty_block_and_merge: function(e) {
                for (var t = veFS_local.get_adjacent_block_ptr(e), r = veFS_local.get_block_size(e), i = veFS_local.get_empty_unalloc(); t < i && !veFS_local.is_file_block(t); ) {
                    let e = veFS_local.get_block_size(t);
                    if (r += e,
                    0 === e)
                        throw Error("bad fs data block");
                    veFS_local.remove_block_from_empty_list(t),
                    t = veFS_local.get_adjacent_block_ptr(t)
                }
                veFS_local.set_block_size(e, r)
            },
            insert_empty_block_to_head: function(e) {
                if (veFS_local.check_continuous_empty_block_and_merge(e),
                !veFS_local.check_last_block_and_merge_into_unalloc(e)) {
                    var t = veFS_local.get_empty_head();
                    0 !== t ? (veFS_local.set_next_empty_ptr(e, t),
                    veFS_local.set_prev_empty_ptr(t, e),
                    veFS_local.set_prev_empty_ptr(e, 0)) : (veFS_local.set_prev_empty_ptr(e, 0),
                    veFS_local.set_next_empty_ptr(e, 0)),
                    veFS_local.set_empty_head(e)
                }
            },
            update_typed_arrays: function() {
                veFS_local.dataFilesU32 = new Uint32Array(Module.veFS.dataFiles.buffer),
                veFS_local.dataFilesU8 = new Uint8Array(Module.veFS.dataFiles.buffer)
            },
            ensure_underlied_buffer_size: function(e) {
                var t = e - veFS_local.dataFilesU8.buffer.byteLength;
                if (t > 0) {
                    var r = Math.max(t, 0x2000000);
                    r = r + 65535 >>> 16;
                    try {
                        Module.veFS.dataFiles.grow(r)
                    } catch (e) {
                        if (e instanceof RangeError)
                            throw "ENOBUFS";
                        throw e
                    } finally {
                        Module.applogPerf && Module.applogPerf("ve_vefs_status", {
                            buffersize: Module.veFS.dataFiles.buffer.byteLength,
                            file_count: Atomics.load(veFS_local.control, 2)
                        })
                    }
                    veFS_local.update_typed_arrays()
                }
            },
            alloc_new_file_block_on_unalloc_region: function(e) {
                var t = veFS_local.get_empty_unalloc();
                return veFS_local.ensure_underlied_buffer_size(t + e + 1),
                veFS_local.set_empty_unalloc(t + e),
                veFS_local.init_file_block(t, e),
                t
            },
            alloc_new_file_block_on_empty_block: function(e, t) {
                var r = veFS_local.get_block_size(e)
                  , i = r - t > 32 ? t : r;
                if (veFS_local.remove_block_from_empty_list(e),
                i < r) {
                    var n = e + i
                      , o = r - i;
                    veFS_local.init_empty_block(n, o),
                    veFS_local.insert_empty_block_to_head(n)
                }
                return veFS_local.init_file_block(e, i),
                e
            },
            alloc_new_file_block: function(e) {
                for (var t = veFS_local.get_empty_head(); 0 !== t && (veFS_local.check_continuous_empty_block_and_merge(t),
                !(veFS_local.get_block_size(t) >= e)); ) {
                    ;t = veFS_local.get_next_empty_ptr(t)
                }
                return 0 !== t ? veFS_local.alloc_new_file_block_on_empty_block(t, e) : veFS_local.alloc_new_file_block_on_unalloc_region(e)
            },
            try_expand_file_block: function(e, t, r) {
                var i = veFS_local.get_block_size(e);
                if (t - i <= 0)
                    return !0;
                var n = veFS_local.get_empty_unalloc()
                  , o = veFS_local.get_adjacent_block_ptr(e);
                if (o >= n) {
                    try {
                        veFS_local.ensure_underlied_buffer_size(e + t + 1)
                    } catch (e) {
                        if ("ENOBUFS" === e)
                            return !1;
                        throw e
                    }
                    return veFS_local.set_empty_unalloc(e + t),
                    veFS_local.set_block_size(e, t),
                    !0
                }
                if (!veFS_local.is_file_block(o) && veFS_local.get_block_size(o) + i >= t) {
                    veFS_local.alloc_new_file_block_on_empty_block(o, t - i);
                    var a = veFS_local.get_block_size(o);
                    return veFS_local.set_block_size(e, i + a),
                    r && veFS_local.dataFilesU8.fill(0, o, o + a),
                    !0
                }
                return !1
            },
            shrink_file_block: function(e, t) {},
            delete_file_block: function(e) {
                veFS_local.init_empty_block(e, veFS_local.get_block_size(e)),
                veFS_local.insert_empty_block_to_head(e)
            }
        };
        function _veFS_file_delete(e) {
            veFS_rw_lock.w_lock();
            var t = veFS_local.get_file_block_ptr(e);
            t > 0 && (veFS_local.set_file_block_ptr(e, 0),
            veFS_local.set_file_size(e, 0),
            veFS_local.delete_file_block(t)),
            veFS_rw_lock.w_unlock()
        }
        function _veFS_file_getSize(e) {
            veFS_rw_lock.r_lock();
            var t = veFS_local.get_file_size(e);
            return veFS_rw_lock.r_unlock(),
            t
        }
        function _veFS_file_handle_alloc() {
            return Atomics.add(veFS_local.control, 2, 1)
        }
        function _veFS_file_open(e, t) {
            return 0
        }
        function veFS_file_read_internal(e, t, r, i) {
            var n = veFS_local.get_file_block_ptr(e)
              , o = veFS_local.get_file_size(e);
            if (0 === n)
                return 0;
            var a = n + 8 + i
              , s = Math.min(n + 8 + i + r, n + 8 + o);
            return a >= s ? 0 : null === t ? veFS_local.dataFilesU8.slice(a, s) : (GROWABLE_HEAP_U8().set(veFS_local.dataFilesU8.subarray(a, s), t),
            s - a)
        }
        function _veFS_file_read(e, t, r, i) {
            veFS_rw_lock.r_lock();
            var n = veFS_file_read_internal(e, t, r, i);
            return veFS_rw_lock.r_unlock(),
            n
        }
        function veFS_file_write_internal(e, t, r, i, n) {
            if (r > 0x7fffffff)
                return -22;
            var o = veFS_local.get_file_block_ptr(e)
              , a = veFS_local.get_file_size(e)
              , s = o > 0
              , u = 0;
            s && (u = veFS_local.get_block_size(o));
            var l = Math.max(a, i + r)
              , c = (l + 8 + 3 >>> 2) * 4;
            if (s && u < c) {
                var p = !1;
                if (!n) {
                    var d = (Math.floor(1.25 * c) + 3 >>> 2) * 4;
                    p = veFS_local.try_expand_file_block(o, d, !1)
                }
                !p && (p = veFS_local.try_expand_file_block(o, c, n)),
                p && (u = veFS_local.get_block_size(o))
            }
            if (s && u >= c)
                return i > a && veFS_local.dataFilesU8.fill(0, o + 8 + a, o + 8 + i),
                null === t ? veFS_local.dataFilesU8.fill(0, o + 8 + i, o + 8 + i + r) : veFS_local.dataFilesU8.set(t, o + 8 + i),
                veFS_local.set_file_size(e, l),
                r;
            var f = c;
            !n && (f = (Math.ceil(f = f > 32768 ? 1.2 * c : 2 * c) + 3 >>> 2) * 4);
            var m = veFS_local.alloc_new_file_block(f);
            return veFS_local.dataFilesU8.copyWithin(m + 8, o + 8, o + 8 + a),
            i > a && veFS_local.dataFilesU8.fill(0, m + 8 + a, m + 8 + i),
            null === t ? veFS_local.dataFilesU8.fill(0, m + 8 + i, m + 8 + i + r) : veFS_local.dataFilesU8.set(t, m + 8 + i),
            veFS_local.set_file_block_ptr(e, m),
            veFS_local.set_file_size(e, l),
            s && veFS_local.delete_file_block(o),
            r
        }
        function _veFS_file_setSize(e, t) {
            veFS_rw_lock.w_lock();
            var r = veFS_local.get_file_block_ptr(e)
              , i = veFS_local.get_file_size(e);
            return i >= t && r > 0 ? (veFS_local.shrink_file_block(r, t),
            veFS_local.set_file_size(e, t)) : veFS_file_write_internal(e, null, t - i, i, !0),
            veFS_rw_lock.w_unlock(),
            0
        }
        function _veFS_file_write(e, t, r, i) {
            var n;
            if (0 === r)
                return 0;
            veFS_rw_lock.w_lock();
            try {
                n = veFS_file_write_internal(e, GROWABLE_HEAP_U8().subarray(t, t + r), r, i, !1)
            } catch (e) {
                if ("ENOBUFS" === e)
                    n = 0;
                else
                    throw e
            } finally {
                veFS_rw_lock.w_unlock()
            }
            return n < 0 ? 0 : n
        }
        _veFS_file_delete.sig = "vi",
        _veFS_file_getSize.sig = "ii",
        _veFS_file_handle_alloc.sig = "i",
        _veFS_file_open.sig = "iii",
        _veFS_file_read.sig = "iipii",
        _veFS_file_setSize.sig = "iii",
        _veFS_file_write.sig = "iipii";
        var VEThreadUtil = {
            browserIterationFunc: null,
            semaphorePtr: 0,
            semaphorePromise: null,
            threadType: "js",
            enableWaitAsync: !0
        };
        function _ve_run_main_loop_wait_async() {
            if (VEThreadUtil.enableWaitAsync && "function" == typeof Atomics.waitAsync) {
                let e = Atomics.waitAsync(GROWABLE_HEAP_I32(), VEThreadUtil.semaphorePtr >>> 2, 0);
                e.async && e.value.then(_ve_run_main_loop_wait_async)
            } else if ("js" === VEThreadUtil.threadType)
                setTimeout(_ve_run_main_loop_wait_async, 0);
            else {
                for (; 0 === Atomics.load(GROWABLE_HEAP_I32(), VEThreadUtil.semaphorePtr >>> 2); )
                    Atomics.wait(GROWABLE_HEAP_I32(), VEThreadUtil.semaphorePtr >>> 2, 0);
                Atomics.store(GROWABLE_HEAP_I32(), VEThreadUtil.semaphorePtr >>> 2, 0)
            }
            if (!ABORT) {
                GL.newRenderingFrameStarted();
                var e = VEThreadUtil.browserIterationFunc;
                if (!e)
                    return;
                Browser.mainLoop.runIter(e);
                !(VEThreadUtil.enableWaitAsync && "function" == typeof Atomics.waitAsync) && "cpp" === VEThreadUtil.threadType && Promise.resolve().then(_ve_run_main_loop_wait_async)
            }
        }
        _ve_run_main_loop_wait_async.sig = "v";
        var _ve_register_main_loop_arg = function(e, t, r, i) {
            VEThreadUtil.browserIterationFunc = () => getWasmTableEntry(r)(i),
            VEThreadUtil.semaphorePtr = e,
            VEThreadUtil.threadType = 0 === t ? "js" : "cpp",
            setTimeout(_ve_run_main_loop_wait_async, 0)
        };
        function _ve_trigger_thread_main_loop(e) {
            VEThreadUtil.enableWaitAsync && "function" == typeof Atomics.waitAsync || Atomics.store(GROWABLE_HEAP_I32(), e >>> 2, 1),
            Atomics.notify(GROWABLE_HEAP_I32(), e >>> 2)
        }
        function _ve_unregister_main_loop() {
            VEThreadUtil = {
                browserIterationFunc: null,
                semaphorePtr: 0,
                semaphorePromise: null
            }
        }
        _ve_register_main_loop_arg.sig = "vpipp",
        _ve_trigger_thread_main_loop.sig = "vp",
        _ve_unregister_main_loop.sig = "v";
        var VELogSink = [];
        function _velog_dump() {
            if (_velog_trigger_dump(),
            ENVIRONMENT_IS_WORKER)
                throw Error("DumpVELog js api must be called in main thread");
            let e = VELogSink.join("!@#$");
            return VELogSink.splice(0, Math.max(1, VELogSink.length - 24576)),
            Emval.toHandle(e)
        }
        function _velog_get_date_string_internal(e) {
            stringToUTF8((new Date).toISOString(), e, 100)
        }
        function _velog_js_dump_line(e) {
            VELogSink.push(UTF8ToString(e))
        }
        function _velog_send_js_buffer_to_main_thread() {
            ENVIRONMENT_IS_WORKER && (postMessage({
                cmd: "vesdk_log_dumped",
                data: VELogSink
            }),
            VELogSink = [])
        }
        function __vesdkRemoveCanvasIdPound(e) {
            return "number" == typeof e && (e = UTF8ToString(e)),
            e.startsWith("#") && (e = e.substring(1)),
            e
        }
        function _vesdkCreateOffscreenCanvas(e, t, r, i) {
            if (!ENVIRONMENT_IS_PTHREAD)
                return -1;
            t = __vesdkRemoveCanvasIdPound(t);
            let n = new OffscreenCanvas(r,i)
              , o = {
                canvasSharedPtr: _malloc(12),
                id: t,
                offscreenCanvas: n
            };
            return GROWABLE_HEAP_I32()[o.canvasSharedPtr >> 2] = n.width,
            GROWABLE_HEAP_I32()[o.canvasSharedPtr + 4 >> 2] = n.height,
            GROWABLE_HEAP_I32()[o.canvasSharedPtr + 8 >> 2] = e,
            GL.offscreenCanvases[t] = o,
            0
        }
        function _vesdkDeleteOffscreenCanvas(e) {
            if (!ENVIRONMENT_IS_PTHREAD)
                return -1;
            e = __vesdkRemoveCanvasIdPound(e);
            let t = GL.offscreenCanvases[e];
            return t && t.canvasSharedPtr ? (_free(t.canvasSharedPtr),
            delete GL.offscreenCanvases[e],
            0) : -1
        }
        function _vesdkInitWebGLLoseContext(e) {
            let t = GL.contexts[e];
            if (!t)
                return -1;
            let r = t.GLctx.getExtension("WEBGL_lose_context");
            return r ? (!GL.webGLLoseContexts && (GL.webGLLoseContexts = {}),
            GL.webGLLoseContexts[e] = r,
            0) : -1
        }
        function _vesdkPrintGLInfo() {
            console.log("[VESDK] GL thread worker: ", globalThis ? globalThis.name : "unknown")
        }
        function _vesdkProfileRendererJS(e) {
            0 == e ? (console.log("[VESDK] Start profiline gl thread worker: ", globalThis ? globalThis.name : "unknown"),
            console.profile("renderer")) : console.profileEnd("renderer")
        }
        function _vesdkSendGLPid(e) {
            postMessage({
                cmd: "vesdk_render_thread_id",
                pid: e
            })
        }
        function __vesdkRegisterWebGlEventCallback(e, t, r, i, n, o) {
            let a = function(e) {
                getWasmTableEntry(i)(n, 0, t) && e.preventDefault()
            }
              , s = findCanvasEventTarget(e);
            return s && s.offscreenCanvas ? (JSEvents.registerOrRemoveHandler({
                target: s.offscreenCanvas,
                eventTypeString: o,
                callbackfunc: i,
                handlerFunc: a,
                useCapture: r
            }),
            0) : -1
        }
        function _vesdkSetWebglcontextlostCallback(e, t, r, i) {
            return ENVIRONMENT_IS_WORKER ? __vesdkRegisterWebGlEventCallback(e, t, r, i, 31, "webglcontextlost") : (console.warn("veSetWebglcontextlostCallback only can use in render sub thread"),
            -1)
        }
        function _vesdkSetWebglcontextrestoreCallback(e, t, r, i) {
            return ENVIRONMENT_IS_WORKER ? __vesdkRegisterWebGlEventCallback(e, t, r, i, 32, "webglcontextrestored") : (console.warn("vesdkSetWebglcontextrestoreCallback only can use in render sub thread"),
            -1)
        }
        function _vesdkSimulateContextLost(e) {
            if (!GL.contexts[e] || !GL.webGLLoseContexts)
                return;
            let t = GL.webGLLoseContexts[e];
            if (!!t)
                t.loseContext()
        }
        function _vesdkSimulateContextLostAndRestored(e, t) {
            if (!GL.contexts[e] || !GL.webGLLoseContexts)
                return;
            let r = GL.webGLLoseContexts[e];
            if (!!r)
                r.loseContext(),
                setTimeout( () => {
                    r.restoreContext()
                }
                , t)
        }
        function _vesdkSimulateContextRestored(e) {
            if (!GL.contexts[e] || !GL.webGLLoseContexts)
                return;
            let t = GL.webGLLoseContexts[e];
            if (!!t)
                t.restoreContext()
        }
        function _vesdk_is_264_simd_enabled(...e) {
            return wasmImports.vesdk_is_264_simd_enabled(...e)
        }
        function _vesdk_log_pthread_create_js(e, t, r, i, n) {
            return Module.pthread_vesdk_log_create_stack_str = n,
            ___pthread_create_js(e, t, r, i)
        }
        function _vesdk_set_264_simd(...e) {
            return wasmImports.vesdk_set_264_simd(...e)
        }
        _velog_dump.sig = "p",
        _velog_get_date_string_internal.sig = "vp",
        _velog_js_dump_line.sig = "vp",
        _velog_send_js_buffer_to_main_thread.sig = "v",
        _vesdkCreateOffscreenCanvas.sig = "ippii",
        _vesdkDeleteOffscreenCanvas.sig = "ip",
        _vesdkInitWebGLLoseContext.sig = "ii",
        _vesdkPrintGLInfo.sig = "v",
        _vesdkProfileRendererJS.sig = "vi",
        _vesdkSendGLPid.sig = "vi",
        _vesdkSetWebglcontextlostCallback.sig = "ippip",
        _vesdkSetWebglcontextrestoreCallback.sig = "ippip",
        _vesdkSimulateContextLost.sig = "vi",
        _vesdkSimulateContextLostAndRestored.sig = "vii",
        _vesdkSimulateContextRestored.sig = "vi",
        _vesdk_is_264_simd_enabled.stub = !0,
        _vesdk_log_pthread_create_js.sig = "pppppp",
        _vesdk_set_264_simd.stub = !0;
        var allocateUTF8OnStack = stringToUTF8OnStack
          , veFS_JS_HUB = {
            writeFile: function(e, t, r) {
                var i = t
                  , n = i.length;
                void 0 === r && (r = !0);
                var o = withStackSave( () => {
                    let t = allocateUTF8OnStack(e);
                    return __vefs_get_file_handle_by_path(t, 1)
                }
                );
                let a = o;
                if (o >= 0) {
                    if (0 === n)
                        return 0;
                    veFS_rw_lock.w_lock();
                    try {
                        a = veFS_file_write_internal(o, i, n, 0, r)
                    } catch (e) {
                        if ("ENOBUFS" === e)
                            return -42;
                        throw e
                    } finally {
                        veFS_rw_lock.w_unlock()
                    }
                }
                return a < 0 && err("vefs bad write, errno: " + a),
                emscriptenLog(513, "vefs written: " + e),
                a
            },
            readFile: function(e, t={}) {
                var r = t.len = t.len || 0xffffffff
                  , i = t.offset = t.offset || 0
                  , n = withStackSave( () => {
                    let t = allocateUTF8OnStack(e);
                    return __vefs_get_file_handle_by_path(t, 0)
                }
                );
                let o = n;
                return n >= 0 && (veFS_rw_lock.r_lock(),
                o = veFS_file_read_internal(n, null, r, i),
                veFS_rw_lock.r_unlock()),
                "number" == typeof o && o < 0 ? err("vefs bad read, errno: " + o) : 0 === o && (o = new Uint8Array),
                o
            },
            veFS_init_idbcache: async function() {
                let e;
                let t = "VEFSIDBCACHE"
                  , r = "file"
                  , i = "dir"
                  , n = () => new Promise(e => {
                    let n = indexedDB.open(t, 1);
                    n.onerror = r => {
                        let i = indexedDB.deleteDatabase(t);
                        i.onsuccess = i.onerror = t => {
                            e(null)
                        }
                    }
                    ,
                    n.onsuccess = t => {
                        let r = t.target.result;
                        r.onerror = e => {
                            throw Error(`Database error: ${e.target.errorCode}`)
                        }
                        ,
                        e(r)
                    }
                    ,
                    n.onupgradeneeded = e => {
                        let t = e.target.result;
                        t.createObjectStore(r, {
                            keyPath: "path"
                        }),
                        t.createObjectStore(i, {
                            keyPath: "path"
                        })
                    }
                }
                )
                  , o = 0;
                for (; o < 2; ) {
                    let t = await n();
                    if (null !== t) {
                        e = t;
                        break
                    }
                    o++
                }
                if (2 === o)
                    throw Error("can't open indexdb");
                let a = () => new Promise(t => {
                    e.transaction([r], "readonly").objectStore(r).openCursor().onsuccess = e => {
                        let r = e.target.result;
                        r ? (veFS_JS_HUB.writeFile(r.value.path, r.value.data, !1),
                        r.continue()) : t()
                    }
                }
                );
                ( () => new Promise(t => {
                    e.transaction([i], "readonly").objectStore(i).openCursor().onsuccess = e => {
                        let r = e.target.result;
                        r ? (FS.mkdir(r.value.path),
                        r.continue()) : t()
                    }
                }
                ))().then( () => a()).then( () => {
                    self.postMessage({
                        cmd: "WASMFS_INIT_DONE"
                    })
                }
                )
            },
            select_wasmFS_type: function() {
                let e = !1;
                if (!Module.use_vefs_force) {
                    let r = navigator.userAgent.toLowerCase()
                      , i = /chrome/.test(r)
                      , n = /edg/.test(r)
                      , o = /opera/.test(r);
                    if (i) {
                        var t = parseInt(r.match(/chrome\/(\d+)/)[1]);
                        t > 102 && (e = !0)
                    } else if (n) {
                        var t = parseInt(r.match(/edg\/(\d+)/)[1]);
                        t > 102 && (e = !0)
                    } else if (o) {
                        var t = parseInt(r.match(/opr\/(\d+)/)[1]);
                        t > 88 && (e = !0)
                    }
                }
                return e ? (Module.wasmFS_type = "opfs",
                1) : (Module.wasmFS_type = "vefs",
                0)
            }
        };
        function lv_api_wait_init(e) {
            return e.createCbId && e.createCbId > 0 ? vesdk_task_map[e.createCbId].promise : Promise.resolve()
        }
        function lv_api_get_task_promise(e) {
            try {
                return vesdk_task_map[e].promise
            } catch (e) {
                return Promise.resolve()
            }
        }
        var readI53FromI64 = e => GROWABLE_HEAP_U32()[e >> 2] + 0x100000000 * GROWABLE_HEAP_I32()[e + 4 >> 2]
          , readI53FromU64 = e => GROWABLE_HEAP_U32()[e >> 2] + 0x100000000 * GROWABLE_HEAP_U32()[e + 4 >> 2]
          , FS_mknod = (e, t, r) => FS.handleError(withStackSave( () => {
            var i = stringToUTF8OnStack(e);
            return __wasmfs_mknod(i, t, r)
        }
        ))
          , FS_create = (e, t=438) => (t &= 4095,
        FS_mknod(e, t |= 32768, 0))
          , FS_writeFile = (e, t) => withStackSave( () => {
            var r = stringToUTF8OnStack(e);
            if ("string" == typeof t) {
                var i = new Uint8Array(lengthBytesUTF8(t) + 1)
                  , n = stringToUTF8Array(t, i, 0, i.length);
                t = i.slice(0, n)
            }
            for (var o = _malloc(t.length), a = 0; a < t.length; a++)
                GROWABLE_HEAP_I8()[o + a] = t[a];
            var s = __wasmfs_write_file(r, o, t.length);
            return _free(o),
            s
        }
        )
          , FS_createDataFile = (e, t, r, i, n, o) => {
            var a = t ? e + "/" + t : e
              , s = FS_getMode(i, n);
            wasmFSPreloadingFlushed ? (FS_create(a, s),
            FS_writeFile(a, r)) : wasmFSPreloadedFiles.push({
                pathName: a,
                fileData: r,
                mode: s
            })
        }
          , PATH_FS = {
            resolve: (...e) => {
                for (var t = "", r = !1, i = e.length - 1; i >= -1 && !r; i--) {
                    var n = i >= 0 ? e[i] : FS.cwd();
                    if ("string" != typeof n)
                        throw TypeError("Arguments to path.resolve must be strings");
                    if (!n)
                        return "";
                    t = n + "/" + t,
                    r = PATH.isAbs(n)
                }
                return t = PATH.normalizeArray(t.split("/").filter(e => !!e), !r).join("/"),
                (r ? "/" : "") + t || "."
            }
            ,
            relative: (e, t) => {
                function r(e) {
                    for (var t = 0; t < e.length && "" === e[t]; t++)
                        ;
                    for (var r = e.length - 1; r >= 0 && "" === e[r]; r--)
                        ;
                    return t > r ? [] : e.slice(t, r - t + 1)
                }
                e = PATH_FS.resolve(e).substr(1),
                t = PATH_FS.resolve(t).substr(1);
                for (var i = r(e.split("/")), n = r(t.split("/")), o = Math.min(i.length, n.length), a = o, s = 0; s < o; s++)
                    if (i[s] !== n[s]) {
                        a = s;
                        break
                    }
                for (var u = [], s = a; s < i.length; s++)
                    u.push("..");
                return (u = u.concat(n.slice(a))).join("/")
            }
        }
          , FS_handledByPreloadPlugin = (e, t, r, i) => {
            void 0 !== Browser && Browser.init();
            var n = !1;
            return preloadPlugins.forEach(o => {
                !n && o.canHandle(t) && (o.handle(e, t, r, i),
                n = !0)
            }
            ),
            n
        }
          , FS_createPreloadedFile = (e, t, r, i, n, o, a, s, u, l) => {
            var c = t ? PATH_FS.resolve(PATH.join2(e, t)) : e
              , p = getUniqueRunDependency(`cp ${c}`);
            function d(r) {
                function d(r) {
                    l?.(),
                    !s && FS_createDataFile(e, t, r, i, n, u),
                    o?.(),
                    removeRunDependency(p)
                }
                if (!FS_handledByPreloadPlugin(r, c, d, () => {
                    a?.(),
                    removeRunDependency(p)
                }
                ))
                    d(r)
            }
            addRunDependency(p),
            "string" == typeof r ? asyncLoad(r, d, a) : d(r)
        }
          , FS_getMode = (e, t) => {
            var r = 0;
            return e && (r |= 365),
            t && (r |= 146),
            r
        }
          , FS_modeStringToFlags = e => {
            var t = {
                r: 0,
                "r+": 2,
                w: 577,
                "w+": 578,
                a: 1089,
                "a+": 1090
            }[e];
            if (void 0 === t)
                throw Error(`Unknown file open mode: ${e}`);
            return t
        }
          , FS_mkdir = (e, t=511) => FS.handleError(withStackSave( () => {
            var r = stringToUTF8OnStack(e);
            return __wasmfs_mkdir(r, t)
        }
        ))
          , FS_mkdirTree = (e, t) => {
            for (var r = e.split("/"), i = "", n = 0; n < r.length; ++n)
                if (r[n]) {
                    i += "/" + r[n];
                    try {
                        FS_mkdir(i, t)
                    } catch (e) {
                        if (20 != e.errno)
                            throw e
                    }
                }
        }
          , FS_unlink = e => withStackSave( () => {
            var t = stringToUTF8OnStack(e);
            return __wasmfs_unlink(t)
        }
        )
          , wasmFS$backends = {}
          , wasmFSDevices = {}
          , wasmFSDeviceStreams = {}
          , FS = {
            init() {
                FS.ensureErrnoError()
            },
            ErrnoError: null,
            handleError(e) {
                if (e < 0)
                    throw new FS.ErrnoError(-e);
                return e
            },
            ensureErrnoError() {
                !FS.ErrnoError && (FS.ErrnoError = function(e) {
                    this.errno = e,
                    this.message = "FS error",
                    this.name = "ErrnoError"
                }
                ,
                FS.ErrnoError.prototype = Error(),
                FS.ErrnoError.prototype.constructor = FS.ErrnoError)
            },
            createDataFile(e, t, r, i, n, o) {
                FS_createDataFile(e, t, r, i, n, o)
            },
            createPath(e, t, r, i) {
                for (var n = t.split("/").reverse(); n.length; ) {
                    var o = n.pop();
                    if (!!o) {
                        var a = PATH.join2(e, o);
                        wasmFSPreloadingFlushed ? FS.mkdir(a) : wasmFSPreloadedDirs.push({
                            parentPath: e,
                            childName: o
                        }),
                        e = a
                    }
                }
                return a
            },
            createPreloadedFile: (e, t, r, i, n, o, a, s, u, l) => FS_createPreloadedFile(e, t, r, i, n, o, a, s, u, l),
            readFile(e, t={}) {
                if (t.encoding = t.encoding || "binary",
                "utf8" !== t.encoding && "binary" !== t.encoding)
                    throw Error('Invalid encoding type "' + t.encoding + '"');
                var r = withStackSave( () => __wasmfs_read_file(stringToUTF8OnStack(e)))
                  , i = readI53FromI64(r)
                  , n = new Uint8Array(GROWABLE_HEAP_U8().subarray(r + 8, r + 8 + i));
                return "utf8" === t.encoding && (n = UTF8ArrayToString(n, 0)),
                n
            },
            cwd: () => UTF8ToString(__wasmfs_get_cwd()),
            analyzePath(e) {
                var t = !!FS.findObject(e);
                return {
                    exists: t,
                    object: {
                        contents: t ? FS.readFile(e) : null
                    }
                }
            },
            mkdir: (e, t) => FS_mkdir(e, t),
            mkdirTree: (e, t) => FS_mkdirTree(e, t),
            rmdir: e => withStackSave( () => {
                var t = stringToUTF8OnStack(e);
                return __wasmfs_rmdir(t)
            }
            ),
            open: (e, t, r) => withStackSave( () => {
                t = "string" == typeof t ? FS_modeStringToFlags(t) : t,
                r = void 0 === r ? 438 : r;
                var i = stringToUTF8OnStack(e);
                return {
                    fd: FS.handleError(__wasmfs_open(i, t, r))
                }
            }
            ),
            create: (e, t) => (t = (void 0 !== t ? t : 438) & 4095 | 32768,
            FS.mknod(e, t, 0)),
            close: e => FS.handleError(-__wasmfs_close(e.fd)),
            unlink: e => FS_unlink(e),
            chdir: e => withStackSave( () => {
                var t = stringToUTF8OnStack(e);
                return __wasmfs_chdir(t)
            }
            ),
            read(e, t, r, i, n) {
                var o, a = void 0 !== n, s = _malloc(i);
                o = a ? __wasmfs_pread(e.fd, s, i, n) : __wasmfs_read(e.fd, s, i),
                o = FS.handleError(o);
                for (var u = 0; u < i; u++)
                    t[r + u] = GROWABLE_HEAP_I8()[s + u];
                return _free(s),
                o
            },
            write(e, t, r, i, n, o) {
                for (var a, s = void 0 !== n, u = _malloc(i), l = 0; l < i; l++)
                    GROWABLE_HEAP_I8()[u + l] = t[r + l];
                return a = s ? __wasmfs_pwrite(e.fd, u, i, n) : __wasmfs_write(e.fd, u, i),
                a = FS.handleError(a),
                _free(u),
                a
            },
            allocate: (e, t, r) => FS.handleError(__wasmfs_allocate(e.fd, BigInt(t), BigInt(r))),
            writeFile: (e, t) => FS_writeFile(e, t),
            mmap: (e, t, r, i, n) => ({
                ptr: FS.handleError(__wasmfs_mmap(t, i, n, e.fd, BigInt(r))),
                allocated: !0
            }),
            msync: (e, t, r, i, n) => (assert(0 === r),
            FS.handleError(__wasmfs_msync(t, i, n))),
            munmap: (e, t) => FS.handleError(__wasmfs_munmap(e, t)),
            symlink: (e, t) => withStackSave( () => __wasmfs_symlink(stringToUTF8OnStack(e), stringToUTF8OnStack(t))),
            readlink: e => UTF8ToString(FS.handleError(withStackSave( () => __wasmfs_readlink(stringToUTF8OnStack(e))))),
            statBufToObject: e => ({
                dev: GROWABLE_HEAP_U32()[e >> 2],
                mode: GROWABLE_HEAP_U32()[e + 4 >> 2],
                nlink: GROWABLE_HEAP_U32()[e + 8 >> 2],
                uid: GROWABLE_HEAP_U32()[e + 12 >> 2],
                gid: GROWABLE_HEAP_U32()[e + 16 >> 2],
                rdev: GROWABLE_HEAP_U32()[e + 20 >> 2],
                size: readI53FromI64(e + 24),
                blksize: GROWABLE_HEAP_U32()[e + 32 >> 2],
                blocks: GROWABLE_HEAP_U32()[e + 36 >> 2],
                atime: readI53FromI64(e + 40),
                mtime: readI53FromI64(e + 56),
                ctime: readI53FromI64(e + 72),
                ino: readI53FromU64(e + 88)
            }),
            stat(e) {
                var t = _malloc(96);
                FS.handleError(withStackSave( () => __wasmfs_stat(stringToUTF8OnStack(e), t)));
                var r = FS.statBufToObject(t);
                return _free(t),
                r
            },
            lstat(e) {
                var t = _malloc(96);
                FS.handleError(withStackSave( () => __wasmfs_lstat(stringToUTF8OnStack(e), t)));
                var r = FS.statBufToObject(t);
                return _free(t),
                r
            },
            chmod: (e, t) => FS.handleError(withStackSave( () => {
                var r = stringToUTF8OnStack(e);
                return __wasmfs_chmod(r, t)
            }
            )),
            lchmod: (e, t) => FS.handleError(withStackSave( () => {
                var r = stringToUTF8OnStack(e);
                return __wasmfs_lchmod(r, t)
            }
            )),
            fchmod: (e, t) => FS.handleError(__wasmfs_fchmod(e, t)),
            utime: (e, t, r) => FS.handleError(withStackSave( () => __wasmfs_utime(stringToUTF8OnStack(e), t, r))),
            truncate: (e, t) => FS.handleError(withStackSave( () => __wasmfs_truncate(stringToUTF8OnStack(e), BigInt(t)))),
            ftruncate: (e, t) => FS.handleError(__wasmfs_ftruncate(e, BigInt(t))),
            findObject(e) {
                var t = withStackSave( () => __wasmfs_identify(stringToUTF8OnStack(e)));
                return 44 == t ? null : {
                    isFolder: 31 == t,
                    isDevice: !1
                }
            },
            readdir: e => withStackSave( () => {
                var t, r = stringToUTF8OnStack(e), i = [], n = __wasmfs_readdir_start(r);
                if (!n)
                    throw Error("No such directory");
                for (; t = __wasmfs_readdir_get(n); )
                    i.push(UTF8ToString(t));
                return __wasmfs_readdir_finish(n),
                i
            }
            ),
            mount: (e, t, r) => {
                var i = e.createBackend(t);
                return FS.handleError(withStackSave( () => __wasmfs_mount(stringToUTF8OnStack(r), i)))
            }
            ,
            unmount: e => FS.handleError(withStackSave( () => __wasmfs_unmount(stringToUTF8OnStack(e)))),
            mknod: (e, t, r) => FS_mknod(e, t, r),
            makedev: (e, t) => e << 8 | t,
            registerDevice(e, t) {
                var r = _wasmfs_create_jsimpl_backend()
                  , i = {
                    userRead: t.read,
                    userWrite: t.write,
                    allocFile: e => {
                        wasmFSDeviceStreams[e] = {}
                    }
                    ,
                    freeFile: e => {
                        wasmFSDeviceStreams[e] = void 0
                    }
                    ,
                    getSize: e => {}
                    ,
                    read: (e, t, r, n) => {
                        var o = Module.HEAP8.subarray(t, t + r);
                        try {
                            var a = i.userRead(wasmFSDeviceStreams[e], o, 0, r, n)
                        } catch (e) {
                            return -e.errno
                        }
                        return Module.HEAP8.set(o, t),
                        a
                    }
                    ,
                    write: (e, t, r, n) => {
                        var o = Module.HEAP8.subarray(t, t + r);
                        try {
                            var a = i.userWrite(wasmFSDeviceStreams[e], o, 0, r, n)
                        } catch (e) {
                            return -e.errno
                        }
                        return Module.HEAP8.set(o, t),
                        a
                    }
                };
                wasmFS$backends[r] = i,
                wasmFSDevices[e] = r
            },
            createDevice(e, t, r, i) {
                if ("string" != typeof e)
                    throw Error("Only string paths are accepted");
                var n = PATH.join2(e, t)
                  , o = FS_getMode(!!r, !!i);
                !FS.createDevice.major && (FS.createDevice.major = 64);
                var a = FS.makedev(FS.createDevice.major++, 0);
                return FS.registerDevice(a, {
                    read(e, t, i, n, o) {
                        for (var a, s = 0, u = 0; u < n; u++) {
                            try {
                                a = r()
                            } catch (e) {
                                throw new FS.ErrnoError(29)
                            }
                            if (void 0 === a && 0 === s)
                                throw new FS.ErrnoError(6);
                            if (null == a)
                                break;
                            s++,
                            t[i + u] = a
                        }
                        return s
                    },
                    write(e, t, r, n, o) {
                        for (var a = 0; a < n; a++)
                            try {
                                i(t[r + a])
                            } catch (e) {
                                throw new FS.ErrnoError(29)
                            }
                        return a
                    }
                }),
                FS.mkdev(n, o, a)
            },
            mkdev(e, t, r) {
                void 0 === r && (r = t,
                t = 438);
                var i = wasmFSDevices[r];
                if (!i)
                    throw Error("Invalid device ID.");
                return FS.handleError(withStackSave( () => _wasmfs_create_file(stringToUTF8OnStack(e), t, i)))
            },
            rename: (e, t) => FS.handleError(withStackSave( () => {
                var r = stringToUTF8OnStack(e)
                  , i = stringToUTF8OnStack(t);
                return __wasmfs_rename(r, i)
            }
            )),
            llseek: (e, t, r) => FS.handleError(__wasmfs_llseek(e.fd, BigInt(t), r))
        }
          , getCFunc = e => Module["_" + e]
          , ccall = (e, t, r, i, n) => {
            var o = {
                string: e => {
                    var t = 0;
                    return null != e && 0 !== e && (t = stringToUTF8OnStack(e)),
                    t
                }
                ,
                array: e => {
                    var t = stackAlloc(e.length);
                    return writeArrayToMemory(e, t),
                    t
                }
            };
            function a(e) {
                return "string" === t ? UTF8ToString(e) : "boolean" === t ? !!e : e
            }
            var s = getCFunc(e)
              , u = []
              , l = 0;
            if (i)
                for (var c = 0; c < i.length; c++) {
                    var p = o[r[c]];
                    p ? (0 === l && (l = stackSave()),
                    u[c] = p(i[c])) : u[c] = i[c]
                }
            var d = s(...u);
            return d = function e(e) {
                return 0 !== l && stackRestore(l),
                a(e)
            }(d)
        }
          , cwrap = (e, t, r, i) => {
            var n = !r || r.every(e => "number" === e || "boolean" === e);
            return "string" !== t && n && !i ? getCFunc(e) : (...n) => ccall(e, t, r, n, i)
        }
          , ALLOC_NORMAL = 0
          , ALLOC_STACK = 1
          , allocate = (e, t) => {
            var r;
            return r = t == ALLOC_STACK ? stackAlloc(e.length) : _malloc(e.length),
            !e.subarray && !e.slice && (e = new Uint8Array(e)),
            GROWABLE_HEAP_U8().set(e, r),
            r
        }
          , allocateUTF8 = stringToNewUTF8
          , removeFunction = e => {
            functionsInTableMap.delete(getWasmTableEntry(e)),
            setWasmTableEntry(e, null),
            freeTableIndexes.push(e)
        }
        ;
        function intArrayToString(e) {
            for (var t = [], r = 0; r < e.length; r++) {
                var i = e[r];
                i > 255 && (i &= 255),
                t.push(String.fromCharCode(i))
            }
            return t.join("")
        }
        PThread.init(),
        registerWasmPlugin(),
        bytenn_wrapper(),
        InternalError = Module.InternalError = class extends Error {
            constructor(e) {
                super(e),
                this.name = "InternalError"
            }
        }
        ,
        embind_init_charCodes(),
        BindingError = Module.BindingError = class extends Error {
            constructor(e) {
                super(e),
                this.name = "BindingError"
            }
        }
        ,
        init_ClassHandle(),
        init_embind(),
        init_RegisteredPointer(),
        UnboundTypeError = Module.UnboundTypeError = extendError(Error, "UnboundTypeError"),
        init_emval(),
        Module.requestFullscreen = Browser.requestFullscreen,
        Module.requestAnimationFrame = Browser.requestAnimationFrame,
        Module.setCanvasSize = Browser.setCanvasSize,
        Module.pauseMainLoop = Browser.mainLoop.pause,
        Module.resumeMainLoop = Browser.mainLoop.resume,
        Module.getUserMedia = Browser.getUserMedia,
        Module.createContext = Browser.createContext;
        for (var preloadedImages = {}, preloadedAudios = {}, i = 0; i < 32; ++i)
            tempFixedLengthArray.push(Array(i));
        for (var miniTempWebGLFloatBuffersStorage = new Float32Array(288), i = 0; i < 288; ++i)
            miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i + 1);
        for (var miniTempWebGLIntBuffersStorage = new Int32Array(288), i = 0; i < 288; ++i)
            miniTempWebGLIntBuffers[i] = miniTempWebGLIntBuffersStorage.subarray(0, i + 1);
        veFS_local.control = new Uint32Array(Module.veFS.control),
        veFS_local.index = new Uint32Array(Module.veFS.index),
        FS.init();
        var proxiedFunctionTable = [_proc_exit, exitOnMainThread, pthreadCreateProxied, setCanvasElementSizeMainThread, _eglChooseConfig, _eglCreateContext, _eglCreateWindowSurface, _eglDestroyContext, _eglDestroySurface, _eglGetCurrentContext, _eglGetCurrentDisplay, _eglGetDisplay, _eglGetError, _eglMakeCurrent, _eglQueryContext, getCanvasSizeMainThread, _environ_get, _environ_sizes_get, _registerBlobIOThread]
          , wasmImports = {
            CancelHttp: _CancelHttp,
            ImageBitmapBindToTexture: _ImageBitmapBindToTexture,
            SendHttp: _SendHttp,
            TEAudioWorkletClearCache: _TEAudioWorkletClearCache,
            TEAudioWorkletGetVolume: _TEAudioWorkletGetVolume,
            TEAudioWorkletPause: _TEAudioWorkletPause,
            TEAudioWorkletPushSamples: _TEAudioWorkletPushSamples,
            TEAudioWorkletResume: _TEAudioWorkletResume,
            TEAudioWorkletSetVolume: _TEAudioWorkletSetVolume,
            TECreateAudioWorklet: _TECreateAudioWorklet,
            TECreateStack: _TECreateStack,
            TEJSEventFetch_Fetch_Abort: _TEJSEventFetch_Fetch_Abort,
            TEJSEventFetch_Fetch_Send: _TEJSEventFetch_Fetch_Send,
            TEJSEvent_BlobClose: _TEJSEvent_BlobClose,
            TEJSEvent_BlobOpen: _TEJSEvent_BlobOpen,
            TEJSEvent_BlobOpen_GetLastModified: _TEJSEvent_BlobOpen_GetLastModified,
            TEJSEvent_BlobOpen_GetType: _TEJSEvent_BlobOpen_GetType,
            TEJSEvent_BlobRead: _TEJSEvent_BlobRead,
            TEJSEvent_BlobSeek: _TEJSEvent_BlobSeek,
            TEJSEvent_Blob_Direct_GetType: _TEJSEvent_Blob_Direct_GetType,
            TEJSEvent_Fetch_Abort: _TEJSEvent_Fetch_Abort,
            TEJSEvent_HEIC_Decode_Init: _TEJSEvent_HEIC_Decode_Init,
            TEJSEvent_HEIC_Get_From_Cache: _TEJSEvent_HEIC_Get_From_Cache,
            TEJSEvent_HTTPRequest_Abort: _TEJSEvent_HTTPRequest_Abort,
            TEJSEvent_HTTPRequest_Send: _TEJSEvent_HTTPRequest_Send,
            TEJSEvent_IDB_Del: _TEJSEvent_IDB_Del,
            TEJSEvent_IDB_Get: _TEJSEvent_IDB_Get,
            TEJSEvent_IDB_Open: _TEJSEvent_IDB_Open,
            TEJSEvent_IDB_Save: _TEJSEvent_IDB_Save,
            TEJSEvent_Image_Decode: _TEJSEvent_Image_Decode,
            TEJSEvent_Image_Decode_ImageBitmap_Close: _TEJSEvent_Image_Decode_ImageBitmap_Close,
            TEJSEvent_Image_Decoder_Is_Support: _TEJSEvent_Image_Decoder_Is_Support,
            TEJSEvent_Image_Gen_Fail_Image: _TEJSEvent_Image_Gen_Fail_Image,
            TEJSEvent_Image_Gen_Image: _TEJSEvent_Image_Gen_Image,
            TEJSEvent_Image_Movie_Close: _TEJSEvent_Image_Movie_Close,
            TEJSEvent_Image_Movie_Decode: _TEJSEvent_Image_Movie_Decode,
            TEJSEvent_Image_Movie_Decode_VideoFrame_Close: _TEJSEvent_Image_Movie_Decode_VideoFrame_Close,
            TEJSEvent_Image_Movie_Open: _TEJSEvent_Image_Movie_Open,
            TEJSEvent_Image_Query_GL_Max_Tex_Size: _TEJSEvent_Image_Query_GL_Max_Tex_Size,
            TEJSEvent_StreamFetch: _TEJSEvent_StreamFetch,
            TEJSEvent_WebCodec_Close: _TEJSEvent_WebCodec_Close,
            TEJSEvent_WebCodec_Close_Frame: _TEJSEvent_WebCodec_Close_Frame,
            TEJSEvent_WebCodec_ConfigVerify: _TEJSEvent_WebCodec_ConfigVerify,
            TEJSEvent_WebCodec_Flush: _TEJSEvent_WebCodec_Flush,
            TEJSEvent_WebCodec_Get_GLTexture: _TEJSEvent_WebCodec_Get_GLTexture,
            TEJSEvent_WebCodec_Init: _TEJSEvent_WebCodec_Init,
            TEJSEvent_WebCodec_IsFlushing: _TEJSEvent_WebCodec_IsFlushing,
            TEJSEvent_WebCodec_Is_Support: _TEJSEvent_WebCodec_Is_Support,
            TEJSEvent_WebCodec_RenderTexutre: _TEJSEvent_WebCodec_RenderTexutre,
            TEJSEvent_WebCodec_SendPacket: _TEJSEvent_WebCodec_SendPacket,
            TEJSEvent_WebCodec_SupportDequeueEvent: _TEJSEvent_WebCodec_SupportDequeueEvent,
            TEJSEvent_WebCodec_UpdateAllQueueSize: _TEJSEvent_WebCodec_UpdateAllQueueSize,
            VideoFrameBindToTexture: _VideoFrameBindToTexture,
            WebGLGetInputShape: _WebGLGetInputShape,
            WebGLGetOutput: _WebGLGetOutput,
            WebGLGetOutputShape: _WebGLGetOutputShape,
            WebGLInference: _WebGLInference,
            WebGLInit: _WebGLInit,
            WebGLReInferShape: _WebGLReInferShape,
            WebGLRelease: _WebGLRelease,
            WebGLSetInput: _WebGLSetInput,
            WebGLSetInputTexture: _WebGLSetInputTexture,
            WebGLSetOutputTexture: _WebGLSetOutputTexture,
            WebGPUGetInputShape: _WebGPUGetInputShape,
            WebGPUGetOutput: _WebGPUGetOutput,
            WebGPUGetOutputShape: _WebGPUGetOutputShape,
            WebGPUInference: _WebGPUInference,
            WebGPUInit: _WebGPUInit,
            WebGPUReInferShape: _WebGPUReInferShape,
            WebGPURelease: _WebGPURelease,
            WebGPUSetInput: _WebGPUSetInput,
            WebGPUSetInputGLTexture: _WebGPUSetInputGLTexture,
            WebGPUSetOutputGLTexture: _WebGPUSetOutputGLTexture,
            __assert_fail: ___assert_fail,
            __c_longjmp: ___c_longjmp,
            __cpp_exception: ___cpp_exception,
            __emscripten_init_main_thread_js: ___emscripten_init_main_thread_js,
            __emscripten_thread_cleanup: ___emscripten_thread_cleanup,
            __heap_base: ___heap_base,
            __indirect_function_table: wasmTable,
            __memory_base: ___memory_base,
            __pthread_create_js: ___pthread_create_js,
            __stack_high: ___stack_high,
            __stack_low: ___stack_low,
            __stack_pointer: ___stack_pointer,
            __table_base: ___table_base,
            __throw_exception_with_stack_trace: ___throw_exception_with_stack_trace,
            _dlopen_js: __dlopen_js,
            _dlsym_catchup_js: __dlsym_catchup_js,
            _embind_finalize_value_object: __embind_finalize_value_object,
            _embind_register_bigint: __embind_register_bigint,
            _embind_register_bool: __embind_register_bool,
            _embind_register_class: __embind_register_class,
            _embind_register_class_constructor: __embind_register_class_constructor,
            _embind_register_class_function: __embind_register_class_function,
            _embind_register_class_property: __embind_register_class_property,
            _embind_register_emval: __embind_register_emval,
            _embind_register_enum: __embind_register_enum,
            _embind_register_enum_value: __embind_register_enum_value,
            _embind_register_float: __embind_register_float,
            _embind_register_integer: __embind_register_integer,
            _embind_register_memory_view: __embind_register_memory_view,
            _embind_register_optional: __embind_register_optional,
            _embind_register_smart_ptr: __embind_register_smart_ptr,
            _embind_register_std_string: __embind_register_std_string,
            _embind_register_std_wstring: __embind_register_std_wstring,
            _embind_register_value_object: __embind_register_value_object,
            _embind_register_value_object_field: __embind_register_value_object_field,
            _embind_register_void: __embind_register_void,
            _emscripten_dlopen_js: __emscripten_dlopen_js,
            _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
            _emscripten_notify_mailbox_postmessage: __emscripten_notify_mailbox_postmessage,
            _emscripten_receive_on_main_thread_js: __emscripten_receive_on_main_thread_js,
            _emscripten_set_offscreencanvas_size: __emscripten_set_offscreencanvas_size,
            _emscripten_system: __emscripten_system,
            _emscripten_thread_exit_joinable: __emscripten_thread_exit_joinable,
            _emscripten_thread_mailbox_await: __emscripten_thread_mailbox_await,
            _emscripten_thread_set_strongref: __emscripten_thread_set_strongref,
            _emval_as: __emval_as,
            _emval_as_int64: __emval_as_int64,
            _emval_call: __emval_call,
            _emval_call_method: __emval_call_method,
            _emval_decref: __emval_decref,
            _emval_get_method_caller: __emval_get_method_caller,
            _emval_get_property: __emval_get_property,
            _emval_incref: __emval_incref,
            _emval_new_array: __emval_new_array,
            _emval_new_array_from_memory_view: __emval_new_array_from_memory_view,
            _emval_new_cstring: __emval_new_cstring,
            _emval_new_object: __emval_new_object,
            _emval_run_destructors: __emval_run_destructors,
            _emval_set_property: __emval_set_property,
            _emval_take_value: __emval_take_value,
            _gmtime_js: __gmtime_js,
            _localtime_js: __localtime_js,
            _mktime_js: __mktime_js,
            _tzset_js: __tzset_js,
            _wasmfs_copy_preloaded_file_data: __wasmfs_copy_preloaded_file_data,
            _wasmfs_get_num_preloaded_dirs: __wasmfs_get_num_preloaded_dirs,
            _wasmfs_get_num_preloaded_files: __wasmfs_get_num_preloaded_files,
            _wasmfs_get_preloaded_child_path: __wasmfs_get_preloaded_child_path,
            _wasmfs_get_preloaded_file_mode: __wasmfs_get_preloaded_file_mode,
            _wasmfs_get_preloaded_file_size: __wasmfs_get_preloaded_file_size,
            _wasmfs_get_preloaded_parent_path: __wasmfs_get_preloaded_parent_path,
            _wasmfs_get_preloaded_path_name: __wasmfs_get_preloaded_path_name,
            _wasmfs_jsimpl_alloc_file: __wasmfs_jsimpl_alloc_file,
            _wasmfs_jsimpl_free_file: __wasmfs_jsimpl_free_file,
            _wasmfs_jsimpl_get_size: __wasmfs_jsimpl_get_size,
            _wasmfs_jsimpl_read: __wasmfs_jsimpl_read,
            _wasmfs_jsimpl_write: __wasmfs_jsimpl_write,
            _wasmfs_stdin_get_char: __wasmfs_stdin_get_char,
            abort: _abort,
            av_add_index_entry: _av_add_index_entry,
            av_audio_fifo_alloc: _av_audio_fifo_alloc,
            av_audio_fifo_drain: _av_audio_fifo_drain,
            av_audio_fifo_free: _av_audio_fifo_free,
            av_audio_fifo_peek_at: _av_audio_fifo_peek_at,
            av_audio_fifo_read: _av_audio_fifo_read,
            av_audio_fifo_reset: _av_audio_fifo_reset,
            av_audio_fifo_size: _av_audio_fifo_size,
            av_audio_fifo_space: _av_audio_fifo_space,
            av_audio_fifo_write: _av_audio_fifo_write,
            av_bsf_alloc: _av_bsf_alloc,
            av_bsf_free: _av_bsf_free,
            av_bsf_get_by_name: _av_bsf_get_by_name,
            av_bsf_init: _av_bsf_init,
            av_bsf_receive_packet: _av_bsf_receive_packet,
            av_bsf_send_packet: _av_bsf_send_packet,
            av_buffer_create: _av_buffer_create,
            av_buffer_default_free: _av_buffer_default_free,
            av_buffer_unref: _av_buffer_unref,
            av_buffersink_get_frame: _av_buffersink_get_frame,
            av_buffersink_get_frame_flags: _av_buffersink_get_frame_flags,
            av_buffersrc_add_frame_flags: _av_buffersrc_add_frame_flags,
            av_calloc: _av_calloc,
            av_codec_is_decoder: _av_codec_is_decoder,
            av_codec_is_encoder: _av_codec_is_encoder,
            av_copy_packet: _av_copy_packet,
            av_cpu_count: _av_cpu_count,
            av_default_item_name: _av_default_item_name,
            av_dict_copy: _av_dict_copy,
            av_dict_free: _av_dict_free,
            av_dict_get: _av_dict_get,
            av_dict_set: _av_dict_set,
            av_dict_set_int: _av_dict_set_int,
            av_display_rotation_get: _av_display_rotation_get,
            av_dump_format: _av_dump_format,
            av_fifo_alloc: _av_fifo_alloc,
            av_fifo_free: _av_fifo_free,
            av_fifo_generic_read: _av_fifo_generic_read,
            av_fifo_reset: _av_fifo_reset,
            av_fifo_size: _av_fifo_size,
            av_find_best_stream: _av_find_best_stream,
            av_format_inject_global_side_data: _av_format_inject_global_side_data,
            av_frame_alloc: _av_frame_alloc,
            av_frame_copy_props: _av_frame_copy_props,
            av_frame_free: _av_frame_free,
            av_frame_get_best_effort_timestamp: _av_frame_get_best_effort_timestamp,
            av_frame_get_buffer: _av_frame_get_buffer,
            av_frame_make_writable: _av_frame_make_writable,
            av_frame_move_ref: _av_frame_move_ref,
            av_frame_ref: _av_frame_ref,
            av_frame_set_best_effort_timestamp: _av_frame_set_best_effort_timestamp,
            av_frame_unref: _av_frame_unref,
            av_free: _av_free,
            av_freep: _av_freep,
            av_get_bytes_per_sample: _av_get_bytes_per_sample,
            av_get_channel_layout_nb_channels: _av_get_channel_layout_nb_channels,
            av_get_default_channel_layout: _av_get_default_channel_layout,
            av_get_pix_fmt: _av_get_pix_fmt,
            av_get_pix_fmt_name: _av_get_pix_fmt_name,
            av_get_sample_fmt: _av_get_sample_fmt,
            av_get_sample_fmt_name: _av_get_sample_fmt_name,
            av_get_time_base_q: _av_get_time_base_q,
            av_guess_format: _av_guess_format,
            av_guess_sample_aspect_ratio: _av_guess_sample_aspect_ratio,
            av_index_search_timestamp: _av_index_search_timestamp,
            av_init_packet: _av_init_packet,
            av_int_list_length_for_size: _av_int_list_length_for_size,
            av_interleaved_write_frame: _av_interleaved_write_frame,
            av_log: _av_log,
            av_log_default_callback: _av_log_default_callback,
            av_log_format_line: _av_log_format_line,
            av_log_get_level: _av_log_get_level,
            av_log_set_callback: _av_log_set_callback,
            av_log_set_level: _av_log_set_level,
            av_malloc: _av_malloc,
            av_mallocz: _av_mallocz,
            av_md5_alloc: _av_md5_alloc,
            av_md5_final: _av_md5_final,
            av_md5_init: _av_md5_init,
            av_md5_update: _av_md5_update,
            av_opt_get: _av_opt_get,
            av_opt_set: _av_opt_set,
            av_opt_set_bin: _av_opt_set_bin,
            av_opt_set_channel_layout: _av_opt_set_channel_layout,
            av_opt_set_int: _av_opt_set_int,
            av_opt_set_sample_fmt: _av_opt_set_sample_fmt,
            av_packet_add_side_data: _av_packet_add_side_data,
            av_packet_alloc: _av_packet_alloc,
            av_packet_clone: _av_packet_clone,
            av_packet_free: _av_packet_free,
            av_packet_get_side_data: _av_packet_get_side_data,
            av_packet_move_ref: _av_packet_move_ref,
            av_packet_new_side_data: _av_packet_new_side_data,
            av_packet_ref: _av_packet_ref,
            av_packet_unref: _av_packet_unref,
            av_pix_fmt_desc_get: _av_pix_fmt_desc_get,
            av_read_frame: _av_read_frame,
            av_reduce: _av_reduce,
            av_register_all: _av_register_all,
            av_rescale: _av_rescale,
            av_rescale_q: _av_rescale_q,
            av_rescale_q_rnd: _av_rescale_q_rnd,
            av_rescale_rnd: _av_rescale_rnd,
            av_sample_fmt_is_planar: _av_sample_fmt_is_planar,
            av_samples_alloc: _av_samples_alloc,
            av_samples_alloc_array_and_samples: _av_samples_alloc_array_and_samples,
            av_samples_copy: _av_samples_copy,
            av_samples_get_buffer_size: _av_samples_get_buffer_size,
            av_seek_frame: _av_seek_frame,
            av_strdup: _av_strdup,
            av_stream_get_side_data: _av_stream_get_side_data,
            av_strerror: _av_strerror,
            av_strtod: _av_strtod,
            av_timecode_init_from_string: _av_timecode_init_from_string,
            av_usleep: _av_usleep,
            av_write_frame: _av_write_frame,
            av_write_trailer: _av_write_trailer,
            avcodec_alloc_context3: _avcodec_alloc_context3,
            avcodec_close: _avcodec_close,
            avcodec_descriptor_get_by_name: _avcodec_descriptor_get_by_name,
            avcodec_fill_audio_frame: _avcodec_fill_audio_frame,
            avcodec_find_decoder: _avcodec_find_decoder,
            avcodec_find_decoder_by_name: _avcodec_find_decoder_by_name,
            avcodec_find_encoder: _avcodec_find_encoder,
            avcodec_find_encoder_by_name: _avcodec_find_encoder_by_name,
            avcodec_flush_buffers: _avcodec_flush_buffers,
            avcodec_free_context: _avcodec_free_context,
            avcodec_get_name: _avcodec_get_name,
            avcodec_is_open: _avcodec_is_open,
            avcodec_open2: _avcodec_open2,
            avcodec_parameters_alloc: _avcodec_parameters_alloc,
            avcodec_parameters_copy: _avcodec_parameters_copy,
            avcodec_parameters_free: _avcodec_parameters_free,
            avcodec_parameters_from_context: _avcodec_parameters_from_context,
            avcodec_parameters_to_context: _avcodec_parameters_to_context,
            avcodec_receive_frame: _avcodec_receive_frame,
            avcodec_receive_packet: _avcodec_receive_packet,
            avcodec_register: _avcodec_register,
            avcodec_register_all: _avcodec_register_all,
            avcodec_send_frame: _avcodec_send_frame,
            avcodec_send_packet: _avcodec_send_packet,
            avfilter_get_by_name: _avfilter_get_by_name,
            avfilter_graph_alloc: _avfilter_graph_alloc,
            avfilter_graph_alloc_filter: _avfilter_graph_alloc_filter,
            avfilter_graph_config: _avfilter_graph_config,
            avfilter_graph_create_filter: _avfilter_graph_create_filter,
            avfilter_graph_free: _avfilter_graph_free,
            avfilter_graph_parse_ptr: _avfilter_graph_parse_ptr,
            avfilter_init_str: _avfilter_init_str,
            avfilter_inout_alloc: _avfilter_inout_alloc,
            avfilter_inout_free: _avfilter_inout_free,
            avfilter_link: _avfilter_link,
            avfilter_register_all: _avfilter_register_all,
            avformat_alloc_context: _avformat_alloc_context,
            avformat_alloc_output_context2: _avformat_alloc_output_context2,
            avformat_close_input: _avformat_close_input,
            avformat_find_stream_info: _avformat_find_stream_info,
            avformat_flush: _avformat_flush,
            avformat_free_context: _avformat_free_context,
            avformat_network_init: _avformat_network_init,
            avformat_new_stream: _avformat_new_stream,
            avformat_open_input: _avformat_open_input,
            avformat_seek_file: _avformat_seek_file,
            avformat_write_header: _avformat_write_header,
            avio_alloc_context: _avio_alloc_context,
            avio_close: _avio_close,
            avio_closep: _avio_closep,
            avio_feof: _avio_feof,
            avio_open: _avio_open,
            avio_rb32: _avio_rb32,
            avio_rb64: _avio_rb64,
            avio_rl32: _avio_rl32,
            avio_seek: _avio_seek,
            avio_size: _avio_size,
            avio_skip: _avio_skip,
            avpicture_fill: _avpicture_fill,
            eglChooseConfig: _eglChooseConfig,
            eglCreateContext: _eglCreateContext,
            eglCreateWindowSurface: _eglCreateWindowSurface,
            eglDestroyContext: _eglDestroyContext,
            eglDestroySurface: _eglDestroySurface,
            eglGetCurrentContext: _eglGetCurrentContext,
            eglGetCurrentDisplay: _eglGetCurrentDisplay,
            eglGetDisplay: _eglGetDisplay,
            eglGetError: _eglGetError,
            eglMakeCurrent: _eglMakeCurrent,
            eglQueryContext: _eglQueryContext,
            emscripten_asm_const_int: _emscripten_asm_const_int,
            emscripten_asm_const_int_sync_on_main_thread: _emscripten_asm_const_int_sync_on_main_thread,
            emscripten_cancel_main_loop: _emscripten_cancel_main_loop,
            emscripten_check_blocking_allowed: _emscripten_check_blocking_allowed,
            emscripten_date_now: _emscripten_date_now,
            emscripten_err: _emscripten_err,
            emscripten_exit_with_live_runtime: _emscripten_exit_with_live_runtime,
            emscripten_get_canvas_element_size: _emscripten_get_canvas_element_size,
            emscripten_get_heap_max: _emscripten_get_heap_max,
            emscripten_get_now: _emscripten_get_now,
            emscripten_glActiveTexture: _emscripten_glActiveTexture,
            emscripten_glAttachShader: _emscripten_glAttachShader,
            emscripten_glBeginQuery: _emscripten_glBeginQuery,
            emscripten_glBeginQueryEXT: _emscripten_glBeginQueryEXT,
            emscripten_glBeginTransformFeedback: _emscripten_glBeginTransformFeedback,
            emscripten_glBindAttribLocation: _emscripten_glBindAttribLocation,
            emscripten_glBindBuffer: _emscripten_glBindBuffer,
            emscripten_glBindBufferBase: _emscripten_glBindBufferBase,
            emscripten_glBindBufferRange: _emscripten_glBindBufferRange,
            emscripten_glBindFramebuffer: _emscripten_glBindFramebuffer,
            emscripten_glBindRenderbuffer: _emscripten_glBindRenderbuffer,
            emscripten_glBindSampler: _emscripten_glBindSampler,
            emscripten_glBindTexture: _emscripten_glBindTexture,
            emscripten_glBindTransformFeedback: _emscripten_glBindTransformFeedback,
            emscripten_glBindVertexArray: _emscripten_glBindVertexArray,
            emscripten_glBindVertexArrayOES: _emscripten_glBindVertexArrayOES,
            emscripten_glBlendColor: _emscripten_glBlendColor,
            emscripten_glBlendEquation: _emscripten_glBlendEquation,
            emscripten_glBlendEquationSeparate: _emscripten_glBlendEquationSeparate,
            emscripten_glBlendFunc: _emscripten_glBlendFunc,
            emscripten_glBlendFuncSeparate: _emscripten_glBlendFuncSeparate,
            emscripten_glBlitFramebuffer: _emscripten_glBlitFramebuffer,
            emscripten_glBufferData: _emscripten_glBufferData,
            emscripten_glBufferSubData: _emscripten_glBufferSubData,
            emscripten_glCheckFramebufferStatus: _emscripten_glCheckFramebufferStatus,
            emscripten_glClear: _emscripten_glClear,
            emscripten_glClearBufferfi: _emscripten_glClearBufferfi,
            emscripten_glClearBufferfv: _emscripten_glClearBufferfv,
            emscripten_glClearBufferiv: _emscripten_glClearBufferiv,
            emscripten_glClearBufferuiv: _emscripten_glClearBufferuiv,
            emscripten_glClearColor: _emscripten_glClearColor,
            emscripten_glClearDepthf: _emscripten_glClearDepthf,
            emscripten_glClearStencil: _emscripten_glClearStencil,
            emscripten_glClientWaitSync: _emscripten_glClientWaitSync,
            emscripten_glColorMask: _emscripten_glColorMask,
            emscripten_glCompileShader: _emscripten_glCompileShader,
            emscripten_glCompressedTexImage2D: _emscripten_glCompressedTexImage2D,
            emscripten_glCompressedTexImage3D: _emscripten_glCompressedTexImage3D,
            emscripten_glCompressedTexSubImage2D: _emscripten_glCompressedTexSubImage2D,
            emscripten_glCompressedTexSubImage3D: _emscripten_glCompressedTexSubImage3D,
            emscripten_glCopyBufferSubData: _emscripten_glCopyBufferSubData,
            emscripten_glCopyTexImage2D: _emscripten_glCopyTexImage2D,
            emscripten_glCopyTexSubImage2D: _emscripten_glCopyTexSubImage2D,
            emscripten_glCopyTexSubImage3D: _emscripten_glCopyTexSubImage3D,
            emscripten_glCreateProgram: _emscripten_glCreateProgram,
            emscripten_glCreateShader: _emscripten_glCreateShader,
            emscripten_glCullFace: _emscripten_glCullFace,
            emscripten_glDeleteBuffers: _emscripten_glDeleteBuffers,
            emscripten_glDeleteFramebuffers: _emscripten_glDeleteFramebuffers,
            emscripten_glDeleteProgram: _emscripten_glDeleteProgram,
            emscripten_glDeleteQueries: _emscripten_glDeleteQueries,
            emscripten_glDeleteQueriesEXT: _emscripten_glDeleteQueriesEXT,
            emscripten_glDeleteRenderbuffers: _emscripten_glDeleteRenderbuffers,
            emscripten_glDeleteSamplers: _emscripten_glDeleteSamplers,
            emscripten_glDeleteShader: _emscripten_glDeleteShader,
            emscripten_glDeleteSync: _emscripten_glDeleteSync,
            emscripten_glDeleteTextures: _emscripten_glDeleteTextures,
            emscripten_glDeleteTransformFeedbacks: _emscripten_glDeleteTransformFeedbacks,
            emscripten_glDeleteVertexArrays: _emscripten_glDeleteVertexArrays,
            emscripten_glDeleteVertexArraysOES: _emscripten_glDeleteVertexArraysOES,
            emscripten_glDepthFunc: _emscripten_glDepthFunc,
            emscripten_glDepthMask: _emscripten_glDepthMask,
            emscripten_glDepthRangef: _emscripten_glDepthRangef,
            emscripten_glDetachShader: _emscripten_glDetachShader,
            emscripten_glDisable: _emscripten_glDisable,
            emscripten_glDisableVertexAttribArray: _emscripten_glDisableVertexAttribArray,
            emscripten_glDrawArrays: _emscripten_glDrawArrays,
            emscripten_glDrawArraysInstanced: _emscripten_glDrawArraysInstanced,
            emscripten_glDrawArraysInstancedANGLE: _emscripten_glDrawArraysInstancedANGLE,
            emscripten_glDrawArraysInstancedARB: _emscripten_glDrawArraysInstancedARB,
            emscripten_glDrawArraysInstancedEXT: _emscripten_glDrawArraysInstancedEXT,
            emscripten_glDrawArraysInstancedNV: _emscripten_glDrawArraysInstancedNV,
            emscripten_glDrawBuffers: _emscripten_glDrawBuffers,
            emscripten_glDrawBuffersEXT: _emscripten_glDrawBuffersEXT,
            emscripten_glDrawBuffersWEBGL: _emscripten_glDrawBuffersWEBGL,
            emscripten_glDrawElements: _emscripten_glDrawElements,
            emscripten_glDrawElementsInstanced: _emscripten_glDrawElementsInstanced,
            emscripten_glDrawElementsInstancedANGLE: _emscripten_glDrawElementsInstancedANGLE,
            emscripten_glDrawElementsInstancedARB: _emscripten_glDrawElementsInstancedARB,
            emscripten_glDrawElementsInstancedEXT: _emscripten_glDrawElementsInstancedEXT,
            emscripten_glDrawElementsInstancedNV: _emscripten_glDrawElementsInstancedNV,
            emscripten_glDrawRangeElements: _emscripten_glDrawRangeElements,
            emscripten_glEnable: _emscripten_glEnable,
            emscripten_glEnableVertexAttribArray: _emscripten_glEnableVertexAttribArray,
            emscripten_glEndQuery: _emscripten_glEndQuery,
            emscripten_glEndQueryEXT: _emscripten_glEndQueryEXT,
            emscripten_glEndTransformFeedback: _emscripten_glEndTransformFeedback,
            emscripten_glFenceSync: _emscripten_glFenceSync,
            emscripten_glFinish: _emscripten_glFinish,
            emscripten_glFlush: _emscripten_glFlush,
            emscripten_glFlushMappedBufferRange: _emscripten_glFlushMappedBufferRange,
            emscripten_glFramebufferRenderbuffer: _emscripten_glFramebufferRenderbuffer,
            emscripten_glFramebufferTexture2D: _emscripten_glFramebufferTexture2D,
            emscripten_glFramebufferTextureLayer: _emscripten_glFramebufferTextureLayer,
            emscripten_glFrontFace: _emscripten_glFrontFace,
            emscripten_glGenBuffers: _emscripten_glGenBuffers,
            emscripten_glGenFramebuffers: _emscripten_glGenFramebuffers,
            emscripten_glGenQueries: _emscripten_glGenQueries,
            emscripten_glGenQueriesEXT: _emscripten_glGenQueriesEXT,
            emscripten_glGenRenderbuffers: _emscripten_glGenRenderbuffers,
            emscripten_glGenSamplers: _emscripten_glGenSamplers,
            emscripten_glGenTextures: _emscripten_glGenTextures,
            emscripten_glGenTransformFeedbacks: _emscripten_glGenTransformFeedbacks,
            emscripten_glGenVertexArrays: _emscripten_glGenVertexArrays,
            emscripten_glGenVertexArraysOES: _emscripten_glGenVertexArraysOES,
            emscripten_glGenerateMipmap: _emscripten_glGenerateMipmap,
            emscripten_glGetActiveAttrib: _emscripten_glGetActiveAttrib,
            emscripten_glGetActiveUniform: _emscripten_glGetActiveUniform,
            emscripten_glGetActiveUniformBlockName: _emscripten_glGetActiveUniformBlockName,
            emscripten_glGetActiveUniformBlockiv: _emscripten_glGetActiveUniformBlockiv,
            emscripten_glGetActiveUniformsiv: _emscripten_glGetActiveUniformsiv,
            emscripten_glGetAttachedShaders: _emscripten_glGetAttachedShaders,
            emscripten_glGetAttribLocation: _emscripten_glGetAttribLocation,
            emscripten_glGetBooleanv: _emscripten_glGetBooleanv,
            emscripten_glGetBufferParameteri64v: _emscripten_glGetBufferParameteri64v,
            emscripten_glGetBufferParameteriv: _emscripten_glGetBufferParameteriv,
            emscripten_glGetBufferPointerv: _emscripten_glGetBufferPointerv,
            emscripten_glGetError: _emscripten_glGetError,
            emscripten_glGetFloatv: _emscripten_glGetFloatv,
            emscripten_glGetFragDataLocation: _emscripten_glGetFragDataLocation,
            emscripten_glGetFramebufferAttachmentParameteriv: _emscripten_glGetFramebufferAttachmentParameteriv,
            emscripten_glGetInteger64i_v: _emscripten_glGetInteger64i_v,
            emscripten_glGetInteger64v: _emscripten_glGetInteger64v,
            emscripten_glGetIntegeri_v: _emscripten_glGetIntegeri_v,
            emscripten_glGetIntegerv: _emscripten_glGetIntegerv,
            emscripten_glGetInternalformativ: _emscripten_glGetInternalformativ,
            emscripten_glGetProgramBinary: _emscripten_glGetProgramBinary,
            emscripten_glGetProgramInfoLog: _emscripten_glGetProgramInfoLog,
            emscripten_glGetProgramiv: _emscripten_glGetProgramiv,
            emscripten_glGetQueryObjecti64vEXT: _emscripten_glGetQueryObjecti64vEXT,
            emscripten_glGetQueryObjectivEXT: _emscripten_glGetQueryObjectivEXT,
            emscripten_glGetQueryObjectui64vEXT: _emscripten_glGetQueryObjectui64vEXT,
            emscripten_glGetQueryObjectuiv: _emscripten_glGetQueryObjectuiv,
            emscripten_glGetQueryObjectuivEXT: _emscripten_glGetQueryObjectuivEXT,
            emscripten_glGetQueryiv: _emscripten_glGetQueryiv,
            emscripten_glGetQueryivEXT: _emscripten_glGetQueryivEXT,
            emscripten_glGetRenderbufferParameteriv: _emscripten_glGetRenderbufferParameteriv,
            emscripten_glGetSamplerParameterfv: _emscripten_glGetSamplerParameterfv,
            emscripten_glGetSamplerParameteriv: _emscripten_glGetSamplerParameteriv,
            emscripten_glGetShaderInfoLog: _emscripten_glGetShaderInfoLog,
            emscripten_glGetShaderPrecisionFormat: _emscripten_glGetShaderPrecisionFormat,
            emscripten_glGetShaderSource: _emscripten_glGetShaderSource,
            emscripten_glGetShaderiv: _emscripten_glGetShaderiv,
            emscripten_glGetString: _emscripten_glGetString,
            emscripten_glGetStringi: _emscripten_glGetStringi,
            emscripten_glGetSynciv: _emscripten_glGetSynciv,
            emscripten_glGetTexParameterfv: _emscripten_glGetTexParameterfv,
            emscripten_glGetTexParameteriv: _emscripten_glGetTexParameteriv,
            emscripten_glGetTransformFeedbackVarying: _emscripten_glGetTransformFeedbackVarying,
            emscripten_glGetUniformBlockIndex: _emscripten_glGetUniformBlockIndex,
            emscripten_glGetUniformIndices: _emscripten_glGetUniformIndices,
            emscripten_glGetUniformLocation: _emscripten_glGetUniformLocation,
            emscripten_glGetUniformfv: _emscripten_glGetUniformfv,
            emscripten_glGetUniformiv: _emscripten_glGetUniformiv,
            emscripten_glGetUniformuiv: _emscripten_glGetUniformuiv,
            emscripten_glGetVertexAttribIiv: _emscripten_glGetVertexAttribIiv,
            emscripten_glGetVertexAttribIuiv: _emscripten_glGetVertexAttribIuiv,
            emscripten_glGetVertexAttribPointerv: _emscripten_glGetVertexAttribPointerv,
            emscripten_glGetVertexAttribfv: _emscripten_glGetVertexAttribfv,
            emscripten_glGetVertexAttribiv: _emscripten_glGetVertexAttribiv,
            emscripten_glHint: _emscripten_glHint,
            emscripten_glInvalidateFramebuffer: _emscripten_glInvalidateFramebuffer,
            emscripten_glInvalidateSubFramebuffer: _emscripten_glInvalidateSubFramebuffer,
            emscripten_glIsBuffer: _emscripten_glIsBuffer,
            emscripten_glIsEnabled: _emscripten_glIsEnabled,
            emscripten_glIsFramebuffer: _emscripten_glIsFramebuffer,
            emscripten_glIsProgram: _emscripten_glIsProgram,
            emscripten_glIsQuery: _emscripten_glIsQuery,
            emscripten_glIsQueryEXT: _emscripten_glIsQueryEXT,
            emscripten_glIsRenderbuffer: _emscripten_glIsRenderbuffer,
            emscripten_glIsSampler: _emscripten_glIsSampler,
            emscripten_glIsShader: _emscripten_glIsShader,
            emscripten_glIsSync: _emscripten_glIsSync,
            emscripten_glIsTexture: _emscripten_glIsTexture,
            emscripten_glIsTransformFeedback: _emscripten_glIsTransformFeedback,
            emscripten_glIsVertexArray: _emscripten_glIsVertexArray,
            emscripten_glIsVertexArrayOES: _emscripten_glIsVertexArrayOES,
            emscripten_glLineWidth: _emscripten_glLineWidth,
            emscripten_glLinkProgram: _emscripten_glLinkProgram,
            emscripten_glMapBufferRange: _emscripten_glMapBufferRange,
            emscripten_glPauseTransformFeedback: _emscripten_glPauseTransformFeedback,
            emscripten_glPixelStorei: _emscripten_glPixelStorei,
            emscripten_glPolygonOffset: _emscripten_glPolygonOffset,
            emscripten_glProgramBinary: _emscripten_glProgramBinary,
            emscripten_glProgramParameteri: _emscripten_glProgramParameteri,
            emscripten_glQueryCounterEXT: _emscripten_glQueryCounterEXT,
            emscripten_glReadBuffer: _emscripten_glReadBuffer,
            emscripten_glReadPixels: _emscripten_glReadPixels,
            emscripten_glReleaseShaderCompiler: _emscripten_glReleaseShaderCompiler,
            emscripten_glRenderbufferStorage: _emscripten_glRenderbufferStorage,
            emscripten_glRenderbufferStorageMultisample: _emscripten_glRenderbufferStorageMultisample,
            emscripten_glResumeTransformFeedback: _emscripten_glResumeTransformFeedback,
            emscripten_glSampleCoverage: _emscripten_glSampleCoverage,
            emscripten_glSamplerParameterf: _emscripten_glSamplerParameterf,
            emscripten_glSamplerParameterfv: _emscripten_glSamplerParameterfv,
            emscripten_glSamplerParameteri: _emscripten_glSamplerParameteri,
            emscripten_glSamplerParameteriv: _emscripten_glSamplerParameteriv,
            emscripten_glScissor: _emscripten_glScissor,
            emscripten_glShaderBinary: _emscripten_glShaderBinary,
            emscripten_glShaderSource: _emscripten_glShaderSource,
            emscripten_glStencilFunc: _emscripten_glStencilFunc,
            emscripten_glStencilFuncSeparate: _emscripten_glStencilFuncSeparate,
            emscripten_glStencilMask: _emscripten_glStencilMask,
            emscripten_glStencilMaskSeparate: _emscripten_glStencilMaskSeparate,
            emscripten_glStencilOp: _emscripten_glStencilOp,
            emscripten_glStencilOpSeparate: _emscripten_glStencilOpSeparate,
            emscripten_glTexImage2D: _emscripten_glTexImage2D,
            emscripten_glTexImage3D: _emscripten_glTexImage3D,
            emscripten_glTexParameterf: _emscripten_glTexParameterf,
            emscripten_glTexParameterfv: _emscripten_glTexParameterfv,
            emscripten_glTexParameteri: _emscripten_glTexParameteri,
            emscripten_glTexParameteriv: _emscripten_glTexParameteriv,
            emscripten_glTexStorage2D: _emscripten_glTexStorage2D,
            emscripten_glTexStorage3D: _emscripten_glTexStorage3D,
            emscripten_glTexSubImage2D: _emscripten_glTexSubImage2D,
            emscripten_glTexSubImage3D: _emscripten_glTexSubImage3D,
            emscripten_glTransformFeedbackVaryings: _emscripten_glTransformFeedbackVaryings,
            emscripten_glUniform1f: _emscripten_glUniform1f,
            emscripten_glUniform1fv: _emscripten_glUniform1fv,
            emscripten_glUniform1i: _emscripten_glUniform1i,
            emscripten_glUniform1iv: _emscripten_glUniform1iv,
            emscripten_glUniform1ui: _emscripten_glUniform1ui,
            emscripten_glUniform1uiv: _emscripten_glUniform1uiv,
            emscripten_glUniform2f: _emscripten_glUniform2f,
            emscripten_glUniform2fv: _emscripten_glUniform2fv,
            emscripten_glUniform2i: _emscripten_glUniform2i,
            emscripten_glUniform2iv: _emscripten_glUniform2iv,
            emscripten_glUniform2ui: _emscripten_glUniform2ui,
            emscripten_glUniform2uiv: _emscripten_glUniform2uiv,
            emscripten_glUniform3f: _emscripten_glUniform3f,
            emscripten_glUniform3fv: _emscripten_glUniform3fv,
            emscripten_glUniform3i: _emscripten_glUniform3i,
            emscripten_glUniform3iv: _emscripten_glUniform3iv,
            emscripten_glUniform3ui: _emscripten_glUniform3ui,
            emscripten_glUniform3uiv: _emscripten_glUniform3uiv,
            emscripten_glUniform4f: _emscripten_glUniform4f,
            emscripten_glUniform4fv: _emscripten_glUniform4fv,
            emscripten_glUniform4i: _emscripten_glUniform4i,
            emscripten_glUniform4iv: _emscripten_glUniform4iv,
            emscripten_glUniform4ui: _emscripten_glUniform4ui,
            emscripten_glUniform4uiv: _emscripten_glUniform4uiv,
            emscripten_glUniformBlockBinding: _emscripten_glUniformBlockBinding,
            emscripten_glUniformMatrix2fv: _emscripten_glUniformMatrix2fv,
            emscripten_glUniformMatrix2x3fv: _emscripten_glUniformMatrix2x3fv,
            emscripten_glUniformMatrix2x4fv: _emscripten_glUniformMatrix2x4fv,
            emscripten_glUniformMatrix3fv: _emscripten_glUniformMatrix3fv,
            emscripten_glUniformMatrix3x2fv: _emscripten_glUniformMatrix3x2fv,
            emscripten_glUniformMatrix3x4fv: _emscripten_glUniformMatrix3x4fv,
            emscripten_glUniformMatrix4fv: _emscripten_glUniformMatrix4fv,
            emscripten_glUniformMatrix4x2fv: _emscripten_glUniformMatrix4x2fv,
            emscripten_glUniformMatrix4x3fv: _emscripten_glUniformMatrix4x3fv,
            emscripten_glUnmapBuffer: _emscripten_glUnmapBuffer,
            emscripten_glUseProgram: _emscripten_glUseProgram,
            emscripten_glValidateProgram: _emscripten_glValidateProgram,
            emscripten_glVertexAttrib1f: _emscripten_glVertexAttrib1f,
            emscripten_glVertexAttrib1fv: _emscripten_glVertexAttrib1fv,
            emscripten_glVertexAttrib2f: _emscripten_glVertexAttrib2f,
            emscripten_glVertexAttrib2fv: _emscripten_glVertexAttrib2fv,
            emscripten_glVertexAttrib3f: _emscripten_glVertexAttrib3f,
            emscripten_glVertexAttrib3fv: _emscripten_glVertexAttrib3fv,
            emscripten_glVertexAttrib4f: _emscripten_glVertexAttrib4f,
            emscripten_glVertexAttrib4fv: _emscripten_glVertexAttrib4fv,
            emscripten_glVertexAttribDivisor: _emscripten_glVertexAttribDivisor,
            emscripten_glVertexAttribDivisorANGLE: _emscripten_glVertexAttribDivisorANGLE,
            emscripten_glVertexAttribDivisorARB: _emscripten_glVertexAttribDivisorARB,
            emscripten_glVertexAttribDivisorEXT: _emscripten_glVertexAttribDivisorEXT,
            emscripten_glVertexAttribDivisorNV: _emscripten_glVertexAttribDivisorNV,
            emscripten_glVertexAttribI4i: _emscripten_glVertexAttribI4i,
            emscripten_glVertexAttribI4iv: _emscripten_glVertexAttribI4iv,
            emscripten_glVertexAttribI4ui: _emscripten_glVertexAttribI4ui,
            emscripten_glVertexAttribI4uiv: _emscripten_glVertexAttribI4uiv,
            emscripten_glVertexAttribIPointer: _emscripten_glVertexAttribIPointer,
            emscripten_glVertexAttribPointer: _emscripten_glVertexAttribPointer,
            emscripten_glViewport: _emscripten_glViewport,
            emscripten_glWaitSync: _emscripten_glWaitSync,
            emscripten_has_threading_support: _emscripten_has_threading_support,
            emscripten_log: _emscripten_log,
            emscripten_num_logical_cores: _emscripten_num_logical_cores,
            emscripten_out: _emscripten_out,
            emscripten_performance_now: _emscripten_performance_now,
            emscripten_promise_destroy: _emscripten_promise_destroy,
            emscripten_promise_resolve: _emscripten_promise_resolve,
            emscripten_resize_heap: _emscripten_resize_heap,
            emscripten_set_canvas_element_size: _emscripten_set_canvas_element_size,
            emscripten_set_main_loop_arg: _emscripten_set_main_loop_arg,
            emscripten_webgl_create_context: _emscripten_webgl_create_context,
            emscripten_webgl_destroy_context: _emscripten_webgl_destroy_context,
            emscripten_webgl_get_context_attributes: _emscripten_webgl_get_context_attributes,
            emscripten_webgl_get_current_context: _emscripten_webgl_get_current_context,
            emscripten_webgl_make_context_current: _emscripten_webgl_make_context_current,
            environ_get: _environ_get,
            environ_sizes_get: _environ_sizes_get,
            exit: _exit,
            ff_h2645_packet_split: _ff_h2645_packet_split,
            ff_h2645_packet_uninit: _ff_h2645_packet_uninit,
            getentropy: _getentropy,
            glActiveTexture: _glActiveTexture,
            glAttachShader: _glAttachShader,
            glBindAttribLocation: _glBindAttribLocation,
            glBindBuffer: _glBindBuffer,
            glBindBufferBase: _glBindBufferBase,
            glBindBufferRange: _glBindBufferRange,
            glBindFramebuffer: _glBindFramebuffer,
            glBindRenderbuffer: _glBindRenderbuffer,
            glBindSampler: _glBindSampler,
            glBindTexture: _glBindTexture,
            glBindVertexArray: _glBindVertexArray,
            glBlendColor: _glBlendColor,
            glBlendEquation: _glBlendEquation,
            glBlendEquationSeparate: _glBlendEquationSeparate,
            glBlendFunc: _glBlendFunc,
            glBlendFuncSeparate: _glBlendFuncSeparate,
            glBlitFramebuffer: _glBlitFramebuffer,
            glBufferData: _glBufferData,
            glBufferSubData: _glBufferSubData,
            glCheckFramebufferStatus: _glCheckFramebufferStatus,
            glClear: _glClear,
            glClearColor: _glClearColor,
            glClearDepthf: _glClearDepthf,
            glClearStencil: _glClearStencil,
            glClientWaitSync: _glClientWaitSync,
            glColorMask: _glColorMask,
            glCompileShader: _glCompileShader,
            glCompressedTexImage2D: _glCompressedTexImage2D,
            glCompressedTexImage3D: _glCompressedTexImage3D,
            glCompressedTexSubImage2D: _glCompressedTexSubImage2D,
            glCompressedTexSubImage3D: _glCompressedTexSubImage3D,
            glCreateProgram: _glCreateProgram,
            glCreateShader: _glCreateShader,
            glCullFace: _glCullFace,
            glDeleteBuffers: _glDeleteBuffers,
            glDeleteFramebuffers: _glDeleteFramebuffers,
            glDeleteProgram: _glDeleteProgram,
            glDeleteRenderbuffers: _glDeleteRenderbuffers,
            glDeleteSamplers: _glDeleteSamplers,
            glDeleteShader: _glDeleteShader,
            glDeleteSync: _glDeleteSync,
            glDeleteTextures: _glDeleteTextures,
            glDepthFunc: _glDepthFunc,
            glDepthMask: _glDepthMask,
            glDepthRangef: _glDepthRangef,
            glDetachShader: _glDetachShader,
            glDisable: _glDisable,
            glDisableVertexAttribArray: _glDisableVertexAttribArray,
            glDrawArrays: _glDrawArrays,
            glDrawArraysInstanced: _glDrawArraysInstanced,
            glDrawBuffers: _glDrawBuffers,
            glDrawElements: _glDrawElements,
            glDrawElementsInstanced: _glDrawElementsInstanced,
            glEnable: _glEnable,
            glEnableVertexAttribArray: _glEnableVertexAttribArray,
            glFenceSync: _glFenceSync,
            glFinish: _glFinish,
            glFlush: _glFlush,
            glFramebufferRenderbuffer: _glFramebufferRenderbuffer,
            glFramebufferTexture2D: _glFramebufferTexture2D,
            glFramebufferTextureLayer: _glFramebufferTextureLayer,
            glFrontFace: _glFrontFace,
            glGenBuffers: _glGenBuffers,
            glGenFramebuffers: _glGenFramebuffers,
            glGenRenderbuffers: _glGenRenderbuffers,
            glGenSamplers: _glGenSamplers,
            glGenTextures: _glGenTextures,
            glGenerateMipmap: _glGenerateMipmap,
            glGetActiveAttrib: _glGetActiveAttrib,
            glGetActiveUniform: _glGetActiveUniform,
            glGetActiveUniformBlockName: _glGetActiveUniformBlockName,
            glGetActiveUniformBlockiv: _glGetActiveUniformBlockiv,
            glGetActiveUniformsiv: _glGetActiveUniformsiv,
            glGetAttachedShaders: _glGetAttachedShaders,
            glGetAttribLocation: _glGetAttribLocation,
            glGetBooleanv: _glGetBooleanv,
            glGetError: _glGetError,
            glGetFloatv: _glGetFloatv,
            glGetFramebufferAttachmentParameteriv: _glGetFramebufferAttachmentParameteriv,
            glGetIntegerv: _glGetIntegerv,
            glGetProgramBinary: _glGetProgramBinary,
            glGetProgramInfoLog: _glGetProgramInfoLog,
            glGetProgramiv: _glGetProgramiv,
            glGetShaderInfoLog: _glGetShaderInfoLog,
            glGetShaderiv: _glGetShaderiv,
            glGetString: _glGetString,
            glGetStringi: _glGetStringi,
            glGetSynciv: _glGetSynciv,
            glGetTexParameteriv: _glGetTexParameteriv,
            glGetUniformLocation: _glGetUniformLocation,
            glGetVertexAttribiv: _glGetVertexAttribiv,
            glIsBuffer: _glIsBuffer,
            glIsEnabled: _glIsEnabled,
            glIsFramebuffer: _glIsFramebuffer,
            glIsProgram: _glIsProgram,
            glIsRenderbuffer: _glIsRenderbuffer,
            glIsSampler: _glIsSampler,
            glIsTexture: _glIsTexture,
            glLinkProgram: _glLinkProgram,
            glMapBufferRange: _glMapBufferRange,
            glPixelStorei: _glPixelStorei,
            glPolygonOffset: _glPolygonOffset,
            glProgramBinary: _glProgramBinary,
            glProgramParameteri: _glProgramParameteri,
            glReadBuffer: _glReadBuffer,
            glReadPixels: _glReadPixels,
            glReleaseShaderCompiler: _glReleaseShaderCompiler,
            glRenderbufferStorage: _glRenderbufferStorage,
            glRenderbufferStorageMultisample: _glRenderbufferStorageMultisample,
            glSamplerParameteri: _glSamplerParameteri,
            glScissor: _glScissor,
            glShaderSource: _glShaderSource,
            glStencilFunc: _glStencilFunc,
            glStencilFuncSeparate: _glStencilFuncSeparate,
            glStencilMask: _glStencilMask,
            glStencilMaskSeparate: _glStencilMaskSeparate,
            glStencilOp: _glStencilOp,
            glStencilOpSeparate: _glStencilOpSeparate,
            glTexImage2D: _glTexImage2D,
            glTexImage3D: _glTexImage3D,
            glTexParameterf: _glTexParameterf,
            glTexParameteri: _glTexParameteri,
            glTexStorage2D: _glTexStorage2D,
            glTexStorage3D: _glTexStorage3D,
            glTexSubImage2D: _glTexSubImage2D,
            glTexSubImage3D: _glTexSubImage3D,
            glUniform1f: _glUniform1f,
            glUniform1fv: _glUniform1fv,
            glUniform1i: _glUniform1i,
            glUniform1iv: _glUniform1iv,
            glUniform1uiv: _glUniform1uiv,
            glUniform2f: _glUniform2f,
            glUniform2fv: _glUniform2fv,
            glUniform2iv: _glUniform2iv,
            glUniform2uiv: _glUniform2uiv,
            glUniform3f: _glUniform3f,
            glUniform3fv: _glUniform3fv,
            glUniform3iv: _glUniform3iv,
            glUniform3uiv: _glUniform3uiv,
            glUniform4f: _glUniform4f,
            glUniform4fv: _glUniform4fv,
            glUniform4iv: _glUniform4iv,
            glUniform4uiv: _glUniform4uiv,
            glUniformBlockBinding: _glUniformBlockBinding,
            glUniformMatrix2fv: _glUniformMatrix2fv,
            glUniformMatrix2x3fv: _glUniformMatrix2x3fv,
            glUniformMatrix3fv: _glUniformMatrix3fv,
            glUniformMatrix4fv: _glUniformMatrix4fv,
            glUnmapBuffer: _glUnmapBuffer,
            glUseProgram: _glUseProgram,
            glVertexAttribDivisor: _glVertexAttribDivisor,
            glVertexAttribIPointer: _glVertexAttribIPointer,
            glVertexAttribPointer: _glVertexAttribPointer,
            glViewport: _glViewport,
            glWaitSync: _glWaitSync,
            isSafari: _isSafari,
            isWebCodecSupported: _isWebCodecSupported,
            lv_api_callback_to_main_thread: _lv_api_callback_to_main_thread,
            lv_api_ret_to_main_thread_internal: _lv_api_ret_to_main_thread_internal,
            memory: wasmMemory || Module.wasmMemory,
            registerBlobIOThread: _registerBlobIOThread,
            register_tejs_http: _register_tejs_http,
            strftime: _strftime,
            strftime_l: _strftime_l,
            swr_alloc: _swr_alloc,
            swr_alloc_set_opts: _swr_alloc_set_opts,
            swr_close: _swr_close,
            swr_convert: _swr_convert,
            swr_free: _swr_free,
            swr_get_delay: _swr_get_delay,
            swr_get_out_samples: _swr_get_out_samples,
            swr_init: _swr_init,
            swr_is_initialized: _swr_is_initialized,
            sws_freeContext: _sws_freeContext,
            sws_getCoefficients: _sws_getCoefficients,
            sws_getContext: _sws_getContext,
            sws_scale: _sws_scale,
            sws_setColorspaceDetails: _sws_setColorspaceDetails,
            tt_H2645NAL_freep: _tt_H2645NAL_freep,
            tt_H2645NAL_get_data: _tt_H2645NAL_get_data,
            tt_H2645NAL_get_data_size: _tt_H2645NAL_get_data_size,
            tt_H2645NAL_malloc: _tt_H2645NAL_malloc,
            tt_h2645_extract_rbsp: _tt_h2645_extract_rbsp,
            uuid_generate: _uuid_generate,
            uuid_unparse_lower: _uuid_unparse_lower,
            veFS_file_delete: _veFS_file_delete,
            veFS_file_getSize: _veFS_file_getSize,
            veFS_file_handle_alloc: _veFS_file_handle_alloc,
            veFS_file_open: _veFS_file_open,
            veFS_file_read: _veFS_file_read,
            veFS_file_setSize: _veFS_file_setSize,
            veFS_file_write: _veFS_file_write,
            ve_register_main_loop_arg: _ve_register_main_loop_arg,
            ve_trigger_thread_main_loop: _ve_trigger_thread_main_loop,
            ve_unregister_main_loop: _ve_unregister_main_loop,
            velog_dump: _velog_dump,
            velog_get_date_string_internal: _velog_get_date_string_internal,
            velog_js_dump_line: _velog_js_dump_line,
            velog_send_js_buffer_to_main_thread: _velog_send_js_buffer_to_main_thread,
            vesdkCreateOffscreenCanvas: _vesdkCreateOffscreenCanvas,
            vesdkDeleteOffscreenCanvas: _vesdkDeleteOffscreenCanvas,
            vesdkInitWebGLLoseContext: _vesdkInitWebGLLoseContext,
            vesdkPrintGLInfo: _vesdkPrintGLInfo,
            vesdkProfileRendererJS: _vesdkProfileRendererJS,
            vesdkSendGLPid: _vesdkSendGLPid,
            vesdkSetWebglcontextlostCallback: _vesdkSetWebglcontextlostCallback,
            vesdkSetWebglcontextrestoreCallback: _vesdkSetWebglcontextrestoreCallback,
            vesdkSimulateContextLost: _vesdkSimulateContextLost,
            vesdkSimulateContextLostAndRestored: _vesdkSimulateContextLostAndRestored,
            vesdkSimulateContextRestored: _vesdkSimulateContextRestored,
            vesdk_is_264_simd_enabled: _vesdk_is_264_simd_enabled,
            vesdk_log_pthread_create_js: _vesdk_log_pthread_create_js,
            vesdk_set_264_simd: _vesdk_set_264_simd
        }
          , wasmExports = createWasm()
          , ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports.__wasm_call_ctors)()
          , ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports.__wasm_apply_data_relocs)()
          , _malloc = Module._malloc = e => (_malloc = Module._malloc = wasmExports.malloc)(e)
          , _free = Module._free = e => (_free = Module._free = wasmExports.free)(e)
          , _fclose = e => (_fclose = wasmExports.fclose)(e)
          , _fwrite = (e, t, r, i) => (_fwrite = wasmExports.fwrite)(e, t, r, i)
          , _strlen = e => (_strlen = wasmExports.strlen)(e)
          , _enableCallFuncLog = Module._enableCallFuncLog = e => (_enableCallFuncLog = Module._enableCallFuncLog = wasmExports.enableCallFuncLog)(e)
          , _vesdk_profileLvApi = Module._vesdk_profileLvApi = e => (_vesdk_profileLvApi = Module._vesdk_profileLvApi = wasmExports.vesdk_profileLvApi)(e)
          , _pthread_create = (e, t, r, i) => (_pthread_create = wasmExports.pthread_create)(e, t, r, i)
          , _memcmp = (e, t, r) => (_memcmp = wasmExports.memcmp)(e, t, r)
          , _pthread_self = Module._pthread_self = () => (_pthread_self = Module._pthread_self = wasmExports.pthread_self)()
          , ___errno_location = () => (___errno_location = wasmExports.__errno_location)()
          , _strtoll = (e, t, r) => (_strtoll = wasmExports.strtoll)(e, t, r)
          , _strtod = (e, t) => (_strtod = wasmExports.strtod)(e, t)
          , _snprintf = (e, t, r, i) => (_snprintf = wasmExports.snprintf)(e, t, r, i)
          , _strcpy = (e, t) => (_strcpy = wasmExports.strcpy)(e, t)
          , _TEAudioWorkletInitCallback = Module._TEAudioWorkletInitCallback = (e, t) => (_TEAudioWorkletInitCallback = Module._TEAudioWorkletInitCallback = wasmExports.TEAudioWorkletInitCallback)(e, t)
          , _TEAudioWorkletPauseCallback = Module._TEAudioWorkletPauseCallback = (e, t) => (_TEAudioWorkletPauseCallback = Module._TEAudioWorkletPauseCallback = wasmExports.TEAudioWorkletPauseCallback)(e, t)
          , _TEAudioWorkletResumeCallback = Module._TEAudioWorkletResumeCallback = (e, t) => (_TEAudioWorkletResumeCallback = Module._TEAudioWorkletResumeCallback = wasmExports.TEAudioWorkletResumeCallback)(e, t)
          , _strcmp = (e, t) => (_strcmp = wasmExports.strcmp)(e, t)
          , _memchr = (e, t, r) => (_memchr = wasmExports.memchr)(e, t, r)
          , _clock = () => (_clock = wasmExports.clock)()
          , _strncmp = (e, t, r) => (_strncmp = wasmExports.strncmp)(e, t, r)
          , _strstr = (e, t) => (_strstr = wasmExports.strstr)(e, t)
          , _atoi = e => (_atoi = wasmExports.atoi)(e)
          , _setFrameDump = Module._setFrameDump = (e, t) => (_setFrameDump = Module._setFrameDump = wasmExports.setFrameDump)(e, t)
          , _atof = e => (_atof = wasmExports.atof)(e)
          , _fdopen = (e, t) => (_fdopen = wasmExports.fdopen)(e, t)
          , _strtol = (e, t, r) => (_strtol = wasmExports.strtol)(e, t, r)
          , _lseek = (e, t, r) => (_lseek = wasmExports.lseek)(e, t, r)
          , _open = (e, t, r) => (_open = wasmExports.open)(e, t, r)
          , _close = e => (_close = wasmExports.close)(e)
          , _fstat = (e, t) => (_fstat = wasmExports.fstat)(e, t)
          , _access = (e, t) => (_access = wasmExports.access)(e, t)
          , _TEApplogReport = Module._TEApplogReport = (e, t, r) => (_TEApplogReport = Module._TEApplogReport = wasmExports.TEApplogReport)(e, t, r)
          , _wasm_app_report = Module._wasm_app_report = (e, t, r) => (_wasm_app_report = Module._wasm_app_report = wasmExports.wasm_app_report)(e, t, r)
          , _vsnprintf = (e, t, r, i) => (_vsnprintf = wasmExports.vsnprintf)(e, t, r, i)
          , ___logExceptionStackInVELOG = Module.___logExceptionStackInVELOG = (e, t) => (___logExceptionStackInVELOG = Module.___logExceptionStackInVELOG = wasmExports.__logExceptionStackInVELOG)(e, t)
          , ___logInVELOG = Module.___logInVELOG = e => (___logInVELOG = Module.___logInVELOG = wasmExports.__logInVELOG)(e)
          , _velog_trigger_dump = () => (_velog_trigger_dump = wasmExports.velog_trigger_dump)()
          , _posix_memalign = (e, t, r) => (_posix_memalign = wasmExports.posix_memalign)(e, t, r)
          , _sscanf = (e, t, r) => (_sscanf = wasmExports.sscanf)(e, t, r)
          , _sysconf = e => (_sysconf = wasmExports.sysconf)(e)
          , _pthread_once = (e, t) => (_pthread_once = wasmExports.pthread_once)(e, t)
          , _realloc = (e, t) => (_realloc = wasmExports.realloc)(e, t)
          , _strncpy = (e, t, r) => (_strncpy = wasmExports.strncpy)(e, t, r)
          , _strchr = (e, t) => (_strchr = wasmExports.strchr)(e, t)
          , _wasmfs_before_preload = Module._wasmfs_before_preload = () => (_wasmfs_before_preload = Module._wasmfs_before_preload = wasmExports.wasmfs_before_preload)()
          , _simulateWebGLLostContext = Module._simulateWebGLLostContext = () => (_simulateWebGLLostContext = Module._simulateWebGLLostContext = wasmExports.simulateWebGLLostContext)()
          , _simulateWebGLRestoreContext = Module._simulateWebGLRestoreContext = () => (_simulateWebGLRestoreContext = Module._simulateWebGLRestoreContext = wasmExports.simulateWebGLRestoreContext)()
          , _simulateWebGLLostContextAndRestored = Module._simulateWebGLLostContextAndRestored = e => (_simulateWebGLLostContextAndRestored = Module._simulateWebGLLostContextAndRestored = wasmExports.simulateWebGLLostContextAndRestored)(e)
          , _vesdk_profileRenderer = Module._vesdk_profileRenderer = e => (_vesdk_profileRenderer = Module._vesdk_profileRenderer = wasmExports.vesdk_profileRenderer)(e)
          , __Z20webglContextCallbackiPKvPv = Module.__Z20webglContextCallbackiPKvPv = (e, t, r) => (__Z20webglContextCallbackiPKvPv = Module.__Z20webglContextCallbackiPKvPv = wasmExports._Z20webglContextCallbackiPKvPv)(e, t, r)
          , _atan2f = (e, t) => (_atan2f = wasmExports.atan2f)(e, t)
          , _stat = (e, t) => (_stat = wasmExports.stat)(e, t)
          , _TEJSEvent_StreamFetch_OnHeaderReceived = Module._TEJSEvent_StreamFetch_OnHeaderReceived = (e, t, r, i) => (_TEJSEvent_StreamFetch_OnHeaderReceived = Module._TEJSEvent_StreamFetch_OnHeaderReceived = wasmExports.TEJSEvent_StreamFetch_OnHeaderReceived)(e, t, r, i)
          , _TEJSEvent_StreamFetch_OnFetchDone = Module._TEJSEvent_StreamFetch_OnFetchDone = (e, t) => (_TEJSEvent_StreamFetch_OnFetchDone = Module._TEJSEvent_StreamFetch_OnFetchDone = wasmExports.TEJSEvent_StreamFetch_OnFetchDone)(e, t)
          , _TEJSEvent_StreamFetch_OnFetchProgress = Module._TEJSEvent_StreamFetch_OnFetchProgress = (e, t, r, i) => (_TEJSEvent_StreamFetch_OnFetchProgress = Module._TEJSEvent_StreamFetch_OnFetchProgress = wasmExports.TEJSEvent_StreamFetch_OnFetchProgress)(e, t, r, i)
          , _TEJSEvent_StreamFetch_OnFail = Module._TEJSEvent_StreamFetch_OnFail = e => (_TEJSEvent_StreamFetch_OnFail = Module._TEJSEvent_StreamFetch_OnFail = wasmExports.TEJSEvent_StreamFetch_OnFail)(e)
          , _TEJSEventFetch_Fetch_OnHeaderReceived = Module._TEJSEventFetch_Fetch_OnHeaderReceived = (e, t, r, i) => (_TEJSEventFetch_Fetch_OnHeaderReceived = Module._TEJSEventFetch_Fetch_OnHeaderReceived = wasmExports.TEJSEventFetch_Fetch_OnHeaderReceived)(e, t, r, i)
          , _TEJSEventFetch_Fetch_OnBodyProgress = Module._TEJSEventFetch_Fetch_OnBodyProgress = (e, t, r) => (_TEJSEventFetch_Fetch_OnBodyProgress = Module._TEJSEventFetch_Fetch_OnBodyProgress = wasmExports.TEJSEventFetch_Fetch_OnBodyProgress)(e, t, r)
          , _TEJSEventFetch_Fetch_OnBodyDone = Module._TEJSEventFetch_Fetch_OnBodyDone = e => (_TEJSEventFetch_Fetch_OnBodyDone = Module._TEJSEventFetch_Fetch_OnBodyDone = wasmExports.TEJSEventFetch_Fetch_OnBodyDone)(e)
          , _TEJSEventFetch_Fetch_OnBodyReceived = Module._TEJSEventFetch_Fetch_OnBodyReceived = (e, t, r) => (_TEJSEventFetch_Fetch_OnBodyReceived = Module._TEJSEventFetch_Fetch_OnBodyReceived = wasmExports.TEJSEventFetch_Fetch_OnBodyReceived)(e, t, r)
          , _TEJSEventFetch_Fetch_OnFail = Module._TEJSEventFetch_Fetch_OnFail = (e, t) => (_TEJSEventFetch_Fetch_OnFail = Module._TEJSEventFetch_Fetch_OnFail = wasmExports.TEJSEventFetch_Fetch_OnFail)(e, t)
          , _TEJSEvent_IDB_Del_error = Module._TEJSEvent_IDB_Del_error = e => (_TEJSEvent_IDB_Del_error = Module._TEJSEvent_IDB_Del_error = wasmExports.TEJSEvent_IDB_Del_error)(e)
          , _TEJSEvent_IDB_Del_complete = Module._TEJSEvent_IDB_Del_complete = e => (_TEJSEvent_IDB_Del_complete = Module._TEJSEvent_IDB_Del_complete = wasmExports.TEJSEvent_IDB_Del_complete)(e)
          , _TEJSEvent_IDB_Get_error = Module._TEJSEvent_IDB_Get_error = e => (_TEJSEvent_IDB_Get_error = Module._TEJSEvent_IDB_Get_error = wasmExports.TEJSEvent_IDB_Get_error)(e)
          , _TEJSEvent_IDB_Get_success = Module._TEJSEvent_IDB_Get_success = (e, t, r, i, n) => (_TEJSEvent_IDB_Get_success = Module._TEJSEvent_IDB_Get_success = wasmExports.TEJSEvent_IDB_Get_success)(e, t, r, i, n)
          , _TEJSEvent_IDB_Open_success = Module._TEJSEvent_IDB_Open_success = (e, t) => (_TEJSEvent_IDB_Open_success = Module._TEJSEvent_IDB_Open_success = wasmExports.TEJSEvent_IDB_Open_success)(e, t)
          , _TEJSEvent_IDB_Open_error = Module._TEJSEvent_IDB_Open_error = e => (_TEJSEvent_IDB_Open_error = Module._TEJSEvent_IDB_Open_error = wasmExports.TEJSEvent_IDB_Open_error)(e)
          , _TEJSEvent_IDB_Open_upgrade = Module._TEJSEvent_IDB_Open_upgrade = e => (_TEJSEvent_IDB_Open_upgrade = Module._TEJSEvent_IDB_Open_upgrade = wasmExports.TEJSEvent_IDB_Open_upgrade)(e)
          , _TEJSEvent_IDB_Open_upgrade_complete = Module._TEJSEvent_IDB_Open_upgrade_complete = e => (_TEJSEvent_IDB_Open_upgrade_complete = Module._TEJSEvent_IDB_Open_upgrade_complete = wasmExports.TEJSEvent_IDB_Open_upgrade_complete)(e)
          , _TEJSEvent_IDB_Save_complete = Module._TEJSEvent_IDB_Save_complete = e => (_TEJSEvent_IDB_Save_complete = Module._TEJSEvent_IDB_Save_complete = wasmExports.TEJSEvent_IDB_Save_complete)(e)
          , _TEJSEvent_IDB_Save_error = Module._TEJSEvent_IDB_Save_error = e => (_TEJSEvent_IDB_Save_error = Module._TEJSEvent_IDB_Save_error = wasmExports.TEJSEvent_IDB_Save_error)(e)
          , _SendHttpOnLoad = Module._SendHttpOnLoad = (e, t, r, i, n) => (_SendHttpOnLoad = Module._SendHttpOnLoad = wasmExports.SendHttpOnLoad)(e, t, r, i, n)
          , _SendHttpOnError = Module._SendHttpOnError = (e, t) => (_SendHttpOnError = Module._SendHttpOnError = wasmExports.SendHttpOnError)(e, t)
          , _vesdk_log_custom_pthread_create = Module._vesdk_log_custom_pthread_create = (e, t, r, i, n) => (_vesdk_log_custom_pthread_create = Module._vesdk_log_custom_pthread_create = wasmExports.vesdk_log_custom_pthread_create)(e, t, r, i, n)
          , _TEJSEvent_WebCodec_ConfigResult = Module._TEJSEvent_WebCodec_ConfigResult = (e, t) => (_TEJSEvent_WebCodec_ConfigResult = Module._TEJSEvent_WebCodec_ConfigResult = wasmExports.TEJSEvent_WebCodec_ConfigResult)(e, t)
          , _enableWebCodecBlockFlush = Module._enableWebCodecBlockFlush = e => (_enableWebCodecBlockFlush = Module._enableWebCodecBlockFlush = wasmExports.enableWebCodecBlockFlush)(e)
          , _TEJSEvent_WebCodec_On_Output = Module._TEJSEvent_WebCodec_On_Output = (e, t, r, i, n, o, a) => (_TEJSEvent_WebCodec_On_Output = Module._TEJSEvent_WebCodec_On_Output = wasmExports.TEJSEvent_WebCodec_On_Output)(e, t, r, i, n, o, a)
          , _TEJSEvent_WebCodec_On_Output_HW_Frame = Module._TEJSEvent_WebCodec_On_Output_HW_Frame = (e, t, r, i, n, o) => (_TEJSEvent_WebCodec_On_Output_HW_Frame = Module._TEJSEvent_WebCodec_On_Output_HW_Frame = wasmExports.TEJSEvent_WebCodec_On_Output_HW_Frame)(e, t, r, i, n, o)
          , _TEJSEvent_WebCodec_OnFramesInJSUpdated = Module._TEJSEvent_WebCodec_OnFramesInJSUpdated = (e, t) => (_TEJSEvent_WebCodec_OnFramesInJSUpdated = Module._TEJSEvent_WebCodec_OnFramesInJSUpdated = wasmExports.TEJSEvent_WebCodec_OnFramesInJSUpdated)(e, t)
          , _TEJSEvent_WebCodec_On_UpdateQueueSize = Module._TEJSEvent_WebCodec_On_UpdateQueueSize = (e, t) => (_TEJSEvent_WebCodec_On_UpdateQueueSize = Module._TEJSEvent_WebCodec_On_UpdateQueueSize = wasmExports.TEJSEvent_WebCodec_On_UpdateQueueSize)(e, t)
          , _TEJSEvent_WebCodec_On_Flush_Done = Module._TEJSEvent_WebCodec_On_Flush_Done = (e, t) => (_TEJSEvent_WebCodec_On_Flush_Done = Module._TEJSEvent_WebCodec_On_Flush_Done = wasmExports.TEJSEvent_WebCodec_On_Flush_Done)(e, t)
          , _TEJSEvent_WebCodec_On_Error = Module._TEJSEvent_WebCodec_On_Error = (e, t) => (_TEJSEvent_WebCodec_On_Error = Module._TEJSEvent_WebCodec_On_Error = wasmExports.TEJSEvent_WebCodec_On_Error)(e, t)
          , _TEJSEvent_WebCodec_Is_Frame_In_Queue = Module._TEJSEvent_WebCodec_Is_Frame_In_Queue = (e, t) => (_TEJSEvent_WebCodec_Is_Frame_In_Queue = Module._TEJSEvent_WebCodec_Is_Frame_In_Queue = wasmExports.TEJSEvent_WebCodec_Is_Frame_In_Queue)(e, t)
          , _TEJSEvent_WebCodec_Clear_Frames = Module._TEJSEvent_WebCodec_Clear_Frames = e => (_TEJSEvent_WebCodec_Clear_Frames = Module._TEJSEvent_WebCodec_Clear_Frames = wasmExports.TEJSEvent_WebCodec_Clear_Frames)(e)
          , _TEJSEvent_WebCodec_Get_Frames_Count = Module._TEJSEvent_WebCodec_Get_Frames_Count = e => (_TEJSEvent_WebCodec_Get_Frames_Count = Module._TEJSEvent_WebCodec_Get_Frames_Count = wasmExports.TEJSEvent_WebCodec_Get_Frames_Count)(e)
          , _TEJSEvent_WebCodec_Get_SendPacket_Count = Module._TEJSEvent_WebCodec_Get_SendPacket_Count = e => (_TEJSEvent_WebCodec_Get_SendPacket_Count = Module._TEJSEvent_WebCodec_Get_SendPacket_Count = wasmExports.TEJSEvent_WebCodec_Get_SendPacket_Count)(e)
          , _TEJSEvent_WebCodec_GetFirstTimestamp = Module._TEJSEvent_WebCodec_GetFirstTimestamp = e => (_TEJSEvent_WebCodec_GetFirstTimestamp = Module._TEJSEvent_WebCodec_GetFirstTimestamp = wasmExports.TEJSEvent_WebCodec_GetFirstTimestamp)(e)
          , _TEWebCodec_GenerateUUID = Module._TEWebCodec_GenerateUUID = () => (_TEWebCodec_GenerateUUID = Module._TEWebCodec_GenerateUUID = wasmExports.TEWebCodec_GenerateUUID)()
          , _TEJSEvent_WebCodec_Gen_GLTexture = Module._TEJSEvent_WebCodec_Gen_GLTexture = e => (_TEJSEvent_WebCodec_Gen_GLTexture = Module._TEJSEvent_WebCodec_Gen_GLTexture = wasmExports.TEJSEvent_WebCodec_Gen_GLTexture)(e)
          , _TEJSEvent_WebCodec_Delete_GLTexture = Module._TEJSEvent_WebCodec_Delete_GLTexture = (e, t) => (_TEJSEvent_WebCodec_Delete_GLTexture = Module._TEJSEvent_WebCodec_Delete_GLTexture = wasmExports.TEJSEvent_WebCodec_Delete_GLTexture)(e, t)
          , _TEJSEvent_WebCodec_GetTotalNativeFrames = Module._TEJSEvent_WebCodec_GetTotalNativeFrames = () => (_TEJSEvent_WebCodec_GetTotalNativeFrames = Module._TEJSEvent_WebCodec_GetTotalNativeFrames = wasmExports.TEJSEvent_WebCodec_GetTotalNativeFrames)()
          , _TEJSEvent_WebCodec_GetTotalPtrs = Module._TEJSEvent_WebCodec_GetTotalPtrs = () => (_TEJSEvent_WebCodec_GetTotalPtrs = Module._TEJSEvent_WebCodec_GetTotalPtrs = wasmExports.TEJSEvent_WebCodec_GetTotalPtrs)()
          , _enableWebCodecLog = Module._enableWebCodecLog = e => (_enableWebCodecLog = Module._enableWebCodecLog = wasmExports.enableWebCodecLog)(e)
          , _setWebCodecSizes = Module._setWebCodecSizes = e => (_setWebCodecSizes = Module._setWebCodecSizes = wasmExports.setWebCodecSizes)(e)
          , _TEJSEvent_InitBlobIO = Module._TEJSEvent_InitBlobIO = () => (_TEJSEvent_InitBlobIO = Module._TEJSEvent_InitBlobIO = wasmExports.TEJSEvent_InitBlobIO)()
          , _TEJSEvent_OnBlobReadResult = Module._TEJSEvent_OnBlobReadResult = (e, t) => (_TEJSEvent_OnBlobReadResult = Module._TEJSEvent_OnBlobReadResult = wasmExports.TEJSEvent_OnBlobReadResult)(e, t)
          , _TEJSEvent_Image_Decode_ImageBitmap_Close_Success = Module._TEJSEvent_Image_Decode_ImageBitmap_Close_Success = e => (_TEJSEvent_Image_Decode_ImageBitmap_Close_Success = Module._TEJSEvent_Image_Decode_ImageBitmap_Close_Success = wasmExports.TEJSEvent_Image_Decode_ImageBitmap_Close_Success)(e)
          , _TEJSEvent_Image_Decode_ImageBitmap_Close_Fail = Module._TEJSEvent_Image_Decode_ImageBitmap_Close_Fail = e => (_TEJSEvent_Image_Decode_ImageBitmap_Close_Fail = Module._TEJSEvent_Image_Decode_ImageBitmap_Close_Fail = wasmExports.TEJSEvent_Image_Decode_ImageBitmap_Close_Fail)(e)
          , _TEJSEvent_Image_Decode_Success_PIXEL_RGBA = Module._TEJSEvent_Image_Decode_Success_PIXEL_RGBA = (e, t, r, i, n) => (_TEJSEvent_Image_Decode_Success_PIXEL_RGBA = Module._TEJSEvent_Image_Decode_Success_PIXEL_RGBA = wasmExports.TEJSEvent_Image_Decode_Success_PIXEL_RGBA)(e, t, r, i, n)
          , _TEJSEvent_Image_Decode_Success_IMAGE_BITMAP = Module._TEJSEvent_Image_Decode_Success_IMAGE_BITMAP = (e, t, r, i, n) => (_TEJSEvent_Image_Decode_Success_IMAGE_BITMAP = Module._TEJSEvent_Image_Decode_Success_IMAGE_BITMAP = wasmExports.TEJSEvent_Image_Decode_Success_IMAGE_BITMAP)(e, t, r, i, n)
          , _TEJSEvent_Image_Decode_Fail = Module._TEJSEvent_Image_Decode_Fail = e => (_TEJSEvent_Image_Decode_Fail = Module._TEJSEvent_Image_Decode_Fail = wasmExports.TEJSEvent_Image_Decode_Fail)(e)
          , _TEJSEvent_Image_Movie_Decode_Succ = Module._TEJSEvent_Image_Movie_Decode_Succ = (e, t, r, i, n, o) => (_TEJSEvent_Image_Movie_Decode_Succ = Module._TEJSEvent_Image_Movie_Decode_Succ = wasmExports.TEJSEvent_Image_Movie_Decode_Succ)(e, t, r, i, n, o)
          , _TEJSEvent_Image_Movie_Decode_Fail = Module._TEJSEvent_Image_Movie_Decode_Fail = e => (_TEJSEvent_Image_Movie_Decode_Fail = Module._TEJSEvent_Image_Movie_Decode_Fail = wasmExports.TEJSEvent_Image_Movie_Decode_Fail)(e)
          , _TEJSEvent_Image_Movie_Open_Succ = Module._TEJSEvent_Image_Movie_Open_Succ = (e, t, r, i, n, o) => (_TEJSEvent_Image_Movie_Open_Succ = Module._TEJSEvent_Image_Movie_Open_Succ = wasmExports.TEJSEvent_Image_Movie_Open_Succ)(e, t, r, i, n, o)
          , _TEJSEvent_Image_Movie_Open_Fail = Module._TEJSEvent_Image_Movie_Open_Fail = e => (_TEJSEvent_Image_Movie_Open_Fail = Module._TEJSEvent_Image_Movie_Open_Fail = wasmExports.TEJSEvent_Image_Movie_Open_Fail)(e)
          , _TEJSEvent_HEIC_Get_From_Cache_Fail = Module._TEJSEvent_HEIC_Get_From_Cache_Fail = e => (_TEJSEvent_HEIC_Get_From_Cache_Fail = Module._TEJSEvent_HEIC_Get_From_Cache_Fail = wasmExports.TEJSEvent_HEIC_Get_From_Cache_Fail)(e)
          , _TEJSEvent_HEIC_Get_From_Cache_Succ = Module._TEJSEvent_HEIC_Get_From_Cache_Succ = (e, t, r, i) => (_TEJSEvent_HEIC_Get_From_Cache_Succ = Module._TEJSEvent_HEIC_Get_From_Cache_Succ = wasmExports.TEJSEvent_HEIC_Get_From_Cache_Succ)(e, t, r, i)
          , _TEJSEvent_HEIC_Decode_Fail = Module._TEJSEvent_HEIC_Decode_Fail = e => (_TEJSEvent_HEIC_Decode_Fail = Module._TEJSEvent_HEIC_Decode_Fail = wasmExports.TEJSEvent_HEIC_Decode_Fail)(e)
          , _TEJSEvent_HEIC_Decode_Succ = Module._TEJSEvent_HEIC_Decode_Succ = e => (_TEJSEvent_HEIC_Decode_Succ = Module._TEJSEvent_HEIC_Decode_Succ = wasmExports.TEJSEvent_HEIC_Decode_Succ)(e)
          , _TEJSEvent_HEIC_Decode_Succ_With_Bitmap = Module._TEJSEvent_HEIC_Decode_Succ_With_Bitmap = (e, t, r, i, n) => (_TEJSEvent_HEIC_Decode_Succ_With_Bitmap = Module._TEJSEvent_HEIC_Decode_Succ_With_Bitmap = wasmExports.TEJSEvent_HEIC_Decode_Succ_With_Bitmap)(e, t, r, i, n)
          , _TEJSEvent_HEIC_Decode_Succ_With_RGBA = Module._TEJSEvent_HEIC_Decode_Succ_With_RGBA = (e, t, r, i, n) => (_TEJSEvent_HEIC_Decode_Succ_With_RGBA = Module._TEJSEvent_HEIC_Decode_Succ_With_RGBA = wasmExports.TEJSEvent_HEIC_Decode_Succ_With_RGBA)(e, t, r, i, n)
          , _TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED = Module._TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED = (e, t, r, i) => (_TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED = Module._TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED = wasmExports.TEJSEvent_HTTPRequest_Send_On_HEADERS_RECEIVED)(e, t, r, i)
          , _TEJSEvent_HTTPRequest_Send_On_DONE = Module._TEJSEvent_HTTPRequest_Send_On_DONE = (e, t, r, i) => (_TEJSEvent_HTTPRequest_Send_On_DONE = Module._TEJSEvent_HTTPRequest_Send_On_DONE = wasmExports.TEJSEvent_HTTPRequest_Send_On_DONE)(e, t, r, i)
          , _exp2 = e => (_exp2 = wasmExports.exp2)(e)
          , _pow = (e, t) => (_pow = wasmExports.pow)(e, t)
          , _log = e => (_log = wasmExports.log)(e)
          , _read = (e, t, r) => (_read = wasmExports.read)(e, t, r)
          , _gettimeofday = (e, t) => (_gettimeofday = wasmExports.gettimeofday)(e, t)
          , _log10f = e => (_log10f = wasmExports.log10f)(e)
          , _cos = e => (_cos = wasmExports.cos)(e)
          , _sin = e => (_sin = wasmExports.sin)(e)
          , _sinh = e => (_sinh = wasmExports.sinh)(e)
          , _cosh = e => (_cosh = wasmExports.cosh)(e)
          , _tan = e => (_tan = wasmExports.tan)(e)
          , _hypot = (e, t) => (_hypot = wasmExports.hypot)(e, t)
          , _exp = e => (_exp = wasmExports.exp)(e)
          , _sinf = e => (_sinf = wasmExports.sinf)(e)
          , _cosf = e => (_cosf = wasmExports.cosf)(e)
          , _exp2f = e => (_exp2f = wasmExports.exp2f)(e)
          , _powf = (e, t) => (_powf = wasmExports.powf)(e, t)
          , _log10 = e => (_log10 = wasmExports.log10)(e)
          , _round = e => (_round = wasmExports.round)(e)
          , _atanf = e => (_atanf = wasmExports.atanf)(e)
          , _lrintf = e => (_lrintf = wasmExports.lrintf)(e)
          , _lrint = e => (_lrint = wasmExports.lrint)(e)
          , _atan = e => (_atan = wasmExports.atan)(e)
          , _atan2 = (e, t) => (_atan2 = wasmExports.atan2)(e, t)
          , _opendir = e => (_opendir = wasmExports.opendir)(e)
          , _readdir = e => (_readdir = wasmExports.readdir)(e)
          , _closedir = e => (_closedir = wasmExports.closedir)(e)
          , _pthread_join = (e, t) => (_pthread_join = wasmExports.pthread_join)(e, t)
          , _fputs = (e, t) => (_fputs = wasmExports.fputs)(e, t)
          , _log2f = e => (_log2f = wasmExports.log2f)(e)
          , _qsort = (e, t, r, i) => (_qsort = wasmExports.qsort)(e, t, r, i)
          , _fiprintf = (e, t, r) => (_fiprintf = wasmExports.fiprintf)(e, t, r)
          , _pthread_mutex_init = (e, t) => (_pthread_mutex_init = wasmExports.pthread_mutex_init)(e, t)
          , _pthread_mutex_destroy = e => (_pthread_mutex_destroy = wasmExports.pthread_mutex_destroy)(e)
          , _strtoul = (e, t, r) => (_strtoul = wasmExports.strtoul)(e, t, r)
          , _pthread_mutex_lock = e => (_pthread_mutex_lock = wasmExports.pthread_mutex_lock)(e)
          , _pthread_mutex_unlock = e => (_pthread_mutex_unlock = wasmExports.pthread_mutex_unlock)(e)
          , _pthread_cond_init = (e, t) => (_pthread_cond_init = wasmExports.pthread_cond_init)(e, t)
          , _pthread_cond_destroy = e => (_pthread_cond_destroy = wasmExports.pthread_cond_destroy)(e)
          , _pthread_cond_wait = (e, t) => (_pthread_cond_wait = wasmExports.pthread_cond_wait)(e, t)
          , _pthread_cond_signal = e => (_pthread_cond_signal = wasmExports.pthread_cond_signal)(e)
          , _rmdir = e => (_rmdir = wasmExports.rmdir)(e)
          , _acos = e => (_acos = wasmExports.acos)(e)
          , _cbrt = e => (_cbrt = wasmExports.cbrt)(e)
          , _getenv = e => (_getenv = wasmExports.getenv)(e)
          , _asin = e => (_asin = wasmExports.asin)(e)
          , _ldexpf = (e, t) => (_ldexpf = wasmExports.ldexpf)(e, t)
          , _ldexp = (e, t) => (_ldexp = wasmExports.ldexp)(e, t)
          , _pthread_cond_broadcast = e => (_pthread_cond_broadcast = wasmExports.pthread_cond_broadcast)(e)
          , _frexp = (e, t) => (_frexp = wasmExports.frexp)(e, t)
          , _cbrtf = e => (_cbrtf = wasmExports.cbrtf)(e)
          , _rename = (e, t) => (_rename = wasmExports.rename)(e, t)
          , _unlink = e => (_unlink = wasmExports.unlink)(e)
          , _fcntl = (e, t, r) => (_fcntl = wasmExports.fcntl)(e, t, r)
          , _write = (e, t, r) => (_write = wasmExports.write)(e, t, r)
          , _lstat = (e, t) => (_lstat = wasmExports.lstat)(e, t)
          , _strrchr = (e, t) => (_strrchr = wasmExports.strrchr)(e, t)
          , _fabs = e => (_fabs = wasmExports.fabs)(e)
          , _tanh = e => (_tanh = wasmExports.tanh)(e)
          , _strcspn = (e, t) => (_strcspn = wasmExports.strcspn)(e, t)
          , _bsearch = (e, t, r, i, n) => (_bsearch = wasmExports.bsearch)(e, t, r, i, n)
          , _OfxGetPlugin = Module._OfxGetPlugin = e => (_OfxGetPlugin = Module._OfxGetPlugin = wasmExports.OfxGetPlugin)(e)
          , _OfxGetNumberOfPlugins = Module._OfxGetNumberOfPlugins = () => (_OfxGetNumberOfPlugins = Module._OfxGetNumberOfPlugins = wasmExports.OfxGetNumberOfPlugins)()
          , __emscripten_tls_init = Module.__emscripten_tls_init = () => (__emscripten_tls_init = Module.__emscripten_tls_init = wasmExports._emscripten_tls_init)()
          , _emscripten_builtin_memalign = (e, t) => (_emscripten_builtin_memalign = wasmExports.emscripten_builtin_memalign)(e, t)
          , ___getTypeName = e => (___getTypeName = wasmExports.__getTypeName)(e)
          , __embind_initialize_bindings = Module.__embind_initialize_bindings = () => (__embind_initialize_bindings = Module.__embind_initialize_bindings = wasmExports._embind_initialize_bindings)()
          , __emscripten_run_callback_on_thread = (e, t, r, i, n) => (__emscripten_run_callback_on_thread = wasmExports._emscripten_run_callback_on_thread)(e, t, r, i, n)
          , __emscripten_set_offscreencanvas_size_on_thread = (e, t, r, i) => (__emscripten_set_offscreencanvas_size_on_thread = wasmExports._emscripten_set_offscreencanvas_size_on_thread)(e, t, r, i)
          , ___dl_seterr = (e, t) => (___dl_seterr = wasmExports.__dl_seterr)(e, t)
          , __emscripten_dlsync_self_async = e => (__emscripten_dlsync_self_async = wasmExports._emscripten_dlsync_self_async)(e)
          , __emscripten_dlsync_self = () => (__emscripten_dlsync_self = wasmExports._emscripten_dlsync_self)()
          , __emscripten_proxy_dlsync_async = (e, t) => (__emscripten_proxy_dlsync_async = wasmExports._emscripten_proxy_dlsync_async)(e, t)
          , __emscripten_proxy_dlsync = e => (__emscripten_proxy_dlsync = wasmExports._emscripten_proxy_dlsync)(e)
          , _strspn = (e, t) => (_strspn = wasmExports.strspn)(e, t)
          , _emscripten_main_runtime_thread_id = () => (_emscripten_main_runtime_thread_id = wasmExports.emscripten_main_runtime_thread_id)()
          , __emscripten_thread_init = Module.__emscripten_thread_init = (e, t, r, i, n, o) => (__emscripten_thread_init = Module.__emscripten_thread_init = wasmExports._emscripten_thread_init)(e, t, r, i, n, o)
          , _clock_gettime = (e, t) => (_clock_gettime = wasmExports.clock_gettime)(e, t)
          , __emscripten_thread_crashed = Module.__emscripten_thread_crashed = () => (__emscripten_thread_crashed = Module.__emscripten_thread_crashed = wasmExports._emscripten_thread_crashed)()
          , _emscripten_main_thread_process_queued_calls = () => (_emscripten_main_thread_process_queued_calls = wasmExports.emscripten_main_thread_process_queued_calls)()
          , _glob = (e, t, r, i) => (_glob = wasmExports.glob)(e, t, r, i)
          , _globfree = e => (_globfree = wasmExports.globfree)(e)
          , _isatty = e => (_isatty = wasmExports.isatty)(e)
          , _llrint = e => (_llrint = wasmExports.llrint)(e)
          , _llrintf = e => (_llrintf = wasmExports.llrintf)(e)
          , _gmtime_r = (e, t) => (_gmtime_r = wasmExports.gmtime_r)(e, t)
          , _nanosleep = (e, t) => (_nanosleep = wasmExports.nanosleep)(e, t)
          , __emscripten_run_on_main_thread_js = (e, t, r, i, n) => (__emscripten_run_on_main_thread_js = wasmExports._emscripten_run_on_main_thread_js)(e, t, r, i, n)
          , __emscripten_thread_free_data = e => (__emscripten_thread_free_data = wasmExports._emscripten_thread_free_data)(e)
          , __emscripten_thread_exit = Module.__emscripten_thread_exit = e => (__emscripten_thread_exit = Module.__emscripten_thread_exit = wasmExports._emscripten_thread_exit)(e)
          , _strerror_r = (e, t, r) => (_strerror_r = wasmExports.strerror_r)(e, t, r)
          , ___multi3 = (e, t, r, i, n) => (___multi3 = wasmExports.__multi3)(e, t, r, i, n)
          , __emscripten_check_mailbox = () => (__emscripten_check_mailbox = wasmExports._emscripten_check_mailbox)()
          , ___trap = () => (___trap = wasmExports.__trap)()
          , _emscripten_stack_set_limits = (e, t) => (_emscripten_stack_set_limits = wasmExports.emscripten_stack_set_limits)(e, t)
          , stackSave = () => (stackSave = wasmExports.stackSave)()
          , stackRestore = e => (stackRestore = wasmExports.stackRestore)(e)
          , stackAlloc = e => (stackAlloc = wasmExports.stackAlloc)(e)
          , ___cxa_decrement_exception_refcount = e => (___cxa_decrement_exception_refcount = wasmExports.__cxa_decrement_exception_refcount)(e)
          , ___cxa_increment_exception_refcount = e => (___cxa_increment_exception_refcount = wasmExports.__cxa_increment_exception_refcount)(e)
          , ___thrown_object_from_unwind_exception = e => (___thrown_object_from_unwind_exception = wasmExports.__thrown_object_from_unwind_exception)(e)
          , ___get_exception_message = (e, t, r) => (___get_exception_message = wasmExports.__get_exception_message)(e, t, r)
          , __wasmfs_read_file = e => (__wasmfs_read_file = wasmExports._wasmfs_read_file)(e)
          , __wasmfs_write_file = (e, t, r) => (__wasmfs_write_file = wasmExports._wasmfs_write_file)(e, t, r)
          , __wasmfs_mkdir = (e, t) => (__wasmfs_mkdir = wasmExports._wasmfs_mkdir)(e, t)
          , __wasmfs_rmdir = e => (__wasmfs_rmdir = wasmExports._wasmfs_rmdir)(e)
          , __wasmfs_open = (e, t, r) => (__wasmfs_open = wasmExports._wasmfs_open)(e, t, r)
          , __wasmfs_allocate = (e, t, r) => (__wasmfs_allocate = wasmExports._wasmfs_allocate)(e, t, r)
          , __wasmfs_mknod = (e, t, r) => (__wasmfs_mknod = wasmExports._wasmfs_mknod)(e, t, r)
          , __wasmfs_unlink = e => (__wasmfs_unlink = wasmExports._wasmfs_unlink)(e)
          , __wasmfs_chdir = e => (__wasmfs_chdir = wasmExports._wasmfs_chdir)(e)
          , __wasmfs_symlink = (e, t) => (__wasmfs_symlink = wasmExports._wasmfs_symlink)(e, t)
          , __wasmfs_readlink = e => (__wasmfs_readlink = wasmExports._wasmfs_readlink)(e)
          , __wasmfs_write = (e, t, r) => (__wasmfs_write = wasmExports._wasmfs_write)(e, t, r)
          , __wasmfs_pwrite = (e, t, r, i) => (__wasmfs_pwrite = wasmExports._wasmfs_pwrite)(e, t, r, i)
          , __wasmfs_chmod = (e, t) => (__wasmfs_chmod = wasmExports._wasmfs_chmod)(e, t)
          , __wasmfs_fchmod = (e, t) => (__wasmfs_fchmod = wasmExports._wasmfs_fchmod)(e, t)
          , __wasmfs_lchmod = (e, t) => (__wasmfs_lchmod = wasmExports._wasmfs_lchmod)(e, t)
          , __wasmfs_llseek = (e, t, r) => (__wasmfs_llseek = wasmExports._wasmfs_llseek)(e, t, r)
          , __wasmfs_rename = (e, t) => (__wasmfs_rename = wasmExports._wasmfs_rename)(e, t)
          , __wasmfs_read = (e, t, r) => (__wasmfs_read = wasmExports._wasmfs_read)(e, t, r)
          , __wasmfs_pread = (e, t, r, i) => (__wasmfs_pread = wasmExports._wasmfs_pread)(e, t, r, i)
          , __wasmfs_truncate = (e, t) => (__wasmfs_truncate = wasmExports._wasmfs_truncate)(e, t)
          , __wasmfs_ftruncate = (e, t) => (__wasmfs_ftruncate = wasmExports._wasmfs_ftruncate)(e, t)
          , __wasmfs_close = e => (__wasmfs_close = wasmExports._wasmfs_close)(e)
          , __wasmfs_mmap = (e, t, r, i, n) => (__wasmfs_mmap = wasmExports._wasmfs_mmap)(e, t, r, i, n)
          , __wasmfs_msync = (e, t, r) => (__wasmfs_msync = wasmExports._wasmfs_msync)(e, t, r)
          , __wasmfs_munmap = (e, t) => (__wasmfs_munmap = wasmExports._wasmfs_munmap)(e, t)
          , __wasmfs_utime = (e, t, r) => (__wasmfs_utime = wasmExports._wasmfs_utime)(e, t, r)
          , __wasmfs_stat = (e, t) => (__wasmfs_stat = wasmExports._wasmfs_stat)(e, t)
          , __wasmfs_lstat = (e, t) => (__wasmfs_lstat = wasmExports._wasmfs_lstat)(e, t)
          , __wasmfs_mount = (e, t) => (__wasmfs_mount = wasmExports._wasmfs_mount)(e, t)
          , __wasmfs_unmount = e => (__wasmfs_unmount = wasmExports._wasmfs_unmount)(e)
          , __wasmfs_identify = e => (__wasmfs_identify = wasmExports._wasmfs_identify)(e)
          , __wasmfs_readdir_start = e => (__wasmfs_readdir_start = wasmExports._wasmfs_readdir_start)(e)
          , __wasmfs_readdir_get = e => (__wasmfs_readdir_get = wasmExports._wasmfs_readdir_get)(e)
          , __wasmfs_readdir_finish = e => (__wasmfs_readdir_finish = wasmExports._wasmfs_readdir_finish)(e)
          , __wasmfs_get_cwd = () => (__wasmfs_get_cwd = wasmExports._wasmfs_get_cwd)()
          , _wasmfs_create_jsimpl_backend = () => (_wasmfs_create_jsimpl_backend = wasmExports.wasmfs_create_jsimpl_backend)()
          , _wasmfs_create_memory_backend = () => (_wasmfs_create_memory_backend = wasmExports.wasmfs_create_memory_backend)()
          , _wasmfs_create_file = (e, t, r) => (_wasmfs_create_file = wasmExports.wasmfs_create_file)(e, t, r)
          , __vefs_get_file_handle_by_path = (e, t) => (__vefs_get_file_handle_by_path = wasmExports._vefs_get_file_handle_by_path)(e, t)
          , _stderr = Module._stderr = 4882520;
        function callMain(e=[]) {
            var t = resolveGlobalSymbol("main").sym;
            if (t) {
                e.unshift(thisProgram);
                var r = e.length
                  , i = stackAlloc((r + 1) * 4)
                  , n = i;
                e.forEach(e => {
                    GROWABLE_HEAP_U32()[n >> 2] = stringToUTF8OnStack(e),
                    n += 4
                }
                ),
                GROWABLE_HEAP_U32()[n >> 2] = 0;
                try {
                    var o = t(r, i);
                    return exitJS(o, !0),
                    o
                } catch (e) {
                    return handleException(e)
                }
            }
        }
        Module.addRunDependency = addRunDependency,
        Module.removeRunDependency = removeRunDependency,
        Module.FS_createPath = FS.createPath,
        Module.wasmMemory = wasmMemory,
        Module.keepRuntimeAlive = keepRuntimeAlive,
        Module.ccall = ccall,
        Module.cwrap = cwrap,
        Module.addFunction = addFunction,
        Module.removeFunction = removeFunction,
        Module.PATH = PATH,
        Module.UTF8ArrayToString = UTF8ArrayToString,
        Module.UTF8ToString = UTF8ToString,
        Module.stringToUTF8Array = stringToUTF8Array,
        Module.stringToUTF8 = stringToUTF8,
        Module.lengthBytesUTF8 = lengthBytesUTF8,
        Module.intArrayFromString = intArrayFromString,
        Module.intArrayToString = intArrayToString,
        Module.writeArrayToMemory = writeArrayToMemory,
        Module.ExitStatus = ExitStatus,
        Module.FS_createPreloadedFile = FS.createPreloadedFile,
        Module.FS = FS,
        Module.FS_createDataFile = FS.createDataFile,
        Module.FS_unlink = FS.unlink,
        Module.veFS_JS_HUB = veFS_JS_HUB,
        Module.ALLOC_NORMAL = ALLOC_NORMAL,
        Module.allocate = allocate,
        Module.allocateUTF8 = allocateUTF8,
        Module.PThread = PThread,
        Module.WebCodecs = WebCodecs,
        Module.lv_api_wait_init = lv_api_wait_init,
        Module.lv_api_get_task_promise = lv_api_get_task_promise,
        dependenciesFulfilled = function e() {
            !calledRun && run(),
            !calledRun && (dependenciesFulfilled = e)
        }
        ;
        var sharedModules = Module.sharedModules || [];
        function run(e=arguments_) {
            if (runDependencies > 0)
                return;
            if (ENVIRONMENT_IS_PTHREAD) {
                readyPromiseResolve(Module),
                initRuntime(),
                startWorker(Module);
                return
            }
            if (preRun(),
            !(runDependencies > 0))
                Module.setStatus ? (Module.setStatus("Running..."),
                setTimeout(function() {
                    setTimeout(function() {
                        Module.setStatus("")
                    }, 1),
                    t()
                }, 1)) : t();
            function t() {
                if (!calledRun)
                    calledRun = !0,
                    Module.calledRun = !0,
                    !ABORT && (initRuntime(),
                    preMain(),
                    readyPromiseResolve(Module),
                    Module.onRuntimeInitialized && Module.onRuntimeInitialized(),
                    shouldRunNow && callMain(e),
                    postRun())
            }
        }
        if (Module.preInit)
            for ("function" == typeof Module.preInit && (Module.preInit = [Module.preInit]); Module.preInit.length > 0; )
                Module.preInit.pop()();
        var shouldRunNow = !0;
        Module.noInitialRun && (shouldRunNow = !1),
        run();
        var tmpFunc = PThread.loadWasmModuleToWorker;
        PThread.loadWasmModuleToWorker = function(e) {
            let t = tmpFunc.apply(this, [e]);
            var r = e.onmessage;
            return e.onmessage = function(t) {
                var i = t.data
                  , n = i.cmd;
                if ("vesdk_callback" === n) {
                    var o = i.sequenceId
                      , a = i.ret
                      , s = i.ext1
                      , u = i.ext2
                      , l = i.f
                      , c = Module.getSeqCallback(o);
                    if (!c) {
                        console.warn("callback can not found for sequeceId" + o);
                        return
                    }
                    c(a, s, u, l)
                } else if ("vesdk_crash" === n) {
                    var p = i.stack
                      , d = i.msg
                      , f = i.createStack
                      , m = Module.getCrashCallback();
                    if (!m) {
                        console.warn("crashCallback not found");
                        return
                    }
                    m(d = `#${i.threadId.toString(16)}# ${d}`, p, i.threadId, f)
                } else if ("vesdk_render_thread_id" === n) {
                    if (Module.vesdk_render_thread_id = t.data.pid,
                    "undefined" != typeof VESDK_ENABLE_WEBGL_CAPTURE && VESDK_ENABLE_WEBGL_CAPTURE) {
                        for (let e of Module.PThread.runningWorkers)
                            if (e.pthread_ptr === Module.vesdk_render_thread_id) {
                                Module.vesdk_render_worker = e,
                                window.__SPECTOR_worker = e;
                                var h = window.spector = new SPECTOR.RemoteSpector({},e);
                                h.displayUI(),
                                h.spyCanvases();
                                break
                            }
                    }
                } else if ("start_audio_worklet" === n)
                    console.log("start worklet msg received"),
                    CreateAudioWorkletInMain(t.data.userData, t.data.sab, t.data.sampleRate, t.data.channelCount);
                else if ("pause_audio_worklet" === n)
                    console.log("pause worklet msg received"),
                    TEPauseAudioWorklet(t.data.userData);
                else if ("resume_audio_worklet" === n)
                    console.log("resume worklet msg received"),
                    TEResumeAudioWorklet(t.data.userData);
                else if ("vesdk_info_callback" === n) {
                    var g = Module.vesdk_info_callback_hub;
                    if (!g) {
                        console.warn("callback hub not set");
                        return
                    }
                    if (i.data && void 0 !== i.data && null !== i.data && void 0 !== i.data.rc && null !== i.data.rc && void 0 !== i.data.p_origin && null !== i.data.p_origin && void 0 !== i.data.p_now && null !== i.data.p_now) {
                        var _ = performance.timeOrigin + performance.now() - (i.data.p_origin + i.data.p_now);
                        i.data.worker2mainCostTime = _
                    }
                    g(i.cbClass, i.cbFunc, i.listenerId, i.data)
                } else if ("vesdk_ret_callback" === n) {
                    var c = vesdk_task_map[i.cbId];
                    if (!c) {
                        console.warn("callback can not found for sequeceId" + o);
                        return
                    }
                    c.promise.costTime = i.costTime,
                    c.promise.callFunc = i.callFunc,
                    c.resolve(i.ret)
                } else if ("vesdk_log_dumped" === n)
                    VELogSink = VELogSink.concat(i.data);
                else if ("onInsertBlobComplete" === n)
                    ;
                else if ("first_frame_workers_detail" === n) {
                    if (Module.applogPerf) {
                        let e = PThread.unusedWorkers.length
                          , t = PThread.runningWorkers.length
                          , r = {
                            running_workers: t,
                            unused_workers: e,
                            total_workers: e + t,
                            heap_size: Module.wasmMemory.buffer.byteLength,
                            beforeFirstFrame: !0
                        };
                        Module.applogPerf("ve_web_workers_detail", r)
                    }
                } else if ("trace" === n) {
                    let e = i.entry;
                    EmscriptenTrace && EmscriptenTrace.post(e)
                } else
                    "function" == typeof Module.onBizMessage ? !Module.onBizMessage(t) && r.apply(e, [t]) : r.apply(e, [t])
            }
            ,
            t
        }
        ,
        PThread.getNewWorker = function() {
            if (0 == PThread.unusedWorkers.length) {
                var e = performance.now();
                PThread.allocateUnusedWorker();
                var t = PThread.unusedWorkers.length + PThread.runningWorkers.length;
                PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]).then(function() {
                    var r = performance.now() - e;
                    Module.applogPerf && Module.applogPerf("ve_web_allocate_thread_worker", {
                        time: r,
                        total_workers: t
                    })
                })
            }
            return PThread.unusedWorkers.shift()
        }
        ;
        var tmpThreadInit = PThread.threadInit;
        PThread.threadInit = function() {
            tmpThreadInit.apply(this, []),
            PThread.threadId = Module._pthread_self()
        }
        ;
        var tmpThreadCancel = PThread.threadCancel;
        PThread.threadCancel = function() {
            tmpThreadCancel.apply(this, []),
            void 0 !== PThread.threadId && delete PThread.threadId
        }
        ;
        var tmpThreadExit = PThread.threadExit;
        PThread.threadExit = function() {
            tmpThreadExit.apply(this, []),
            void 0 !== PThread.threadId && delete PThread.threadId
        }
        ,
        PThread.shrinkUnusedWorker = function() {
            if (ENVIRONMENT_IS_WORKER)
                return;
            let e = Module.maintainWorkerSize || 2
              , t = Module.PThread.unusedWorkers;
            for (; t.length > e; ) {
                let e = t.shift();
                terminateWorker(e),
                console.log(`free worker ${e.__VESDK_name}`)
            }
        }
        ;
        var tmpReturnWorkerToPool = PThread.returnWorkerToPool;
        if (PThread.returnWorkerToPool = e => {
            tmpReturnWorkerToPool(e),
            PThread.shrinkUnusedWorker()
        }
        ,
        !ENVIRONMENT_IS_WORKER) {
            let lastReportedData;
            function measurementInterval() {
                return Math.max(-(6e4 * Math.log(Math.random())), 2e4)
            }
            function scheduleMeasurement() {
                setTimeout(function() {
                    if (Module.applogPerf) {
                        let e = PThread.unusedWorkers.length
                          , t = PThread.runningWorkers.length
                          , r = {
                            running_workers: t,
                            unused_workers: e,
                            total_workers: e + t,
                            heap_size: Module.wasmMemory.buffer.byteLength
                        };
                        if (JSON.stringify(r) === JSON.stringify(lastReportedData)) {
                            scheduleMeasurement();
                            return
                        }
                        Module.applogPerf("ve_web_workers_detail", r),
                        lastReportedData = r
                    }
                    scheduleMeasurement()
                }, measurementInterval())
            }
            scheduleMeasurement(),
            function e() {
                setTimeout(function() {
                    if (Module.applogPerf) {
                        var e = document.createElement("canvas").getContext("webgl2")
                          , t = e ? e.getExtension("WEBGL_debug_renderer_info") : void 0;
                        e && t ? Module.applogPerf("ve_web_webgl_info", {
                            gl: "webgl2",
                            render_info: 1,
                            cpu_cores: navigator.hardwareConcurrency,
                            platform: navigator.platform,
                            webgl_renderer: e.getParameter(t.UNMASKED_RENDERER_WEBGL),
                            webgl_vendor: e.getParameter(t.UNMASKED_VENDOR_WEBGL)
                        }) : Module.applogPerf("ve_web_webgl_info", {
                            gl: e ? "webgl2" : "unknown",
                            render_info: t ? 1 : 0
                        })
                    }
                }, measurementInterval())
            }()
        }
        addOnPostRun(e => {
            setTimeout(function() {
                Module.applogPerf && Module.applogPerf("ve_web_runtime_info", {
                    simd: void 0 === Module.SIMD_MODE ? -1 : Module.SIMD_MODE
                })
            }, 3e3)
        }
        ),
        Module.applogPerf = function(e, t) {
            if (runtimeInitialized) {
                if (!e) {
                    console.log("Event name or type is empty");
                    return
                }
                if (t) {
                    if ("Object" !== t.constructor.name) {
                        console.log("ExtraObj is not a plain object");
                        return
                    }
                } else
                    t = {};
                Module.ccall("TEApplogReport", null, ["string", "string", "string"], [e, "performance", JSON.stringify(t)])
            }
        }
        ,
        FS.getMounts = FS.getMounts,
        FS.root = FS.root,
        FS.syncfs = FS.syncfs,
        FS.stat = FS.stat,
        FS.mkdirTree = FS.mkdirTree,
        FS.open = FS.open,
        FS.write = FS.write,
        FS.close = FS.close,
        FS.readdir = FS.readdir,
        FS.mount = FS.mount,
        FS.unlink = FS.unlink,
        FS.joinPath = FS.joinPath,
        FS.readFile = FS.readFile,
        FS.isDir = FS.isDir,
        FS.rmdir = FS.rmdir,
        FS.mkdir = FS.mkdir,
        FS.lookupPath = FS.lookupPath,
        FS.FSNode = FS.FSNode,
        FS.lstat = FS.lstat,
        PATH.join = PATH.join,
        PATH.dirname = PATH.dirname,
        "undefined" != typeof window && (window.Module = Module,
        window.Module.PATH = PATH);
        var makeCurrent = GL.makeContextCurrent;
        if (GL.makeContextCurrent = function() {
            var e = makeCurrent.apply(GL, arguments);
            if (GL.currentContext) {
                var t, r = GL.currentContext.GLctx.__proto__, i = Object.getOwnPropertyNames(r);
                let e = {};
                e[r.VIEWPORT] = "_viewport",
                e[r.DEPTH_WRITEMASK] = "_depthMask",
                e[r.DEPTH_RANGE] = "_depthRange",
                e[r.SCISSOR_BOX] = "_scissor",
                e[r.CULL_FACE_MODE] = "_cullFace",
                e[r.FRONT_FACE] = "_frontFace",
                e[r.POLYGON_OFFSET_FACTOR] = "_polygonOffsetFactor",
                e[r.POLYGON_OFFSET_UNITS] = "_polygonOffsetUnits",
                e[r.COLOR_WRITEMASK] = "_colorMask",
                e[r.BLEND_COLOR] = "_blendColor",
                e[r.BLEND_DST_RGB] = "_blendDstRGB",
                e[r.BLEND_SRC_RGB] = "_blendSrcRGB",
                e[r.BLEND_DST_ALPHA] = "_blendDstAlpha",
                e[r.BLEND_SRC_ALPHA] = "_blendSrcAlpha",
                e[r.BLEND_EQUATION] = "_blendEquation",
                e[r.BLEND_EQUATION_ALPHA] = "_blendEquationAlpha",
                e[r.DEPTH_FUNC] = "_depthFunc",
                e[r.STENCIL_FUNC] = "_stencilFunc",
                e[r.STENCIL_REF] = "_stencilRef",
                e[r.STENCIL_VALUE_MASK] = "_stencilValueMask",
                e[r.STENCIL_WRITEMASK] = "_stencilWritemask",
                e[r.STENCIL_FAIL] = "_stencilFail",
                e[r.STENCIL_PASS_DEPTH_FAIL] = "_depthFail",
                e[r.STENCIL_PASS_DEPTH_PASS] = "_depthPass",
                e[r.STENCIL_BACK_FUNC] = "_stencilBackFunc",
                e[r.STENCIL_BACK_REF] = "_stencilBackRef",
                e[r.STENCIL_BACK_VALUE_MASK] = "_stencilBackValueMask",
                e[r.STENCIL_BACK_WRITEMASK] = "_stencilBackWritemask",
                e[r.STENCIL_BACK_FAIL] = "_stencilBackFail",
                e[r.STENCIL_BACK_PASS_DEPTH_FAIL] = "_depthBackFail",
                e[r.STENCIL_BACK_PASS_DEPTH_PASS] = "_depthBackPass";
                for (var n = 0; n < i.length; n++) {
                    try {
                        t = r[i[n]]
                    } catch (e) {
                        continue
                    }
                    !function(t, i) {
                        let n = function(e) {
                            return function() {
                                let t;
                                var r = performance.now();
                                return t = e.apply(null, arguments),
                                performance.now(),
                                t
                            }
                        };
                        "function" == typeof i && !i.__replaced && ("bindTexture" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1];
                            var n = i.apply(GL.currentContext.GLctx, arguments);
                            return e === r.TEXTURE_2D && (GL.currentContext.bindedTexture = t ? GL.textures[t.name] : null),
                            n
                        }) : "viewPort" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2]
                              , n = arguments[3];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._viewport = Int32Array.from([e, t, r, n]),
                            o
                        }) : "depthMask" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._depthMask = e,
                            t
                        }) : "scissor" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2]
                              , n = arguments[3];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._scissor = Int32Array.from([e, t, r, n]),
                            o
                        }) : "cullFace" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._cullFace = e,
                            t
                        }) : "frontFace" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._frontFace = e,
                            t
                        }) : "polygonOffset" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1];
                            var r = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._polygonOffsetFactor = e,
                            GL.currentContext._polygonOffsetUnits = t,
                            r
                        }) : "colorMask" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2]
                              , n = arguments[3];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._colorMask = [e, t, r, n],
                            o
                        }) : "depthFunc" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._depthFunc = e,
                            t
                        }) : "blendColor" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2]
                              , n = arguments[3];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._blendColor = Float32Array.from([e, t, r, n]),
                            o
                        }) : "blendFunc" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1];
                            var r = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._blendSrcRGB = e,
                            GL.currentContext._blendDstRGB = t,
                            GL.currentContext._blendSrcAlpha = e,
                            GL.currentContext._blendDstAlpha = t,
                            r
                        }) : "blendFuncSeparate" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2]
                              , n = arguments[3];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._blendSrcRGB = e,
                            GL.currentContext._blendDstRGB = t,
                            GL.currentContext._blendSrcAlpha = r,
                            GL.currentContext._blendDstAlpha = n,
                            o
                        }) : "blendEquation" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._blendEquation = e,
                            GL.currentContext._blendEquationAlpha = e,
                            t
                        }) : "blendEquationSeparate" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[0];
                            var r = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._blendEquation = e,
                            GL.currentContext._blendEquationAlpha = t,
                            r
                        }) : "stencilFunc" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2];
                            var n = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._stencilFunc = e,
                            GL.currentContext._stencilBackFunc = e,
                            GL.currentContext._stencilRef = t,
                            GL.currentContext._stencilBackRef = t,
                            GL.currentContext._stencilValueMask = r,
                            GL.currentContext._stencilBackValueMask = r,
                            n
                        }) : "stencilMask" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            var t = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._stencilWritemask = e,
                            GL.currentContext._stencilBackWritemask = e,
                            t
                        }) : "stencilOp" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , r = arguments[2];
                            var n = i.apply(GL.currentContext.GLctx, arguments);
                            return GL.currentContext._stencilFail = e,
                            GL.currentContext._stencilBackFail = e,
                            GL.currentContext._depthFail = t,
                            GL.currentContext._depthBackFail = t,
                            GL.currentContext._depthPass = r,
                            GL.currentContext._depthBackPass = r,
                            n
                        }) : "stencilFuncSeparate" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , n = arguments[2]
                              , o = arguments[3];
                            var a = i.apply(GL.currentContext.GLctx, arguments);
                            return e === r.FRONT_AND_BACK ? (GL.currentContext._stencilFunc = t,
                            GL.currentContext._stencilBackFunc = t,
                            GL.currentContext._stencilRef = n,
                            GL.currentContext._stencilBackRef = n,
                            GL.currentContext._stencilValueMask = o,
                            GL.currentContext._stencilBackValueMask = o) : e === r.FRONT ? (GL.currentContext._stencilFunc = t,
                            GL.currentContext._stencilRef = n,
                            GL.currentContext._stencilValueMask = o) : e === r.BACK && (GL.currentContext._stencilBackFunc = t,
                            GL.currentContext._stencilBackRef = n,
                            GL.currentContext._stencilBackValueMask = o),
                            a
                        }) : "stencilMaskSeparate" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1];
                            var n = i.apply(GL.currentContext.GLctx, arguments);
                            return e === r.FRONT_AND_BACK ? (GL.currentContext._stencilWritemask = t,
                            GL.currentContext._stencilBackWritemask = t) : e === r.FRONT ? GL.currentContext._stencilWritemask = t : e === r.BACK && (GL.currentContext._stencilBackWritemask = t),
                            n
                        }) : "stencilOpSeparate" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , n = arguments[2]
                              , o = arguments[3];
                            var a = i.apply(GL.currentContext.GLctx, arguments);
                            return e === r.FRONT_AND_BACK ? (GL.currentContext._stencilFail = t,
                            GL.currentContext._stencilBackFail = t,
                            GL.currentContext._depthFail = n,
                            GL.currentContext._depthBackFail = n,
                            GL.currentContext._depthPass = o,
                            GL.currentContext._depthBackPass = o) : e === r.FRONT ? (GL.currentContext._stencilFail = t,
                            GL.currentContext._depthFail = n,
                            GL.currentContext._depthPass = o) : e === r.BACK && (GL.currentContext._stencilBackFail = t,
                            GL.currentContext._depthBackFail = n,
                            GL.currentContext._depthBackPass = o),
                            a
                        }) : "isFramebuffer" === t || "isRenderbuffer" === t || "isShader" === t || "isTexture" === t || "isProgram" === t || "isBuffer" === t ? r[t] = n(function() {
                            let e = arguments[0];
                            return !!e
                        }) : "getParameter" === t ? r[t] = n(function() {
                            let t = arguments[0];
                            if (e.hasOwnProperty(t)) {
                                let r = e[t];
                                if (void 0 !== GL.currentContext[r])
                                    return GL.currentContext[r]
                            }
                            var r = i.apply(GL.currentContext.GLctx, arguments);
                            if (e.hasOwnProperty(t)) {
                                let i = e[t];
                                GL.currentContext[i] = r
                            }
                            return r
                        }) : "getShaderParameter" === t ? r[t] = n(function() {
                            var e;
                            let t = arguments[0]
                              , n = arguments[1];
                            return e = n === r.COMPILE_STATUS ? t ? 1 : 0 : i.apply(GL.currentContext.GLctx, arguments),
                            e
                        }) : "getProgramParameter" === t ? r[t] = n(function() {
                            var e;
                            let t = arguments[0]
                              , n = arguments[1];
                            return e = n === r.LINK_STATUS ? t ? 1 : 0 : i.apply(GL.currentContext.GLctx, arguments),
                            e
                        }) : "texParameteri" === t ? r[t] = n(function() {
                            let e = arguments[0]
                              , t = arguments[1]
                              , n = arguments[2];
                            var o = i.apply(GL.currentContext.GLctx, arguments);
                            return e == r.TEXTURE_2D && GL.currentContext.bindedTexture && (t == r.TEXTURE_MAG_FILTER || t == r.TEXTURE_MIN_FILTER || t == r.TEXTURE_WRAP_S || t == r.TEXTURE_WRAP_T) && (GL.currentContext.bindedTexture["p" + t] = n),
                            o
                        }) : "getTexParameter" === t ? r[t] = n(function() {
                            var e;
                            let t = arguments[0]
                              , n = arguments[1];
                            return e = t == r.TEXTURE_2D && GL.currentContext.bindedTexture && GL.currentContext.bindedTexture["p" + n] ? GL.currentContext.bindedTexture["p" + n] : i.apply(GL.currentContext.GLctx, arguments),
                            e
                        }) : "getError" === t ? r[t] = function() {
                            return 0
                        }
                        : r[t] = n(function() {
                            var e = i.apply(GL.currentContext.GLctx, arguments);
                            return e
                        }),
                        r[t].__replaced = !0)
                    }(i[n], t)
                }
            }
            return e
        }
        ,
        Module.onBizMessage = function(e) {
            var t = e.data
              , r = t.cmd;
            if ("lvve" == r)
                return dynCall(t.signature, t.handle, t.args),
                !0;
            if ("lvve_function" == r) {
                let e = t.handle
                  , r = t.args || [];
                return Module.lvveFunctionTable.call(e, ...r),
                !0
            }
            return !1
        }
        ,
        ENVIRONMENT_IS_PTHREAD) {
            let replace_worker_onmessage = () => {
                var e = globalThis.onmessage;
                globalThis.onmessage = function(t) {
                    var r = !1;
                    try {
                        var i = t.data.cmd;
                        if ("insertBlob" === i) {
                            var n = t.data.url
                              , o = t.data.blob
                              , a = t.data.uuid;
                            BlobMapper.insertBlob(n, o),
                            postMessage({
                                cmd: "onInsertBlobComplete",
                                uuid: a
                            })
                        } else {
                            if ("removeBlob" !== i)
                                return r = !0,
                                e.apply(globalThis, [t]);
                            var n = t.data.url;
                            BlobMapper.removeBlob(n)
                        }
                    } catch (i) {
                        if (console.warn(i),
                        !r)
                            return e.apply(globalThis, [t])
                    }
                }
            }
            ;
            if (Module.dynamicLibraries && runDependencies > 0) {
                let watcher = setInterval( () => {
                    0 === runDependencies && (replace_worker_onmessage(),
                    clearInterval(watcher))
                }
                , 10)
            } else
                replace_worker_onmessage()
        } else
            Module._blobMapper = {},
            Module.initBlobIO = function() {
                return Module.blobIOWorker ? (out("A blob io worker already exists"),
                Promise.resolve("already exists")) : (Module.ccall("TEJSEvent_InitBlobIO", null, [], []),
                new Promise( (e, t) => {
                    let r = setInterval(function() {
                        Module.blobIOWorker && (clearInterval(r),
                        e("success"))
                    }, 10)
                }
                ))
            }
            ,
            Module.isBlobExists = function(e) {
                return Module.blobIOWorker ? !!Module._blobMapper[e] : (err("No blob io worker, please call 'await Module.initBlobIO()' first"),
                !1)
            }
            ,
            Module.insertBlob = function(e, t) {
                if (!Module.blobIOWorker) {
                    err("No blob io worker, please call 'await Module.initBlobIO()' first");
                    return
                }
                let r = function e(e, t) {
                    for (var r = "", i = e; i > 0; --i)
                        r += t[Math.floor(Math.random() * t.length)];
                    return r
                }(32, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
                return new Promise(function(i, n) {
                    Module._blobMapper[e] = t;
                    let o = Module.blobIOWorker;
                    o.postMessage({
                        cmd: "insertBlob",
                        url: e,
                        blob: t,
                        uuid: r
                    });
                    let a = function(e) {
                        "onInsertBlobComplete" === e.data.cmd && e.data.uuid === r && (o.removeEventListener("message", a),
                        i())
                    };
                    o.addEventListener("message", a)
                }
                )
            }
            ,
            Module.removeBlob = function(e) {
                if (!Module.blobIOWorker) {
                    err("No blob io worker, please call 'await Module.initBlobIO()' first");
                    return
                }
                let t = Module.blobIOWorker
                  , r = Module._blobMapper;
                if ("string" == typeof e)
                    delete r[e],
                    t.postMessage({
                        cmd: "removeBlob",
                        url: e
                    });
                else if (e instanceof Blob) {
                    for (let i in r)
                        if (r[i] === e) {
                            delete r[i],
                            t.postMessage({
                                cmd: "removeBlob",
                                url: i
                            });
                            break
                        }
                }
            }
            ;
        return moduleArg.ready
    }
}
)();
export default createVEModule;
