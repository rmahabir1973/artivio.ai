// processor-worker.js
import initWasm, { processFrame } from './video-processor.wasm';

class VideoProcessorWorker {
    constructor() {
        this.canvas = null;
        this.gl = null;
        this.wasmModule = null;
        this.textures = {};
        this.shaders = {};
        this.programs = {};
        
        this.init();
    }
    
    async init() {
        // Load WebAssembly module
        await this.loadWasm();
        
        // Set up message handler
        this.setupMessageHandler();
    }
    
    async loadWasm() {
        try {
            this.wasmModule = await initWasm();
            console.log('WASM module loaded successfully');
        } catch (error) {
            console.error('Failed to load WASM module:', error);
        }
    }
    
    setupMessageHandler() {
        self.onmessage = async (e) => {
            const { type, canvas, frame, width, height } = e.data;
            
            switch(type) {
                case 'init':
                    await this.initWebGL(canvas, width, height);
                    break;
                case 'process-frame':
                    await this.processFrame(frame);
                    break;
                case 'apply-effect':
                    this.applyEffect(e.data.effect, e.data.params);
                    break;
            }
        };
    }
    
    async initWebGL(offscreenCanvas, width, height) {
        this.canvas = offscreenCanvas;
        this.canvas.width = width;
        this.canvas.height = height;
        
        // Initialize WebGL2 context
        this.gl = this.canvas.getContext('webgl2', {
            alpha: false,
            antialias: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });
        
        if (!this.gl) {
            throw new Error('WebGL2 not supported');
        }
        
        // Set viewport
        this.gl.viewport(0, 0, width, height);
        
        // Initialize shaders and textures
        await this.initShaders();
        await this.initTextures();
        
        // Notify main thread that WebGL is ready
        self.postMessage({ type: 'webgl-ready' });
    }
    
    async initShaders() {
        // Vertex shader
        const vertexShaderSource = `#version 300 es
            in vec2 a_position;
            in vec2 a_texCoord;
            out vec2 v_texCoord;
            
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;
        
        // Fragment shader for basic rendering
        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec2 v_texCoord;
            out vec4 outColor;
            uniform sampler2D u_texture;
            
            void main() {
                outColor = texture(u_texture, v_texCoord);
            }
        `;
        
        // Compile shaders
        this.programs.main = this.createProgram(
            vertexShaderSource,
            fragmentShaderSource
        );
    }
    
    createProgram(vertexSource, fragmentSource) {
        const vertexShader = this.compileShader(this.gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = this.compileShader(this.gl.FRAGMENT_SHADER, fragmentSource);
        
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Program link failed:', this.gl.getProgramInfoLog(program));
            return null;
        }
        
        return program;
    }
    
    compileShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile failed:', this.gl.getShaderInfoLog(shader));
            return null;
        }
        
        return shader;
    }
    
    async initTextures() {
        // Create input and output textures
        this.textures.input = this.createTexture();
        this.textures.output = this.createTexture();
    }
    
    createTexture() {
        const texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        
        // Set texture parameters
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        return texture;
    }
    
    async processFrame(frameData) {
        if (!this.gl || !this.wasmModule) return;
        
        try {
            // Process frame using WASM for CPU-intensive operations
            const processedData = this.processWithWasm(frameData.data);
            
            // Upload to WebGL texture
            this.uploadTexture(this.textures.input, processedData, frameData.width, frameData.height);
            
            // Apply WebGL processing
            this.renderFrame();
            
            // Read back processed frame
            const outputData = this.readPixels();
            
            // Send processed frame back to main thread
            self.postMessage({
                type: 'frame-processed',
                data: {
                    data: outputData,
                    width: frameData.width,
                    height: frameData.height,
                    timestamp: frameData.timestamp
                }
            }, [outputData.buffer]);
            
        } catch (error) {
            console.error('Frame processing error:', error);
            self.postMessage({
                type: 'error',
                data: error.message
            });
        }
    }
    
    processWithWasm(frameData) {
        // Use WASM for CPU-intensive processing
        // This could include color correction, filtering, etc.
        
        const wasmMemory = new Uint8Array(this.wasmModule.memory.buffer);
        const inputPtr = this.wasmModule.allocate_buffer(frameData.length);
        
        // Copy data to WASM memory
        wasmMemory.set(frameData, inputPtr);
        
        // Process frame
        const outputPtr = processFrame(
            inputPtr,
            frameData.length,
            1920,  // width
            1080   // height
        );
        
        // Get processed data
        const processedData = wasmMemory.slice(
            outputPtr,
            outputPtr + frameData.length
        );
        
        // Free WASM memory
        this.wasmModule.free_buffer(inputPtr);
        this.wasmModule.free_buffer(outputPtr);
        
        return processedData;
    }
    
    uploadTexture(texture, data, width, height) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(
            this.gl.TEXTURE_2D,
            0,
            this.gl.RGBA8,
            width,
            height,
            0,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            data
        );
    }
    
    renderFrame() {
        this.gl.useProgram(this.programs.main);
        
        // Set up geometry
        const positions = new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1
        ]);
        
        const texCoords = new Float32Array([
            0, 0, 1, 0, 0, 1,
            0, 1, 1, 0, 1, 1
        ]);
        
        // Create buffers
        const positionBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
        
        const texCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, texCoords, this.gl.STATIC_DRAW);
        
        // Set attributes
        const positionAttrib = this.gl.getAttribLocation(this.programs.main, 'a_position');
        this.gl.enableVertexAttribArray(positionAttrib);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);
        this.gl.vertexAttribPointer(positionAttrib, 2, this.gl.FLOAT, false, 0, 0);
        
        const texCoordAttrib = this.gl.getAttribLocation(this.programs.main, 'a_texCoord');
        this.gl.enableVertexAttribArray(texCoordAttrib);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, texCoordBuffer);
        this.gl.vertexAttribPointer(texCoordAttrib, 2, this.gl.FLOAT, false, 0, 0);
        
        // Set texture
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.input);
        const textureUniform = this.gl.getUniformLocation(this.programs.main, 'u_texture');
        this.gl.uniform1i(textureUniform, 0);
        
        // Draw
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        
        // Clean up
        this.gl.deleteBuffer(positionBuffer);
        this.gl.deleteBuffer(texCoordBuffer);
    }
    
    readPixels() {
        const width = this.canvas.width;
        const height = this.canvas.height;
        const pixels = new Uint8Array(width * height * 4);
        
        this.gl.readPixels(
            0, 0,
            width, height,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            pixels
        );
        
        return pixels;
    }
    
    applyEffect(effect, params) {
        // Apply various video effects
        // This would involve switching shaders or updating uniform values
        switch(effect) {
            case 'brightness':
                this.setUniform('u_brightness', params.value);
                break;
            case 'contrast':
                this.setUniform('u_contrast', params.value);
                break;
            case 'saturation':
                this.setUniform('u_saturation', params.value);
                break;
            // Add more effects as needed
        }
    }
    
    setUniform(name, value) {
        const program = this.programs.main;
        this.gl.useProgram(program);
        const location = this.gl.getUniformLocation(program, name);
        
        if (typeof value === 'number') {
            this.gl.uniform1f(location, value);
        } else if (value.length === 2) {
            this.gl.uniform2f(location, value[0], value[1]);
        } else if (value.length === 3) {
            this.gl.uniform3f(location, value[0], value[1], value[2]);
        } else if (value.length === 4) {
            this.gl.uniform4f(location, value[0], value[1], value[2], value[3]);
        }
    }
}

// Initialize worker
new VideoProcessorWorker();